# 2.flask

## web服务器知识

### selenium 原理

```text
selenium：通过driver驱动启动一个http服务，代码通过http与服务连接，服务解析后驱动浏览器执行相应操作。因为采用这个原理所以selenium可以支持跨平台跨语言使用。以下为python采用原生方法与chromedriver服务进行连接操作；
```

```python
from selenium import webdriver
import requests


driver = webdriver.Chrome(executable_path=r"D:\code\uiautotest\docs\chromedriver.exe", port=6001)
url = "http://www.baidu.com"
sid = driver.session_id  # 获得驱动对象
print(sid)  # 720b05c53f84a63f757689559c89f1df
# driver.get(url)  # Command.GET, {'url': url}   ->  {Command.GET: ('POST', '/session/$sessionId/url')}
data = r"http://localhost:6001/session/{}/url".format(sid)  # 由driver.get方法可知，get是通过post方法请求http服务携带相关参数
res = requests.post(url=data, json={"url": url})  
print(res)  # <Response [200]>
```

* 客户端：前端（HTML+css+js），小程序，ios（oc，swift），安卓（kotlin）

  （reactnative，vue+weex），flutter（dart，），（电视，平台）桌面，c\#，c++

* 静态页面 client + web-server + 数据
* 动态页面 client + web-server + application + 数据
* wsgi

### 作业：

```python
import json
from wsgiref.simple_server import make_server

"""    支持4个url；
    get访问方式
    异常处理"""


def home(**kwargs):
    return kwargs


def index(**kwargs):
    return kwargs


def tag(**kwargs):
    return kwargs


dic = {"/": home,
       "/index": index,
       "/tag": tag}


def app(env, start_response):
    if env.get("PATH_INFO") is None or dic.get(env["PATH_INFO"]) is None:
        start_response("404 NOT FOUND", [('Content-Type', 'text/plain')])
    else:
        start_response("200 OK", [('Content-Type', 'application/json')])
        data = {"data": env.get("PATH_INFO")}
        data = dic.get(env["PATH_INFO"])(**data)
        return [json.dumps(data).encode()]


if __name__ == '__main__':
    service = make_server("", 6002, app)
    service.serve_forever()
```

六、MVC 1、组成 ·modelM==&gt;数据相关逻辑。sql boy. ·view，V返回的内容展示。==&gt; ·control，C控制器。视图函数。==&gt;接受请求，公共业务，=数据相关=响应结果 ·控制器（Controller）-负责转发请求，对请求进行处理。 ·视图（View）-界面设计人员进行图形界面设计。 ·模型（Model）-程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计（可以实现具体的功能）。

## 视图函数

1、视图装饰器应该放最外层，否则里面的装饰器不会生效。 2、视图函数包裹的装饰器不要return值，否则会被包装成返回数据。

```python
from flask import Flask

app = Flask(__name__)


def decorator(func):
    def decor(*args, **kwargs):
        print("我是个装饰器1")
        res = func(*args, **kwargs)
        print("我是个装饰器2")
        return res  # 其他装饰器必须返回视图函数的返回值

    return decor


@decorator  # 此处不会被运行到     
@app.route("/index")  # 支持叠加路由
@app.route("/")
@decorator
def index():
    return "<p style='color: red'> 蛤蛤蛤蛤蛤flask</p>"


if __name__ == '__main__':
    app.run(debug=True)
```

### 动态路由

```python
from flask import Flask

app = Flask(__name__)


@app.route("/<id>")
@app.route("/<int: id>")
@app.route("/<string: id>")  # 不支持含斜杠(/)
@app.route("/<float: id>")  # 支持含斜杠
@app.route("/<path: id>")
@app.route("/<uuid: id>")
def index(id):
    return id


if __name__ == '__main__':
    app.run(debug=True)
```

### 默认参数

```python
@app.route("/haha/", defaults={"sid": "50"})  # sid默认为50
@app.route("/haha/<sid>")
def index(sid):
    print(sid)
    return sid


@app.route("/haha/")
@app.route("/haha/<sid>")
def index(sid="sads"):  # sid默认为sads
    print(sid)
    return sid
```

> 命名要统一。设置case 访问case/ 访问不到 ； 设置case/ 访问case 将重定向至case/

**端点：**通过API可用的功能

**路由：**用于访问端点的“名称”，用于URL中

### 注册路由

注册路由有两种方法：1. 装饰器注册 2. 集中注册

小项目用装饰器，大项目用集中注册

```python
from flask import Flask

app = Flask(__name__)


@app.route("/<id>")
def index(id):
    return id


def login():
    return "login"


# 路由， 视图函数， 端点， 参数-> 请求方法等
app.add_url_rule("/login", view_func=login, endpoint="hahah", methods=["GET", "POST"])

if __name__ == '__main__':
    app.run(debug=True)
```

视图函数： 前后端不分离时，最好一个视图函数有get/post两种方法 功能不一样的话才进行分离，method不一样不分离

基于类的视图\(可插拔视图\) 两种实现方式

类视图有什么好处 类是可以继承的 代码可以复用 可以定义多种行为

```python
from functools import wraps

from flask import Flask, request
from flask.views import View, MethodView

from werkzeug.utils import redirect

app = Flask(__name__)


def decorator1(func):
    @wraps(func)  # @functools.wraps(func)的作用就是保留原有函数的名称和docstring
    def decorate1(*args, **kwargs):
        print("我是装饰器前")
        res = func(*args, **kwargs)
        print("我是装饰器后")
        return res

    return decorate1


# class UserView()

class ProjectView(View):
    # methods = ['GET', 'POST']  # 可以在类中设置， 也可以在添加路由中设置
    # decorators = (decorator1,)  # 可以在类内设置， 也可以在类外添加路由前 显式装饰

    def get(self):
        return "我是get"

    def post(self):
        return "我是post"

    def dispatch_request(self):  # 调度请求
        dispatch_pattern = {'GET': self.get, 'POST': self.post}
        method = request.method
        return dispatch_pattern.get(method)()


g = ProjectView.as_view("index")  # 视图名
d = decorator1(g)  # 装饰路由
app.add_url_rule('/index', view_func=d, methods=['GET', 'POST'])


class UserView(MethodView):
    decorators = (decorator1,)  # 可以在类内设置， 也可以在类外添加路由前 显式装饰

    def get(self, user_id="xixixi"):
        print(user_id)
        return "我是get"

    def post(self, user_id):
        return "我是post"

    def delete(self, user_id):
        # delete a single user
        pass

    def put(self, user_id):
        # update a single user
        pass


h = UserView.as_view("login")
h = decorator1(h)
app.add_url_rule('/login/<user_id>', view_func=h, methods=['GET', 'POST', 'PUT', 'DELETE'])
app.add_url_rule('/login/', view_func=h, methods=['GET', 'POST', 'PUT', 'DELETE'], defaults={"user_id": None})
if __name__ == '__main__':
    app.run(debug=True, port=3001)
```

作业： 前端上传文件后端储存

### uuid

```python
import uuid


print(uuid.uuid4())  # 62d08e22-de7b-4d4c-b3c1-6720be981bfd
```

### format

```text
3.6版本py后可以使用简写
```

```python
    haha = "xixixi"
    print(f"{haha}")
```

### 配置项

app.config

static\_url\_path 静态文件地址

static\_folder 静态文件名

debug模式：1. 代码change会自动重启 2. 有error会在前端展示

### 命令行运行flask

## 4. 请求和响应

### 4.1 请求

**获取前端传过来的请求数据是后端服务来管理的，Flask内置实现了，使用 `from flask import request`导入。**

| 名字 | 语法 | 描述 |
| :--- | :--- | :--- |
| Get请求 | request.args | 类型是ImmutableMultiDict 不可变字典。可以选择to\_dict（）转化成普通的可变字典。 |
| 表单格式 | request.form | 表单类型application/x-www-form-urlencoded |
| Json格式 | request.json | application/json |
| 文件请求 | request.files | multipart/form-data |
|  | get\_json（） | 可以强制转化 |
|  | request.values\(\) | CombinedMultiDict，内容是form和args。可以使用values替代form和args。 |
|  | request.cookies | 顾名思义，请求的cookies，类型是dict。 |
|  | request.stream | 在可知的mimetype下，如果进来的表单数据无法解码，会没有任何改动的保存到这个stream以供使用。很多时候，当请求的数据转换为string时，使用data是最好的方式。这个stream只返回数据一次。 |
| 请求头 | request.headers | 字典类型 |
|  | request.data | 包含了请求的数据，并转换为字符串，除非是一个Flask无法处理的mimetype |
|  | 文件.save\(\) | 保存文件 |
|  | secure\_filename\(\) | 格式化文件名，将空格转化为\_ |
| 环境变量 | environ | WSGI隐含的环境配置 |
| 请求方法 | request.method | 请求方法 |
| 远程ip | remote\_addr | 可以限制ip的行为 |
|  | user-agent | 提供反扒和恶意攻击 |

```python
import os
from flask import Flask, request
from werkzeug.utils import secure_filename

app = Flask(__name__)  # 定义名字


@app.route("/", methods=["GET", "POST"])
def root():
    print(request.method)  # POST or GET
    print(request.form)
    print(request.values)
    print(request.files)
    print(request.get_json(), "==============")
    print(request.stream)
    print(request.headers)
    print(request.data)
    print(request.environ)
    path = os.path.dirname(__name__)
    file = request.files.get("name")
    print(file)
    print(file.filename)
    file.save(secure_filename(file.filename))
    print(request.is_xhr)
    print(request.is_json)
    print(request.environ["CONTENT_TYPE"])
    if request.method == "GET":
        print(request.args)  # ImmutableMultiDict([('user', 'hahah')])
    elif request.method == "POST":
        print(request.json)  # {'user': 'hahahaha'}
    return "测试test"


if __name__ == '__main__':
    app.run(debug=True)
```

#### 4.1.2. request包含的信息

```text
request.is_json
request.is_xhr
```

```python
print(request.is_xhr)  # True or False
print(request.is_json)  # True or False
```

#### 4.1.3. 代理模式

request本质是一个Request对象，只能和路由请求绑定使用，单独定义一个函数使用requests是获取不到的。 从源码看BaseRequest类 ·args 是从QUERY\_STRING获取数据 ·其他很多是从environ获取数据。 ·为什么要和请求绑定，没有请求，不会生成这些环境变量。 编写单元测试的时候就要用到上下文环境。 距离说明：

#### 4.1.4. 文件上传

**可以用 flask-upload库**

注意：一定要加在ajax的data内`enctype=“multipart/form-data”`，不然浏览器不会上传。如果要使用原来的名字，要用 `secure_filename`

```text
那么secure_filename（）函数到底是有什么用？有一条原则是“永远不要信任用户输入”。这条原则同样适用已上传文件的文件名。所有提交的表单数据可能是伪造的，文件名也可以是危险的。此时要谨记：在把文件保存到文件系统之前总是要使用这个函数对文件名进行安检。
比如说上传一个文件通过相对路径来替换你系统的文件。
```

#### 4.1.5. 限制文件格式。

**确保用户不能上传HTML文件，因为HTML可能引起XSS问题（参见鹰站脚本攻击（XSS））**

```python
if file.filename in ("png"):  # 限制文件格式
    file.save(secure_filename(file.filename))
```

#### 4.1.6. 限制文件的大小

`app.config['MAX_CONTENT_LENGTH']=10*1024*1024`

```python
from flask import Flask, request
from werkzeug.utils import secure_filename

app = Flask(__name__)  # 定义名字
app.config["MAX_CONTENT_LENGTH"] = 1024*1024  # 413 Request Entity Too Large


@app.route("/", methods=["GET", "POST"])
def root():
    file = request.files.get("name")
    print(file)
    print(file.filename)
    if file.filename in ("png"):  # 限制文件格式
        file.save(secure_filename(file.filename))
        return "GG"
    if request.method == "GET":
        print(request.args)  # ImmutableMultiDict([('user', 'hahah')])
    elif request.method == "POST":
        print(request.json)  # {'user': 'hahahaha'}
    return "测试test"


if __name__ == '__main__':
    app.run(debug=True)
```

#### 4.1.7. 让文件可以访问

`send_from_directory(directory, filename, **options)`

```python
import os
from flask import Flask, send_from_directory

app = Flask(__name__)  # 定义名字


@app.route("/", methods=["GET", "POST"])
def root():

    return send_from_directory(os.path.dirname(__name__), "ludashi.jpg")


if __name__ == '__main__':
    app.run(debug=True)
```

### 4.2 响应对象

**如果不进行任何设置，返回字符串浏览器会自动把它变成HTML。**

### 4.1. 主要响应的类型 Content-Type

|  |  |
| :--- | :--- |
| 文本 | text/plain |
| HTML | text/html |
| XML | application/xml |
| json | application/json |

[https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics\_of\_HTTP/MIME\_types](https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types)

### 4.2. 手动修改响应状态码和媒体类型MIME types

```python
from flask import Flask

app = Flask(__name__)  # 定义名字


@app.route("/", methods=["GET", "POST"])
def root():

    return {"hahah": "xixixi"}, 202, {"content-type": "application/json"}
    # data status_code 

if __name__ == '__main__':
    app.run(debug=True)
```

### 4.3、实现原理make\_response

```python
import json

from flask import Flask, make_response

app = Flask(__name__)  # 定义名字


# make_response（args）的实现：
# Response（）类
# 第一种：初始化构造：
@app.route("/xx", methods=["GET", "POST"])
def root():
    a = json.dumps({"name": "dedede"})
    res = make_response(a, 201, {"content-type": "application/json"})
    return res


# 第二种实现方式，先定义在初始化
@app.route("/login")
def login():
    b = json.dumps({"name": "dedede"})
    res = make_response()
    res.response = b
    res.status = '202'
    res.headers = {"Location": "dsads", "content-type": "application/json"}
    return res


if __name__ == '__main__':
    app.run(debug=True)
```

### 4.4、json 响应格式

### 4.5、响应中文

```text
无论是使用json.dumps（）还是jsonify（），返回中文字符时的原生格式都不会直接显示中文：需要进行配置 
1. 直接在创建的falsk对象中 FLASK["JSON_AS_ASCII"] = False
2. 在进行json转换时, ensure_ascii= False
```

```python
import json

from flask import Flask, make_response

app = Flask(__name__)  # 定义名字
app.config["JSON_AS_ASCII"] = False  # 全局定义成可以返回非ASCII字符


@app.route("/xx", methods=["GET", "POST"])
def root():
    # a = json.dumps({"name": "我是中文"})  # {"name": "\u6211\u662f\u4e2d\u6587"}
    a = json.dumps({"name": "我是中文"}, ensure_ascii=False)  # {"name": "我是中文"}
    res = make_response(a, 201, {"content-type": "application/json"})
    return res


@app.route("/login")
def login():
    b = json.dumps({"name": "我是中文"})  # {"name": "我是中文"}
    res = make_response()
    res.response = b
    res.status = '202'
    res.headers = {"content-type": "application/json"}
    return res


if __name__ == '__main__':
    app.run(debug=True)
```

### 4.6、重定向 redirect

1. redirect（"/new/url"）
2. redirect（url\_for（"endpoint"）） 
3. redirect（url\_for（"路由"）） 
4. redirect（url\_for（"静态文件夹", "filename"\)\)

   **重定向**

   \`\`\`py

   @app.route\("/index", redirect\_to="/login"\)  \# 若在装饰器进行重定向将不会运行视图函数内的代码

   def index\(\):

   return redirect\("/login"\)

@app.route\("/"\) def index\(\): return redirect\("/login"\)

@app.route\("/", methods=\["GET", "POST"\]\) def root\(\): return {"hahah": "xixixi"}, 301, {"Location": "login"} \# 在请求头中有300+状态码 ， location时浏览器会自动重定向

@app.route\("/login"\) def login\(\): return {"name": "login"}

```text
## 4.7、错误响应

1. 全局错误：

装饰器
集中注册

2. 抛出异常

1. abort函数 abort实际上一种处理异常的方式
抛出定义异常状态码→ 定义全局错误模板
直接定义异常状态码及错误模板
2. raise
抛出异常 → 定义全局错误模板



















# 5. 模板引擎

## 5.1 

## 5.2 静态文件

## 5.3 变量属性

## 5.4 for循环

变量描述
loop.index当前循环迭代的次数（从1开始）
loop.index0当前循环迭代的次数（从0开始）
loop.revindex到循环结束需要迭代的次数（从1开始）
loop.revindex0到循环结束需要迭代的次数（从0开始）
loop.first如果是第一次迭代，为True。
loop.last如果是最后一次迭代，为True。
loop.length序列中的项目数。

默认每个for元素之间会有空白，如果要去除，使用-
{% for p in projects - %}
项目：{{p.name}}：{{p.interfaces}}
{%-endfor%}

## 5.5 if循环

## 5.6 消息闪现

flash()

## 5.7 可以访问的全局变量和函数

八、URL反向构建
1.反转通常比硬编码URL的描述性更好。
2.你可以只在一个地方改变URL，而不用到处乱找。
3.URL 创建会为你处理特殊字符的转义和Unicode数据，比较直观。
4.生产的路径总是绝对路径，可以避免相对路径产生副作用。
5.如果你的应用是放在URL根路径之外的地方（如在/myapplication中，不在/中），url_for（）会为你妥善处理。
<form action="{{url_for（'1ogin'）}}"，method="post">

管道命令过滤器

{#当变量未定义时，显示默认字符串，可以缩写为d#}
<p>{{name | default（'No name'，true）}}</p>
{#单词首字母大写#}
<p>{{'hel1o' | capitalize}}</p>
{#单词全小写#}
<p>{{'XML'| lower}}</p>
{#去除字符串前后的空白字符#}
<p>{{' he1lo ' | trim}}</p>
{#字符串反转，返回“o11eh”#}
<p>{{'hello' | reverse}}</p>
{#格式化输出，返回"Numberis 2”#}
<p>{{%s is %d' | format（"Number"，2）}}</p>


{#关闭HTML自动转义#}
<p>{{'<em>name</em>'I safe}}</p>
{%autoescape false%}
{#HTML转义，即使autoescape关了也转义，可以缩写为e#}
<p>{{'<em>name</em>' |  escape}}</p>
{%endautoescape%}

数字

{#四舍五入取整，返回13.0#}
<p>{{12.8888 | round}}</p>
{#向下截取到小数点后2位，返回12.88#}
<p>{{12.8888 | round（2，'floor'）}}</p>
{#绝对值，返回12#}|
<p>{{-12 | abs}}</p>

列表

{#取第一个元素#}
<p>{{[1，2，3，4，5] | first }}</p>
{#取最后一个元素#}
<p>{{[1，2，3，4，5] | last }}</p>
{#返回列表长度，可以写为count#}
<p>{{[1，2，3，4，5]|1ength }}</p>
{#列表求和#}
<p>{{[1，2，3，4，5] | sum }}</p>
{#列表排序，默认为升序#}
<p>{{[3，2，1，5，4] | sort }}</p>
{#合并为字符串，返回“1|2|3|4|5"#}
<p>{{[1，2，3，4，5] | join（'|'）}}</p>
{#列表中所有元素都全大写。这里可以用upper，lower，但capitalize无效#}
<p>{{['tom'，'bob'，'ada'] | upper }}</p>


tojson

{{user | tojson | safe（0.10之前）}}


注册过滤器

测试

除了过滤器，所谓的“测试”也是可用的。测试可以用于对照普通表达式测试一个变量。要测试一个变量或表达式，你要在变量后加上一个is以及测试的名称。例如，要得出一个值是否定义过，你可以用name is defined，这会根据name是否定义返回true或false。

测试也可以接受参数。如果测试只接受一个参数，你可以省去括号来分组它们。例如，下面的两个表达式做同样的事情：
{%if 1oop.index is divisibleby3%}
{%if loop.index is divisibleby（3）%}

内置过滤器

{#检查变量是否被定义，也可以用undefined检查是否未被定义#}
{% if name is defined %}
<p>Name is:{{ name }}</p>
{%endif%}
{#检查是否所有字符都是大写#}
{%if name is upper%}
<h2>"{{ name}}"are all upper case.</h2>
{%endif%}
{#检查变量是否为空#}
{% if name is none %}
<h2>variable is none.</h2>
{%endif%}
{#检查变量是否为字符串，也可以用number检查是否为数值#}
{% if name is string %}
<h2>{{ name}}is a string.</h2>
{%endif%}
{#检查数值是否是偶数，也可以用odd检查是否为奇数#}
{% if 2 is even%}
<h2>variable is an even number.</h2>
{%endif%}
{#检查变量是否可被迭代循环，也可以用sequence检查是否是序列#}
{%if[1，2，3]is iterable%}
<h2>variable is iterable.</h2>
{%endif%}
{#检查变量是否是字典#}
{%if{'name'：'test'}is mapping%}
<h2>variable is dict.</h2>
{%endif%}

jinja2

自定义测试 

context_processor 环境处理器

全局函数

继承

include

# 表单验证


6.
跨站脚本攻击是指在一个网站的环境中注入恶任意的HTML（包括附带的JavaScript
）。要防防御这种攻击，开发者需要正确地转义文本，使其不能包含恶意的HTML标
·不要让用户给你传HTML，IS
·脚本，对文本进行正确的转义。


# 8. 数据库和模型
## 8.1 sqlite的使用
    sqlite vs mysql好处：
    开箱即用
    小巧
    进程访问，不需要通过端口网络
    支持主流功能
    python自带
    就是一个文件。备份和迁移很方便。

## 8.2 flask如何使用数据库
### 8.2.1 sqlite使用
```py
@app.before_request 
def before_request():
    g.db=sqlite3.connect（app.config['DATABASE']）

@app.teardown_request
def teardown_request(exception):
    db=getattr（g，'db'，None）
    if db is not None：
        db.close（）
```

#### 8.2.2 MySQL使用

```python
def connect_to_database(): 
    conn = pymysql.connect(host='localhost', user='root', pas sword='', db='lemon_tester', charset='utf8mb4',cursorclass=pymysql.cursors.Dictcursor)
    return conn.cursor()

@app.route("/")
def index(): 
    db=connect_to_database()
    db.execute(' SELECT * FROM project_info;')
    res=db.fetchal1()
    print(res)
    return 'hello'
```

#### 8.2.3 封装原生SQL

## 9 SQLalchemy

### 9.3 数据模型定义的参数说明

```python
class user（db.Model）：
#表名
    __tablename__ = 'user'
    id = db.Column（db.Integer，primary_key = True）
    username = db.Column（db.string（80），unique = True, nullable = False,default = ''）
    email = db.Column（db.string（120），unique = True）
```

数据类型：

| 类型 | 描述 |
| :--- | :--- |
| Integer | 整数 |
| String（size） | 有长度限制的字符串 |
| Text | 一些较长的unicode文本 |
| Date Time | 表示为Python datetime对象的时间和日期 |
| Float | 存储浮点值 |
| Boolean | 存储布尔值 |
| Pickle Type | 存储为一个持久化的Python对象 |
| LargeBinary | 存储一个任意大的二进制数据 |

参数：

| 参数 | 描述 |
| :--- | :--- |
| db.Foreignkey（"project.id"） | 外键 |
| primary\_key | 主键，唯一标致 主键会自动自增长 |
| autoincrement | 自增长 |
| unique | 唯一 |
| index | 索引 |
| nullable | 可以为空 |
| default | 默认值 |
| comment | 说明，注释 |

### 9.4 数据库操作

#### 9.4.1. 创建表

db.create\_all\(\)

#### 9.4.2. 插入数据

```python
user=User（username='demo'）
db.session.add（user） #保存到会话。

db.session.add_a11（[userl，user2]）  #添加多个
db.session.commit（）
```

#### 9.4.3. 查询和过滤

```python
# 1、所有的all（）
users =User.query.all（）
# 2、第一个first（）
users=User.query.first（）
# 3、get（）通过主键去获取
users= User.query.get（1）

#如果有多个主键
users=User.query.get（（1，5））
users=User.query.get（{"id"：1，"project_id"：3}）
# 4、filter_by（）
admin=User.query.filter_by（username='admin'）.first（）

# 5、filter（）更加复杂的查询
User.query.filter（User.email.endswith（'Qexample.com'））.al1（）


提示：支持的字段操作：Columnoperators源码。

# 6、按某种规则对用户排序：
User.query.order_by（User.username.desc（））.all（）
[<User u'admin'>，<User u'guest'>，<user u'peter'>]
# 7、限制返回用户的数量：
User.query.order_by（user.username.desc（））.1imit（1）.all（）
[<User u'admin'>]
```

#### 9.4.4. 删除

db.session.delete（me） db.session.commit（）

#### 9.4.5. first\_or\_404没找到就abort（）和异常处理机制配合起来使用非常好。

#### 9.4.6. 数据更新

user=User（） db.session.add（user）

## 添加多个

db.session.add\_all（\[user1，user2\]） db.session.commit（）

### 9.5 分页

### 9.6 数据库迁移

### 9.7 原生sql

flask-sqlalchemy使用：

```python
def select（）：
    with app.app_context（）as ctx：
        sql='select*from user:'
        a=db.session.execute（sq1）
#a是一个ResultProxy
#print（a.fetchall（））#print（a.fetchone（）
```

原生sqlalchemy使用：

```python
def init-sql(): 
    import sqlalchemy db_engine=
    sqlalchemy.create_engine(' mysq1+pymysq1://root:Q1ocalhost/weibo', echo=True)
    db_conn=db_engine.connect()
    a=db_conn.execute(' select* from user;')
    print(a. fetchal1())
```

参数化使用：

```python
session=Session(bind=engine)
sq1=' select * from user where name= :name;'  # 传递变量
a=session.execute(sql, params={'name':'yuz'})
print(a. fetchall())
```

xampp集成环境

```python
from sqlalchemy import Column，Integer，String，create_engine 
from sqlalchemy.ext.declarative import declarative_base 
from sqlalchemy.orm import session
#映射
Base=declarative_base（）
#继承
class User（Base）：
    __tablename__='users'
    id=column（Integer，primary_key=True）
    name=Column（string（100））
    age=Column（Integer）

#绑定数据库此东西不会变，可在初始化app的时候定义
engine=credte_engine（r'sqlite:///d:\test.db'，echo=True）

#创建数据库
Base.metadata.create_all（engine）

#创建session进行操作
session=Session（bind=engine）

#增加
#user=User（id=1，name='yuze'，age=18）
#session.add（user）
#session.commit（）
#查询
a=session.query（User）.first（）
print（a.name）
#原生sQL语句
a=session.execute（"select*from users"）.fetchone（）
print（a）


ad=User(name='yuz',age=11)
session.add(ad)
session.commit()
```

ORM模型关系

多对一关系 backref

```python
class Project(db. Mode1): 
    id=db.column(db.Integer, primary_key=True)
    modules=db.relationship('Module', backref='project')

class Module(db.Mode1): 
    id=db.column(db.Integer, primary_key=True)
    project_id=db.column(db.Integer, db.Foreignkey('project.id'))
```

back\_populates

```python
class Project（db.Mode1）：
    #这里的modules和Module里面的back_populaters='modules'相等
    modules=db.relationship（'Module'，back_populates='project'）

class Module（db.Mode1）：
    #这里的project和Project 里面的back_populaters='project'相等
    project=db.relationship（'Module'，back_populates='modules'）
```

backref vs back\_populates ·back\_populates 需要双向显示说明；backref 只需要指明一边隐式声明； ·back\_populates更麻烦，backref更简单； ·back\_populates 更具有可读性，能很快知道各个表之间的关系。

一对一关系

```python
class Project（db.Mode1）：
    #这里的modules和Module里面的back_populaters='modules'相等
    modules=db.relationship（'Module'，back_populates='project'）

class Module（db.Mode1）：
    #这里的project和Project 里面的back_populaters='project'相等
    project=db.relationship（'Module'，back_populates='modules', uselist=False）
```

多对多关系

多对多关系 Table 适用场景： 1、关系表只存储2个关联表的id作为外键，没有其他信息。 2、关联表并不能作为模型操作。

```python
xuanke=db.Table（'xuanke'，db.column（'user_id'，db.Integer，db.Foreignkey（'user.id'))，db.column（'subject_id'，db.Integer，db.Foreignkey（'subject.id'））
#ORM
class User（db.Mode1）：
    id=db.column（db.Integer，primary_key=True）
    name=db.column（db.string（20））
    subjects=db.relationship（'subject'，secondary=xuanke，backref=db.backref（'users'，lazy='dynamic'），lazy='dynamic'）

# lazy查询的时候的数据加载状态select
# user =User.query.get（1）
# select:user.subjects ==>[Subjcet（），Subject（）]
# dynamic:user.subjects.filter（）.all（）==>query 对象

class subject（db.Mode1）：
    id=db.column（db.Integer，primary_key=True）
    name=db.column（db.string（20））


user.subjects # --> 获取的是Xuanke
subject.students.student  # -->
```

多对多关系需要获取额外内容

```python
class Xuanke(db. Mode1): 
    student_id=db.column(db. Integer, db. Foreignkey('user. id'), primary_key=True)
    subject_id=db.Column(db. Integer, db. Foreignkey('subject. id'), primary_key=True)

class User(db. Model): 
    id=db.column(db.Integer, primary_key=True)
    name=db.column(db.string(20), nullable=False)
    subjects=db.relationship('Xuanke', backref='user')

class subject(db. Model): 
    id=db.column(db. Integer, primary_key=True)
    name=db.column(db. string(20), nullable=False)
    students=db.relationship('Xuanke', backref='subject')

user=User.query.get（1）
#获取选课
xuanke=user.subjects
#获取课程
for ke in xuanke：
    print（ke.subject）
```

自引用关系

```python
class Follower(db. Mode1): 
    fensi_id=db. column(db. Integer, db. Foreignkey(' user. id'), primary_key=True)
    guanzhuzhe_id=db. Column(db. Integer, db. Foreignkey(' user. id'), primary_key=True)

class User(db. Mode1): 
    id=db. column(db. Integer, primary_key=True)
    name=db. column(db. string(20), nullable=False)
    fensis=db. relationship(' Follower', foreign_keys=[ Fo1lower. guanzhuzhe_id], backref=' guanzhuzhe')
    guanzhuzhes=db. relationship(' Follower', foreign_keys=[ Fo1lower. fensi_id], backref=' fensi')
```

关联查询

```python
m=db.session.query(Module,Project).filter(Project.id==Module.project_id==2).a11()
```

1、最小原型里面的app是一个函数，而flask是对象，对象被调用是执行`__ca11__`方法。 2、app._cal1_里面的函数：wsgi\_app（） 3、wsgi\_app源码：会通过环境变量数据实例化一个RequestContext（environ），并执行ctx.push（）将这个请求上下文推入一个栈中。 4、request\_ctx.push（）先判断一下是否有一个appContext，没有的话推入一个。 5、\_request\_ctx\_stack.top 就是现在的请求对象6、\_app\_ctx\_stack.top 就是现在的app对象。 1Qapp.route（'/） 2 def index（）：a=\_app\_ctx\_stack.top b=\_request\_ctx\_stack.top return'year' 7、request\_ctx\_stack.top 就是current\_app 8、\_app\_ctx\_stack.top 就是request 1current\_app=LocalProxy（\_find\_app） 2request=Localproxy（partial（\_lookup\_req\_object，'request'））

