## 4.7、错误响应

1. 全局错误：

装饰器
集中注册

2. 抛出异常

1. abort函数 abort实际上一种处理异常的方式
抛出定义异常状态码→ 定义全局错误模板
直接定义异常状态码及错误模板
2. raise
抛出异常 → 定义全局错误模板



















# 5. 模板引擎

## 5.1 

## 5.2 静态文件

## 5.3 变量属性

## 5.4 for循环

变量描述
loop.index当前循环迭代的次数（从1开始）
loop.index0当前循环迭代的次数（从0开始）
loop.revindex到循环结束需要迭代的次数（从1开始）
loop.revindex0到循环结束需要迭代的次数（从0开始）
loop.first如果是第一次迭代，为True。
loop.last如果是最后一次迭代，为True。
loop.length序列中的项目数。

默认每个for元素之间会有空白，如果要去除，使用-
{% for p in projects - %}
项目：{{p.name}}：{{p.interfaces}}
{%-endfor%}

## 5.5 if循环

## 5.6 消息闪现

flash()

## 5.7 可以访问的全局变量和函数

八、URL反向构建
1.反转通常比硬编码URL的描述性更好。
2.你可以只在一个地方改变URL，而不用到处乱找。
3.URL 创建会为你处理特殊字符的转义和Unicode数据，比较直观。
4.生产的路径总是绝对路径，可以避免相对路径产生副作用。
5.如果你的应用是放在URL根路径之外的地方（如在/myapplication中，不在/中），url_for（）会为你妥善处理。
<form action="{{url_for（'1ogin'）}}"，method="post">

管道命令过滤器

{#当变量未定义时，显示默认字符串，可以缩写为d#}
<p>{{name | default（'No name'，true）}}</p>
{#单词首字母大写#}
<p>{{'hel1o' | capitalize}}</p>
{#单词全小写#}
<p>{{'XML'| lower}}</p>
{#去除字符串前后的空白字符#}
<p>{{' he1lo ' | trim}}</p>
{#字符串反转，返回“o11eh”#}
<p>{{'hello' | reverse}}</p>
{#格式化输出，返回"Numberis 2”#}
<p>{{%s is %d' | format（"Number"，2）}}</p>


{#关闭HTML自动转义#}
<p>{{'<em>name</em>'I safe}}</p>
{%autoescape false%}
{#HTML转义，即使autoescape关了也转义，可以缩写为e#}
<p>{{'<em>name</em>' |  escape}}</p>
{%endautoescape%}

数字

{#四舍五入取整，返回13.0#}
<p>{{12.8888 | round}}</p>
{#向下截取到小数点后2位，返回12.88#}
<p>{{12.8888 | round（2，'floor'）}}</p>
{#绝对值，返回12#}|
<p>{{-12 | abs}}</p>

列表

{#取第一个元素#}
<p>{{[1，2，3，4，5] | first }}</p>
{#取最后一个元素#}
<p>{{[1，2，3，4，5] | last }}</p>
{#返回列表长度，可以写为count#}
<p>{{[1，2，3，4，5]|1ength }}</p>
{#列表求和#}
<p>{{[1，2，3，4，5] | sum }}</p>
{#列表排序，默认为升序#}
<p>{{[3，2，1，5，4] | sort }}</p>
{#合并为字符串，返回“1|2|3|4|5"#}
<p>{{[1，2，3，4，5] | join（'|'）}}</p>
{#列表中所有元素都全大写。这里可以用upper，lower，但capitalize无效#}
<p>{{['tom'，'bob'，'ada'] | upper }}</p>


tojson

{{user | tojson | safe（0.10之前）}}


注册过滤器

测试

除了过滤器，所谓的“测试”也是可用的。测试可以用于对照普通表达式测试一个变量。要测试一个变量或表达式，你要在变量后加上一个is以及测试的名称。例如，要得出一个值是否定义过，你可以用name is defined，这会根据name是否定义返回true或false。

测试也可以接受参数。如果测试只接受一个参数，你可以省去括号来分组它们。例如，下面的两个表达式做同样的事情：
{%if 1oop.index is divisibleby3%}
{%if loop.index is divisibleby（3）%}

内置过滤器

{#检查变量是否被定义，也可以用undefined检查是否未被定义#}
{% if name is defined %}
<p>Name is:{{ name }}</p>
{%endif%}
{#检查是否所有字符都是大写#}
{%if name is upper%}
<h2>"{{ name}}"are all upper case.</h2>
{%endif%}
{#检查变量是否为空#}
{% if name is none %}
<h2>variable is none.</h2>
{%endif%}
{#检查变量是否为字符串，也可以用number检查是否为数值#}
{% if name is string %}
<h2>{{ name}}is a string.</h2>
{%endif%}
{#检查数值是否是偶数，也可以用odd检查是否为奇数#}
{% if 2 is even%}
<h2>variable is an even number.</h2>
{%endif%}
{#检查变量是否可被迭代循环，也可以用sequence检查是否是序列#}
{%if[1，2，3]is iterable%}
<h2>variable is iterable.</h2>
{%endif%}
{#检查变量是否是字典#}
{%if{'name'：'test'}is mapping%}
<h2>variable is dict.</h2>
{%endif%}

jinja2

自定义测试 

context_processor 环境处理器

全局函数

继承

include

# 表单验证


6.
跨站脚本攻击是指在一个网站的环境中注入恶任意的HTML（包括附带的JavaScript
）。要防防御这种攻击，开发者需要正确地转义文本，使其不能包含恶意的HTML标
·不要让用户给你传HTML，IS
·脚本，对文本进行正确的转义。


# 8. 数据库和模型
## 8.1 sqlite的使用
    sqlite vs mysql好处：
    开箱即用
    小巧
    进程访问，不需要通过端口网络
    支持主流功能
    python自带
    就是一个文件。备份和迁移很方便。

## 8.2 flask如何使用数据库
### 8.2.1 sqlite使用
```py
@app.before_request 
def before_request():
    g.db=sqlite3.connect（app.config['DATABASE']）

@app.teardown_request
def teardown_request(exception):
    db=getattr（g，'db'，None）
    if db is not None：
        db.close（）
```

#### 8.2.2 MySQL使用

```python
def connect_to_database(): 
    conn = pymysql.connect(host='localhost', user='root', pas sword='', db='lemon_tester', charset='utf8mb4',cursorclass=pymysql.cursors.Dictcursor)
    return conn.cursor()

@app.route("/")
def index(): 
    db=connect_to_database()
    db.execute(' SELECT * FROM project_info;')
    res=db.fetchal1()
    print(res)
    return 'hello'
```

#### 8.2.3 封装原生SQL

## 9 SQLalchemy

### 9.3 数据模型定义的参数说明

```python
class user（db.Model）：
#表名
    __tablename__ = 'user'
    id = db.Column（db.Integer，primary_key = True）
    username = db.Column（db.string（80），unique = True, nullable = False,default = ''）
    email = db.Column（db.string（120），unique = True）
```

数据类型：

| 类型 | 描述 |
| :--- | :--- |
| Integer | 整数 |
| String（size） | 有长度限制的字符串 |
| Text | 一些较长的unicode文本 |
| Date Time | 表示为Python datetime对象的时间和日期 |
| Float | 存储浮点值 |
| Boolean | 存储布尔值 |
| Pickle Type | 存储为一个持久化的Python对象 |
| LargeBinary | 存储一个任意大的二进制数据 |

参数：

| 参数 | 描述 |
| :--- | :--- |
| db.Foreignkey（"project.id"） | 外键 |
| primary\_key | 主键，唯一标致 主键会自动自增长 |
| autoincrement | 自增长 |
| unique | 唯一 |
| index | 索引 |
| nullable | 可以为空 |
| default | 默认值 |
| comment | 说明，注释 |

### 9.4 数据库操作

#### 9.4.1. 创建表

db.create\_all\(\)

#### 9.4.2. 插入数据

```python
user=User（username='demo'）
db.session.add（user） #保存到会话。

db.session.add_a11（[userl，user2]）  #添加多个
db.session.commit（）
```

#### 9.4.3. 查询和过滤

```python
# 1、所有的all（）
users =User.query.all（）
# 2、第一个first（）
users=User.query.first（）
# 3、get（）通过主键去获取
users= User.query.get（1）

#如果有多个主键
users=User.query.get（（1，5））
users=User.query.get（{"id"：1，"project_id"：3}）
# 4、filter_by（）
admin=User.query.filter_by（username='admin'）.first（）

# 5、filter（）更加复杂的查询
User.query.filter（User.email.endswith（'Qexample.com'））.al1（）


提示：支持的字段操作：Columnoperators源码。

# 6、按某种规则对用户排序：
User.query.order_by（User.username.desc（））.all（）
[<User u'admin'>，<User u'guest'>，<user u'peter'>]
# 7、限制返回用户的数量：
User.query.order_by（user.username.desc（））.1imit（1）.all（）
[<User u'admin'>]
```

#### 9.4.4. 删除

db.session.delete（me） db.session.commit（）

#### 9.4.5. first\_or\_404没找到就abort（）和异常处理机制配合起来使用非常好。

#### 9.4.6. 数据更新

user=User（） db.session.add（user）

## 添加多个

db.session.add\_all（\[user1，user2\]） db.session.commit（）

### 9.5 分页

### 9.6 数据库迁移

### 9.7 原生sql

flask-sqlalchemy使用：

```python
def select（）：
    with app.app_context（）as ctx：
        sql='select*from user:'
        a=db.session.execute（sq1）
#a是一个ResultProxy
#print（a.fetchall（））#print（a.fetchone（）
```

原生sqlalchemy使用：

```python
def init-sql(): 
    import sqlalchemy db_engine=
    sqlalchemy.create_engine(' mysq1+pymysq1://root:Q1ocalhost/weibo', echo=True)
    db_conn=db_engine.connect()
    a=db_conn.execute(' select* from user;')
    print(a. fetchal1())
```

参数化使用：

```python
session=Session(bind=engine)
sq1=' select * from user where name= :name;'  # 传递变量
a=session.execute(sql, params={'name':'yuz'})
print(a. fetchall())
```

xampp集成环境

```python
from sqlalchemy import Column，Integer，String，create_engine 
from sqlalchemy.ext.declarative import declarative_base 
from sqlalchemy.orm import session
#映射
Base=declarative_base（）
#继承
class User（Base）：
    __tablename__='users'
    id=column（Integer，primary_key=True）
    name=Column（string（100））
    age=Column（Integer）

#绑定数据库此东西不会变，可在初始化app的时候定义
engine=credte_engine（r'sqlite:///d:\test.db'，echo=True）

#创建数据库
Base.metadata.create_all（engine）

#创建session进行操作
session=Session（bind=engine）

#增加
#user=User（id=1，name='yuze'，age=18）
#session.add（user）
#session.commit（）
#查询
a=session.query（User）.first（）
print（a.name）
#原生sQL语句
a=session.execute（"select*from users"）.fetchone（）
print（a）


ad=User(name='yuz',age=11)
session.add(ad)
session.commit()
```

ORM模型关系

多对一关系 backref

```python
class Project(db. Mode1): 
    id=db.column(db.Integer, primary_key=True)
    modules=db.relationship('Module', backref='project')

class Module(db.Mode1): 
    id=db.column(db.Integer, primary_key=True)
    project_id=db.column(db.Integer, db.Foreignkey('project.id'))
```

back\_populates

```python
class Project（db.Mode1）：
    #这里的modules和Module里面的back_populaters='modules'相等
    modules=db.relationship（'Module'，back_populates='project'）

class Module（db.Mode1）：
    #这里的project和Project 里面的back_populaters='project'相等
    project=db.relationship（'Module'，back_populates='modules'）
```

backref vs back\_populates ·back\_populates 需要双向显示说明；backref 只需要指明一边隐式声明； ·back\_populates更麻烦，backref更简单； ·back\_populates 更具有可读性，能很快知道各个表之间的关系。

一对一关系

```python
class Project（db.Mode1）：
    #这里的modules和Module里面的back_populaters='modules'相等
    modules=db.relationship（'Module'，back_populates='project'）

class Module（db.Mode1）：
    #这里的project和Project 里面的back_populaters='project'相等
    project=db.relationship（'Module'，back_populates='modules', uselist=False）
```

多对多关系

多对多关系 Table 适用场景： 1、关系表只存储2个关联表的id作为外键，没有其他信息。 2、关联表并不能作为模型操作。

```python
xuanke=db.Table（'xuanke'，db.column（'user_id'，db.Integer，db.Foreignkey（'user.id'))，db.column（'subject_id'，db.Integer，db.Foreignkey（'subject.id'））
#ORM
class User（db.Mode1）：
    id=db.column（db.Integer，primary_key=True）
    name=db.column（db.string（20））
    subjects=db.relationship（'subject'，secondary=xuanke，backref=db.backref（'users'，lazy='dynamic'），lazy='dynamic'）

# lazy查询的时候的数据加载状态select
# user =User.query.get（1）
# select:user.subjects ==>[Subjcet（），Subject（）]
# dynamic:user.subjects.filter（）.all（）==>query 对象

class subject（db.Mode1）：
    id=db.column（db.Integer，primary_key=True）
    name=db.column（db.string（20））


user.subjects # --> 获取的是Xuanke
subject.students.student  # -->
```

多对多关系需要获取额外内容

```python
class Xuanke(db. Mode1): 
    student_id=db.column(db. Integer, db. Foreignkey('user. id'), primary_key=True)
    subject_id=db.Column(db. Integer, db. Foreignkey('subject. id'), primary_key=True)

class User(db. Model): 
    id=db.column(db.Integer, primary_key=True)
    name=db.column(db.string(20), nullable=False)
    subjects=db.relationship('Xuanke', backref='user')

class subject(db. Model): 
    id=db.column(db. Integer, primary_key=True)
    name=db.column(db. string(20), nullable=False)
    students=db.relationship('Xuanke', backref='subject')

user=User.query.get（1）
#获取选课
xuanke=user.subjects
#获取课程
for ke in xuanke：
    print（ke.subject）
```

自引用关系

```python
class Follower(db. Mode1): 
    fensi_id=db. column(db. Integer, db. Foreignkey(' user. id'), primary_key=True)
    guanzhuzhe_id=db. Column(db. Integer, db. Foreignkey(' user. id'), primary_key=True)

class User(db. Mode1): 
    id=db. column(db. Integer, primary_key=True)
    name=db. column(db. string(20), nullable=False)
    fensis=db. relationship(' Follower', foreign_keys=[ Fo1lower. guanzhuzhe_id], backref=' guanzhuzhe')
    guanzhuzhes=db. relationship(' Follower', foreign_keys=[ Fo1lower. fensi_id], backref=' fensi')
```

关联查询

```python
m=db.session.query(Module,Project).filter(Project.id==Module.project_id==2).a11()
```

1、最小原型里面的app是一个函数，而flask是对象，对象被调用是执行`__ca11__`方法。 2、app._cal1_里面的函数：wsgi\_app（） 3、wsgi\_app源码：会通过环境变量数据实例化一个RequestContext（environ），并执行ctx.push（）将这个请求上下文推入一个栈中。 4、request\_ctx.push（）先判断一下是否有一个appContext，没有的话推入一个。 5、\_request\_ctx\_stack.top 就是现在的请求对象6、\_app\_ctx\_stack.top 就是现在的app对象。 1Qapp.route（'/） 2 def index（）：a=\_app\_ctx\_stack.top b=\_request\_ctx\_stack.top return'year' 7、request\_ctx\_stack.top 就是current\_app 8、\_app\_ctx\_stack.top 就是request 1current\_app=LocalProxy（\_find\_app） 2request=Localproxy（partial（\_lookup\_req\_object，'request'））

