## 部署流程（暂）
> 1.打包 → 2.上传 → 3.解压 → 4.安装py3 → 5.虚拟环境 → 6.安装包 → 7.gunicorn → 8.nginx → 9.进程管理 → 10.测试

**解压**
```sh
# 方式一：
[ -d "${LOG}" ] || mkdir -p ${LOG} # -p 递归创建目录，如果没有目标目录上级也会自动创建
[ -d "${BIN}" ] || mkdir -p ${BIN}
[ -d "${SYSTEM_SERVICE}" ] || mkdir -p ${SYSTEM_SERVICE}

# 方式二
PROJECT_DIR="$HOME/Projects"
PROJECT_NAME='deve1'
CODE_PATH="$HOME/devel.tar.gz"
function unpack_code
{
    if[ ! -d "${PROJECT_DIR}" ]; then  # 如果没该目录就创建目录
    {
        echo "${PROJECT_DIR} is't existed."
        mkdir -p ${PROJECT_DIR} && echo "created ${PROJECT_DIR} successfully!" || echo "created ${PROJECT_DIR} failed！"
    }
    cd "${PROJECT_DIR}"
    [ -e "${PROJECT_NAME}" ] && rm-rf "${ PROJECT_NAME}"  # 如果已经有该文件，就删除
    tar -xvzf "${CODE_PATH}" ./
}
```


## 介绍

    Docker：汽车引擎
    Dockerfile：汽车图纸
    Images：类似于样板车
    Container：把一些汽车的零件，拼接在一起
    Docker compose：老司机
    Docker volume：汽车的油箱
    Docker swarm：交通枢组
    Docker Registry：4s店
---
    docker是C/S设计，docker build 命令拿到上下文地址时会将路径下内容打包上传到docker引擎进行构建
### vmware 和 docker 优劣

|特性|虚拟机|容器|
|-|-|-|
|隔离级别|内核级(操作系统)|进程级|
|隔离策略|Hypervisor|CGroups|
|系统资源|5-15%|0-5%|
|启动时间|分钟级|秒级|
|镜像存储|GB-TB|KB-MB|
|集群规模|上百|上万|
|高可用策略|备份、容灾、迁移|弹性、负载、动态|

---
### docker通用

```sh
docker exec -itd # 在运行的容器中执行命令 -d :分离模式: 在后台运行  -i :即使没有附加也保持STDIN 打开  -t :分配一个伪终端

docker images
# 查看本地镜像仓库


```
---
### docker images
```docker
docker image --help  # 查看images下的帮助

docker pull IMAGE_NAME:TAG # 从仓库中拉取镜像

docker rmi python:3-alpine  # 删除本地镜像 镜像名:标签
docker rmi c7abf446d82f # 删除本地镜像 IMAGE ID   长ID为镜像ID全称 短ID一般取前3位数即可

docker inspect nginx:latest  # 查看镜像的详细信息

docker tag IMAGE_ID NEW_IMAGE_NAME:NEW_TAG  # 修改目标镜像的名字和标签
```
---
创建镜像
```sh
docker build -t image_name:latest .
# -t 参数指定容器镜像的名称和标签;"." 号把当前目录设为构建过程中的顶级目录

docker build -t image_name:latest -f dockerfile_1 .  # -f 指定dockerfile文件
``` 
---
### docker container
```sh
docker container --help  # 查看容器下的帮助

docker commit -m "提交的描述信息" -a "镜像作者" CONTAINER_ID NEW_IMAGE_NAME:NEW_TAG
# -m 提交的描述信息 -a 镜像作者 容器ID  指定要创建的目标镜像名和标签
```
列出容器
```sh
docker ps # 查看顶层容器

docker ps -a # 查看全部容器
```
启动容器
```sh
docker container run IMAGE_NAME  # 构建指定镜像(不常用)
docker run IMAGE_NAME # (常用)

docker run IMAGE_NAME COMMAND # 在启动容器命令后加上COMMAND 将会在容器内执行COMMAND

docker run --name CONTAINER_NAME IMAGE_NAME  # 构建容器时指定容器名

docker run --name container_name -d -p 8000:5000 -e SECRET_KEY=57d40f677 -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> image_name:latest
# --name 指容器名；
# -d 孤立模式启动容器(在系统的后台作业中运行容器) ；
# -p 把宿主系统的 8000 端口映射到容器的 5000 端口上, 默认tcp模式；
# -e 设定环境变量；
# 最后的image_name:latest  指定使用镜像:标签

docker run -P IMAGE_NAME  # -P 随机分配端口进行映射

docker run -p 8000:5000/udp IMAGE_NAME # -p 将容器5000端口绑定宿主机8000端口用UDP模式

docker run -it IMAGE /bin/bash  # 构建指定镜像并进入该容器 -i 交互 -t 终端

docker run --rm IMAGE_NAME   # 容器运行结束后自我删除
```
操作容器
```sh
docker stop CONTAINER_ID
# 停止指定的容器进程

docker rm CONTAINER_ID  # 常用
docker container rm CONTAINER_ID
# 删除指定的容器

docker rm -f CONTAINER_ID  # 容器停止后才可以删除
# 停止并删除指定容器

docker container top CONTAINER_ID || CONTAINER_NAME # 查看容器内部进程 可以用容器ID，也可以用容器名(正在运行)
docker top CONTAINER_ID || CONTAINER_NAME

docker stats CONTAINER_ID || CONTAINER_NAME # 查看容器资源使用情况 可以用容器ID，也可以用容器名(正在运行)

docker stop CONTAINER_ID || CONTAINER_NAME  # 停止容器

docker restart CONTAINER_ID || CONTAINER_NAME  # 重启容器

docker pause CONTAINER_ID || CONTAINER_NAME  # 暂停容器运行

docker unpause CONTAINER_ID || CONTAINER_NAME  # 恢复暂停的容器运行

docker inspect CONTAINER_ID || CONTAINER_NAME  # 容器详情

docker logs CONTAINER_ID || CONTAINER_NAME # 容器日志

docker export CONTAINER_ID > file.tar  # 导出容器快照

docker import file.tar IMAGE_NAME:TAG_NAME  # 导入容器快照
```
---
## network

- bridge桥接
    - nat网络模型
    - 虚拟交换机
- host
    - 与宿主机共享网络
    - --net=host
- none
    - 不配置网络
        - --net=none
- overlay
    - 不同网络进行通讯


```sh
docker network ls  # 查看网络

ip a # 里面的docker0 为容器分配的网关段
ifconfig

# 新增网络类型
docker network create --driver DRIVER_NAME NETWORK_NAME # 创建新的网络类型
docker network create -d DRIVER_NAME NETWORK_NAME  # 常用

# 查看网络模式详情
docker network inspect NETWORK_NAME

# 删除网络模式
docker network rm NETWORK_NAME

# 配置容器网关模式
docker run --network NETWORK_NAME IMAGE_NAME /bin/bash  # 配置为bridge模式
docker run --net NETWORK_NAME IMAGE_NAME /bin/bash # 常用
# 容器a与容器b是同一个网关模式，就建立了互联关系

apt install iputils-ping # tips：容器内可通过该命令安装ping

docker network create -d subnet 172.16.100.0/24 NETWORK_NAME
# -d：参数指定 Docker 网络类型
```
DNS
    
    /etc/docker/daemon.json  # 在宿主机该文件上可以修改DNS.原有容器需重启生效
    /etc/resolv.conf  # 在容器上该文件可以看容器DNS
```sh
docker run --dns=114.114.114.114 --dns-search=test.com IMAGE_NAME
# -h HOSTNAME 设置主机名 会写到容器 /etc/hostname 和 /etc/hosts
# --dns=IP_ADDRESS 设置解析服务器地址
# --dns-search=DOMAIN 设定容器的搜索域
```
/etc/docker/daemon.json
```json
{
  "dns" : [
    "114.114.114.114",
    "8.8.8.8"
  ]
}
```
## Docker Volume 数据持久化
- 数据卷 可以在容器之间共享和重用
- 对 数据卷 的修改会立马生效
- 对 数据卷 的更新，不会影响镜像
- 数据卷 默认会一直存在，即使容器被删除
```sh
docker run -v $PWD/html:/usr/share/nginx/html nginx  # 挂载  宿主机目录:容器目录 映射 

docker volume create DATA_VOLUME  # 创建数据卷

docker volume inspect DATA_VOLUME  # 查看数据卷详情

docker volume rm DATA_VOLUME  # 删除数据卷，需要无容器使用时

 docker volume prune # 删除无主的数据卷

 docker run -d --mount source=my-vol,target=/webapp ubuntu:18.04 /bin/sh # --mount给容器挂载数据卷 source宿主机目录/数据卷 target容器目录  
```
## dockerfile
两种格式
```dockerfile
# dockerfile全部关键字都支持exec格式和shell格式

CMD ["boot.sh"]  # exec格式, 该格式执行shell时需要  sh -c 
ENTRYPOINT ls /  # shell格式
```
    CMD与RUN区别:
        - CMD 在docker run 时默认运行
        - RUN 是在 docker build
    CMD:
        - 可被 docker run 命令行参数中指定要运行的程序所覆盖。
        - 如果 Dockerfile 中如果存在多个 CMD 指令，仅最后一个生效
```dockerfile
FROM ubuntu  # 定制的镜像都是基于 FROM 的镜像
LABEL # 指明作者
```
---
RUN
```dockerfile
RUN python -m venv file  # 执行命令 shell格式
RUN ["命令", "参数1", "参数2"]  # 执行命令 exec格式
# 注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大。

RUN command1 param1 param2 && command2 param1 param2 
# 按这种链式执行的话，只有一层 知识点：分层存储
```
---
ENV & ARG
```dockerfile
ENV username hahah
ENV username=hahah # 容器的环境变量

ARG name xixi
ARG name=bibi

RUN echo "$username"  # 前面的环境变量可以在容器中或之后的命令中使用
RUN echo "$name" # ARG的环境变量仅能在dockersfile文件中使用
```
---
CMD & ENTRYPOINT
```dockerfile
CMD ["<可执行文件或命令>","<param1>","<param2>",...]  # 每次 docker run时默认运行

# 如果CMD与ENTRYPOINT一起使用，CMD可给ENTRYPOINT当参数
ENTRYPOINT ["sh"] # 仅最后一个生效
CMD ["boot.sh"]  # 相当于  sh boot.sh  当启动容器时带有其他参数，会覆盖掉CMD的运行。常用来当默认参数使用
```
例如
```sh
docker run IMAGE_NAME # 此时启动容器会运行  sh boot.sh
docker run IMAGE_NAME xixi.sh  # 此时启动容器会运行 sh xixi.sh
```
---
COPY & ADD
```dockerfile
COPY app app # 将宿主机文件复制到容器中
# [--chown=<user>:<group>]：可选参数，用户改变复制到容器内文件的拥有者和属组。

ADD www.baidu.com # 比copy多两个特性：能解压压缩文件，然后复制到镜像；能远程下载 缺点：在不解压的前提下，无法复制 tar 压缩文件。导致性能不佳
```
---
```dockerfile
WORKDIR /home/project # 切换到该目录（定义应用所在的顶层目录）

USER <用户名>[:<用户组>] # 指定用户和组 需提前创建好

VOLUME <路径> # 默认指定挂载 或者是原有的数据卷  如果 run时有指定挂载会被覆盖

EXPOSE 5000 # 仅用于声明端口
```
实例
```dockerfile
From python:3-alpine3.9
LABEL fungagis

WORKDIR /usr/src/app

COPY app app
ADD app.tar.gz app

RUN pip install -r requirements.txt

CMD ['python', 'run.py']
```
---
## docker hub  公开镜像
```sh
docker login
# 登录docker hub

docker logout
# 推出docker hub

docker search KEYWORD # 搜索仓库中的镜像

docker tag container_name:latest <dockerhub_username>/container_name:latest
# 修改镜像名称和标签

docker push <dockerhub_username>/container_name:latest
# 推送镜像到hub
```
## Docker Compose 
### 安装卸载
安装: 建议linux系统使用二进制包
```sh
sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose

sudo chmod +x /usr/local/bin/docker-compose
```
bash 补全命令(可选)
```sh
curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose
```
卸载
```sh
sudo rm /usr/local/bin/docker-compose
```
### 术语:
- 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。
- 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。

### 运行
docker-compose.yml
```yml
version: '3'
services:

  web:
    build: .
    ports:
     - "5000:5000" # 宿主机：容器

  redis:
    image: "redis:alpine"
```
`docker-compose up`

    - 会生成默认项目名
    - 默认网络

### 命令说明
    -f 指定使用的构建模板文件,默认docker-compose.yml
    -p 指定项目名,默认使用所在目录名作为项目名

build

### 模板文件
```yml
version: '3'
services:

  webapp:
    build: # 指定上下文和文件名
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1
  app:
    build: ./dir # 默认dockerfile
```
```yml
version: '3'

services:
  web:
    build: .
    depends_on:  # 指定依赖，当数组中容器启动后，才启动当前容器
      - db
      - redis

  redis:
    image: redis

  db:
    image: postgres
```
- build: 指定dockerfile所在文件夹的路径,绝对路径/相对于yml的路径,默认dockerfile
    - context: 指定上下文
    - dockerfile: 指定文件名
- command:覆盖容器启动后默认执行的命令
- container_name:指定容器名称
- depends_on:依赖启动顺序,但不会等待到完全启动
- dns: 自定义DNS服务器
- env_file: 设置环境变量的文件(数组)
- environment: 环境编列(可以用数字/字典形式)
- expose: 暴露容器端口
- image: 指定构建的镜像名称/ID
- labels: 辅助说明
- ports: "HOST:CONTAINER" 互联端口信息,如果只给出容器端口则会随便分配一个宿主端口(数组)
```yml
version: "3"

services:
  my_src:
    image: mysql:8.0
    restart: always # 重启策略
    volumes:
      - mysql_data:/var/lib/mysql  # 只有全局指定了匿名数据卷才可以做映射
    environment:
        MYSQL_ROOT_PASSWORD: 123456
        MYSQL_DATABASE: dev01

volumes:  # 声明要创建的匿名volumes
  mysql_data:
```

- volumes: 也可以全局使用
    - 宿主机路径(HOST:CONTAINER)
    - 数据卷名称(VOLUME:CONTAINER) 需要额外在文件中配置
    - 访问模式 （HOST:CONTAINER:ro）

## docker swarm 集群
    特点：
        集群
        大型应用
        高性能、高效率、高可用
        无中心设计
        横向、纵向伸缩
        多主机网络
        服务发现
        负载均衡
        回滚更新

    架构
        manager 侧重管理
        worker 侧重服务

    集群采用overlay，所以集群中每个node都可以相互通信（即访问任意节点ip都可访问）
    自动重启服务
### 初始化(docker swarm)
    创建manager`docker swarm init --advertise-addr string localhost:2377 --listen-addr localhost:2377`

    添加worker`docker swarm join --token XXX` 此处运行在创建manager时提供的命令即可

### 节点操作(docker node) 只能在manager中使用
    查询集群节点`docker node ls` 

    查看节点详细信息`docker node inspect node_name`
    详细信息格式化`docker node inspect node_name --pretty`

    提权操作 `docker node promote worker_name`

    降权操作 `docker node demote woreker_name`

    查看进程 `docker node ps node_name`

### service 服务 只能在manager中使用

    创建服务 `docker service create --name application_name -p 宿主机port:container port --constraint "node.role == worker" nginx`

    创建扩容6个容器 `docker service create --replicas=6 ……`

    扩容已有的 `docker service scale application_name=6`

    查看服务 `docker service ls`
    查看服务详情 `docker service inspect application_name`
    格式化`docker service inspect application_name --pretty`

    删除服务 `docker servcice rm application_name`

### stack 集群中启动多个服务
    deploy只能在集群中使用
```yml
version: "3"
services:
    application:
        image: nginx
        ports:
            - "8080:80"
        depoly:
            # 默认replicated,可以创建多个副本，global只可以创建一个容器
            mode: replicated
            # 启动容器数量
            replicas: 6
            restart_policy:
                condition: on-failure
                delay: 5s  # 默认为0
                max_attempts: 3  # 最大重启数
            placement:
                constarints:  # 指定创建角色
                    - node.role == worker

```

启动容器 `docker stack deploy --compose-file docker-compose.yml application_name `  启动后自动创建默认网络和服务

查看服务：`docker stack ls`

查看进程 `docker stack ps application_name`

portainer 容器编排工具
