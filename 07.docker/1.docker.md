## 1. 介绍

参考资料:https://yeasy.gitbook.io/docker_practice/

* Docker：汽车引擎
* Dockerfile：汽车图纸
* Images：类似于样板车
* Container：把一些汽车的零件，拼接在一起
* Docker compose：老司机
* Docker volume：汽车的油箱
* Docker swarm：交通枢组
* Docker Registry：4s店

### 1.1 Docker的CS模式
#### 1.1.1 步骤
1. Docker Client中来运行Docker的各种命令(docker build etc.)
2. 这些命令会传送给在Docker的宿主机上运行的Docker的守护进程(Server)
3. 守护进程是负责来实现Docker的各种功能
4. 守护进程将命令执行的结果返回给客户端

#### 1.1.2 Remote API(不过多介绍)
Docker提供了守护进程对外的通信接口,支持自定义程序与其集成
[官方文档](https://docs.docker.com/engine/api/)
### 1.2 vmware 和 docker 优劣

|特性|虚拟机|容器|
|-|-|-|
|隔离级别|内核级(操作系统)|进程级|
|隔离策略|Hypervisor|CGroups|
|系统资源|5-15%|0-5%|
|启动时间|分钟级|秒级|
|镜像存储|GB-TB|KB-MB|
|集群规模|上百|上万|
|高可用策略|备份、容灾、迁移|弹性、负载、动态|

## 2. 命令
### 2.1 docker通用

1. `docker exec -u root container_id -it`
- d: 分离模式, 在后台运行, 不能与另外两个一起使用
- i: 即使没有附加也保持STDIN 打开
- t: 分配一个伪终端
- u: 进入的用户 可搭配: `-u root` 以root权限进入

2. 查看本地镜像仓库: `docker images`

### 2.2 镜像管理

- 查看images下的帮助: `docker image --help`
- 从仓库中拉取镜像(无tag默认拉取最新): `docker pull IMAGE_NAME:TAG`
- 删除本地镜像 镜像名:标签: `docker rmi python:3-alpine`
- 删除本地镜像 IMAGE ID(长ID为镜像ID全称;短ID一般取前3位数即可): `docker rmi c7abf446d82f` or `docker rmi c7a`
- 查看镜像的详细信息(ID or 名称:标签): `docker inspect nginx:latest`
- 修改目标镜像的名字和标签: `docker tag IMAGE_ID NEW_IMAGE_NAME:NEW_TAG`
- 创建镜像: `docker build -t image_name:latest .`
    - -t 参数指定容器镜像的名称和标签
    - "." 号把当前目录设为构建过程中的顶级目录
    - 默认创建脚本为"Dockerfile"
    - 指定创建脚本
        - `docker build -t image_name:latest -f dockerfile_1 .`

### 2.3 容器管理

- 查看容器下的帮助: `docker container --help`
- 从容器中创建镜像: `docker commit -m "提交的描述信息" -a "镜像作者" CONTAINER_ID NEW_IMAGE_NAME:NEW_TAG`
    - `-m` 提交的描述信息 
    - `-a` 镜像作者 
    - 容器ID  
    - 指定要创建的目标镜像名和标签
- 查看容器进程
    - 查看顶层容器: `docker ps`
    - 查看全部容器: `docker ps -a`
- 启动容器
    - 构建指定镜像(不带tag将pull latest版本)(不常用): `docker container run IMAGE_NAME`
    - (常用): `docker run -d IMAGE_NAME:tag`
        - `-d`: 以后台daemon的方式运行
    - -P 随机分配端口进行映射: `docker run -P IMAGE_NAME`
    - 将容器5000端口绑定宿主机8000端口用UDP模式: `docker run -p 8000:5000/udp IMAGE_NAME`
    - 构建指定镜像并进入该容器: `docker run -it IMAGE /bin/sh`
        - `-i` 交互
        - `-t` 终端
        - `/bin/sh`一定在后面声明使用的解释器(alpine一般只有sh)
    - 容器运行结束后自我删除: `docker run --rm IMAGE_NAME`
    - 在启动容器命令后加上COMMAND 将会在容器内执行COMMAND :`docker run IMAGE_NAME COMMAND`
    - 构建容器时指定容器名: `docker run --name CONTAINER_NAME IMAGE_NAME`
    - 链接其他容器(非常不推荐使用,建议使相关容器绑定新建的网络): `docker run -d --link <name or id>:alias IMAGE_NAME`
        -  `<name or id>`: name和id是源容器的name和id
        -  `alias`: 源容器在link下的别名
        -  链接后双方间可以互相使用 `alias` or `name` or `id` 进行通信

- example: `docker run --name container_name -d -p 8000:5000 -e SECRET_KEY=57d40f677 -e MAIL_USERNAME=<your-gmail-username> -e MAIL_PASSWORD=<your-gmail-password> image_name:latest`
    - --name 指容器名；
    - -d 以后台daemon的方式运行
    - -p 把宿主系统的 8000 端口映射到容器的 5000 端口上, 默认tcp模式；
    - -e 设定环境变量；
    - 最后的image_name:latest  指定使用镜像:标签


- 操作容器(可用容器ID或名字)
    - 停止指定的容器进程: `docker stop CONTAINER_ID`
    - 删除指定的容器(需在终结状态): `docker rm CONTAINER_ID`
        - 不推荐使用: `docker container rm CONTAINER_ID`
    - 删除运行中的容器: `docker rm -f CONTAINER_ID`
    - 查看容器内部进程: `docker top CONTAINER_ID`
        - 不推荐使用: `docker container top CONTAINER_ID`
    - 查看容器资源使用情况: `docker stats CONTAINER_ID`
    - 启动容器: `docker start CONTAINER_ID`
    - 重启容器: `docker restart CONTAINER_ID`
    - 暂停容器运行: `docker pause CONTAINER_ID`
    - 恢复暂停的容器运行: `docker unpause CONTAINER_ID`
    - 杀掉容器: `docker kill CONTAINER_ID`
    - 容器详情: `docker inspect CONTAINER_ID`
    - 容器日志: `docker logs CONTAINER_ID`
    - 导出容器快照: `docker export CONTAINER_ID > file.tar`
    - 导入容器快照: `docker import file.tar IMAGE_NAME:TAG_NAME`
    - 进入容器: `docker exec -it CONTAINER_ID /bin/sh`
    - 以root权限进入容器: `docker exec -it -u root CONTAINER_ID /bin/sh`
    - 复制容器内文件到主机: `docker cp CONTAINER_ID:/dir_path target_path`
    - 复制主机文件到容器: `docker cp 主机地址 容器ID:容器地址`

## 2. network

- bridge桥接
    - nat网络模型
    - 虚拟交换机
- host
    - 与宿主机共享网络
    - --net=host
- none
    - 不配置网络
        - --net=none
- overlay
    - 不同网络进行通讯

- 查看网络: docker network ls
    - ip a # 里面的docker0 为容器分配的网关段
    - ifconfig

- 新增网络类型
    - 创建新的网络类型: `docker network create -d DRIVER_NAME NETWORK_NAME`
        - `docker network create --driver DRIVER_NAME NETWORK_NAME`
- 查看网络模式详情: `docker network inspect NETWORK_NAME`
- 删除网络模式: `docker network rm NETWORK_NAME`
- 配置容器网关模式: `docker run --net NETWORK_NAME IMAGE_NAME /bin/bash`
    - `docker run --network NETWORK_NAME IMAGE_NAME /bin/bash`

**容器a与容器b是同一个网关模式，就建立了互联关系**
- tips
    - 容器内可通过该命令安装ping: `apt install iputils-ping`

- 新建指定网桥ip的网络类型: `docker network create -d DRIVER_NAME --subnet=172.16.100.0/24 NETWORK_NAME`
    - `--subnet`: 网桥ip
    - `-d`：参数指定 Docker 网络类型


### 2.1 DNS
    
- 在宿主机该文件上可以修改DNS.原有容器需重启生效: `/etc/docker/daemon.json`
- 在容器上该文件可以看容器DNS:`/etc/resolv.conf`

- 指定镜像运行的网络: `docker run --dns=114.114.114.114 --dns-search=test.com IMAGE_NAME`
    - `-h HOSTNAME` 设置主机名 会写到容器 /etc/hostname 和 /etc/hosts
    - `--dns=IP_ADDRESS` 设置解析服务器地址
    - `--dns-search=DOMAIN` 设定容器的搜索域

`/etc/docker/daemon.json`
```json
{
  "dns" : [
    "114.114.114.114",
    "8.8.8.8"
  ]
}
```

## 3. Docker Volume 数据持久化
- 数据卷 可以在容器之间共享和重用
- 对 数据卷 的修改会立马生效
- 对 数据卷 的更新，不会影响镜像
- 数据卷 默认会一直存在，即使容器被删除
- 数据卷存放在`/var/lib/docker/volumes`文件夹中某一个文件夹下面的`_data`文件夹

tips：
- volume是空的而container中的目录有内容，那么docker会将container目录中的内容拷贝到volume中，
- volume中已经有内容，则会将container中的目录覆盖

### 3.1 常用操作
- 挂载指定数据卷(没有会创建):`docker run -v VOLUME_NAME:/usr/share/nginx/html IMAGE_NAME` 
- 挂在匿名数据卷: `docker run -v /usr/share/nginx/html IMAGE_NAME`
- 挂载指定地址数据卷（宿主机地址必须从根目录开始）:`docker run -v $PWD/html:/usr/share/nginx/html IMAGE_NAME`
    - `-v`: 数据卷(可选):容器目录:模式(可选)
        - 模式:(默认读写)
            - `rw`:读写
            - `ro`:只读
- 挂载:`docker run -d --mount source=my-vol,target=/webapp ubuntu:18.04 /bin/sh`
    - --mount给容器挂载数据卷
        - source宿主机目录/数据卷
        - target容器目录

- 创建数据卷:`docker volume create DATA_VOLUME`
- 查看数据卷详情:`docker volume inspect DATA_VOLUME`
- 删除数据卷，需要无容器使用时:`docker volume rm DATA_VOLUME`
- 删除容器时,一起删除数据卷:`docker rm -v CONTAINER_ID`
- 删除无主的数据卷:`docker volume prune`

### 3.2 共享数据卷容器
1. 先创建一个专门用于同其他容器挂载的已挂载容器: `docker run -v data_volume:/container_path --name volume_container_name IMAGE_NAME`
2. 将其他需要共享的容器挂载到该容器上：`docker run --volumes-form volume_container_name IMAGE_NAME`

- 删除共享数据卷，必须将所有关联容器全部删掉

## 4. dockerfile构建文件

### 4.1 格式
**dockerfile全部关键字都支持exec格式和shell格式**

```dockerfile
CMD ["boot.sh"]  # exec格式(官方推荐), 该格式执行shell时需要  sh -c 
ENTRYPOINT ls /  # shell格式
```

```dockerfile
FROM ubuntu  # 定制的镜像都是基于 FROM 的镜像
LABEL # 指明作者
```

### 4.2 RUN
**注意：Dockerfile 的指令每执行一次都会在 docker 上新建一层。所以过多无意义的层，会造成镜像膨胀过大.可选用分层存储的方式尽量规避**

```dockerfile
RUN python -m venv file  # 执行命令 shell格式
RUN ["命令", "参数1", "参数2"]  # 执行命令 exec格式

# 分层存储
RUN command1 param1 param2 && command2 param1 param2  # 按这种链式执行的话，只有一层
```

#### tips:

1. `CMD`与`RUN`区别:
    - `CMD`:在`docker run`时默认运行的启动命令
    - `RUN`:在`docker build`时运行
2. `CMD`:
    - 可被`docker run`命令行参数中指定要运行的程序所覆盖
    - 如果`Dockerfile`中如果存在多个 CMD 指令，仅最后一个生效

### 4.3 ENV & ARG
- `ENV`: 容器的环境变量
- `ARG`: dockerfile文件内部变量

```dockerfile
ENV username hahah
ENV username=hahah # 容器的环境变量

ARG name xixi
ARG name=bibi  # 内部变量

RUN echo "$username"  # 前面的环境变量可以在容器中或之后的命令中使用
RUN echo "$name" # ARG的环境变量仅能在dockerfile文件中使用
```

### 4.4 CMD & ENTRYPOINT
- `CMD`:容器启动时默认的可执行体,当有ENTRYPOINT时为默认参数,可被覆盖
- `ENTRYPOINT`:容器启动时默认的可执行体,当存在CMD时,将会把CMD当做默认参数使用,`--entrypoint` `run`时使用该参数会被覆盖.

```dockerfile
CMD ["<可执行文件或命令>","<param1>","<param2>",...]  # 每次 docker run时默认运行

# 如果CMD与ENTRYPOINT一起使用，CMD可给ENTRYPOINT当参数
ENTRYPOINT ["sh"] # 仅最后一个生效
CMD ["boot.sh"]  # 相当于  sh boot.sh  当启动容器时带有其他参数，会覆盖掉CMD的运行。常用来当默认参数使用
```

#### 4.4.2 Example:
```sh
docker run IMAGE_NAME # 此时启动容器会运行  sh boot.sh
docker run IMAGE_NAME xixi.sh  # 此时启动容器会运行 sh xixi.sh
```

### 4.5 COPY & ADD
- `COPY source target`: 将宿主机文件复制到容器中
- `ADD`:比copy多两个特性
    1. 能解压压缩文件,然后复制到镜像
    2. 能远程下载
    3. 缺点：在不解压的前提下,无法复制tar压缩文件.导致性能不佳

```dockerfile
COPY app app # 将宿主机文件复制到容器中
# [--chown=<user>:<group>]：可选参数，用户改变复制到容器内文件的拥有者和属组。

ADD www.baidu.com # 比copy多两个特性：能解压压缩文件，然后复制到镜像；能远程下载 缺点：在不解压的前提下，无法复制 tar 压缩文件。导致性能不佳
```

### 4.6 其余
- `WORKDIR`: 切换到该目录（定义应用所在的顶层目录）
- `USER <用户名>[:<用户组>]`: 指定用户和组 需提前创建好
- `VOLUME <路径>`: 默认指定挂载 或者是原有的数据卷,如果`run`时有指定挂载会被覆盖
- `EXPOSE port`: 用于声明端口

```dockerfile
WORKDIR /home/project # 切换到该目录（定义应用所在的顶层目录）

USER <用户名>[:<用户组>] # 指定用户和组 需提前创建好

VOLUME <路径> # 默认指定挂载 或者是原有的数据卷  如果 run时有指定挂载会被覆盖

EXPOSE 5000 # 仅用于声明端口
```
实例
```dockerfile
From python:3-alpine3.9
LABEL fungagis

WORKDIR /usr/src/app

COPY app app
ADD app.tar.gz app

RUN pip install -r requirements.txt

CMD ['python', 'run.py']
```


## 5. docker hub  公开镜像
- `docker login`: 登录docker hub
- `docker logout`: 退出docker hub
- `docker search KEYWORD`: 查找仓库中的镜像
- `docker tag container_name:latest <dockerhub_username>/container_name:latest`: 修改镜像名称和标签
- `docker push <dockerhub_username>/container_name:latest`: 推送镜像到hub

## 6. Docker Compose（单机多容器管理）
### 6.1 安装卸载
- 安装: 建议linux系统使用二进制包

```sh
sudo curl -L https://github.com/docker/compose/releases/download/1.25.5/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose

- sudo chmod +x /usr/local/bin/docker-compose
```

- 命令行补全提示(可选)

```sh
curl -L https://raw.githubusercontent.com/docker/compose/1.25.5/contrib/completion/bash/docker-compose > /etc/bash_completion.d/docker-compose
```

- 卸载

```sh
sudo rm /usr/local/bin/docker-compose
```
### 6.2 术语:
- 服务 (service)：一个应用容器，实际上可以运行多个相同镜像的实例。
- 项目 (project)：由一组关联的应用容器组成的一个完整业务单元。

### 6.3运行
常用文件名: `docker-compose.yml`
```yml
version: '3'
services:

  web:
    build: .
    ports:
     - "5000:5000" # 宿主机：容器

  redis:
    image: "redis:alpine"
```

运行: `docker-compose up -d`
- 会生成默认项目名
- 默认网络
- `-f` 指定使用的构建模板文件,默认docker-compose.yml
- `-p` 指定项目名,默认使用所在目录名作为项目名
- `-d` 以后台daemon的方式运行

### 6.4 build(构建)

#### 6.4.1 模板文件
```yml
version: '3'
services:

  webapp:
    build: # 指定上下文和文件名
      context: ./dir
      dockerfile: Dockerfile-alternate
      args:
        buildno: 1
  app:
    build: ./dir # 默认dockerfile
```
```yml
version: '3'

services:
  web:
    build: .
    depends_on:  # 指定依赖，当数组中容器启动后，才启动当前容器
      - db
      - redis

  redis:
    image: redis

  db:
    image: postgres
```
- build: 指定dockerfile所在文件夹的路径,绝对路径/相对于yml的路径,默认dockerfile
    - context: 指定上下文
    - dockerfile: 指定文件名
    - command:覆盖容器启动后默认执行的命令
    - container_name:指定容器名称
    - depends_on:依赖启动顺序,但不会等待到完全启动
    - dns: 自定义DNS服务器
    - env_file: 设置环境变量的文件(数组)
    - environment: 环境编列(可以用数字/字典形式)
    - expose: 暴露容器端口
    - image: 指定构建的镜像名称/ID
    - labels: 辅助说明
    - ports: "HOST:CONTAINER" 互联端口信息,如果只给出容器端口则会随便分配一个宿主端口(数组)
```yml
version: "3"

services:
  my_src:
    image: mysql:8.0
    restart: always # 重启策略
    volumes:
      - mysql_data:/var/lib/mysql  # 只有全局指定了匿名数据卷才可以做映射
    environment:
        MYSQL_ROOT_PASSWORD: 123456
        MYSQL_DATABASE: dev01

volumes:  # 声明要创建的匿名volumes
  mysql_data:
```

- volumes: 也可以全局使用
    - 宿主机路径(HOST:CONTAINER)
    - 数据卷名称(VOLUME:CONTAINER) 需要额外在文件中配置
    - 访问模式 （HOST:CONTAINER:ro）

## 7. docker swarm 集群(已淘汰，目前推荐学习k8s)
- 特点：
    - 集群
    - 大型应用
    - 高性能、高效率、高可用
    - 无中心设计
    - 横向、纵向伸缩
    - 多主机网络
    - 服务发现
    - 负载均衡
    - 回滚更新
- 架构
    - manager 侧重管理
    - worker 侧重服务

    集群采用overlay，所以集群中每个node都可以相互通信（即访问任意节点ip都可访问）
    自动重启服务
### 7.1 初始化(docker swarm)
- 创建manager`docker swarm init --advertise-addr string localhost:2377 --listen-addr localhost:2377`
- 添加worker`docker swarm join --token XXX` 此处运行在创建manager时提供的命令即可

### 7.2 节点操作(docker node) 只能在manager中使用
- 查询集群节点`docker node ls` 
- 查看节点详细信息`docker node inspect node_name`
- 详细信息格式化`docker node inspect node_name --pretty`
- 提权操作 `docker node promote worker_name`
- 降权操作 `docker node demote woreker_name`
- 查看进程 `docker node ps node_name`

### service 服务 只能在manager中使用

- 创建服务 `docker service create --name application_name -p 宿主机port:container port --constraint "node.role == worker" nginx`
- 创建扩容6个容器 `docker service create --replicas=6 ……`
- 扩容已有的 `docker service scale application_name=6`
- 查看服务 `docker service ls`
- 查看服务详情 `docker service inspect application_name`
- 格式化`docker service inspect application_name --pretty`
- 删除服务 `docker servcice rm application_name`

### stack 集群中启动多个服务
deploy只能在集群中使用
```yml
version: "3"
services:
    application:
        image: nginx
        ports:
            - "8080:80"
        depoly:
            # 默认replicated,可以创建多个副本，global只可以创建一个容器
            mode: replicated
            # 启动容器数量
            replicas: 6
            restart_policy:
                condition: on-failure
                delay: 5s  # 默认为0
                max_attempts: 3  # 最大重启数
            placement:
                constarints:  # 指定创建角色
                    - node.role == worker

```

- 启动容器 `docker stack deploy --compose-file docker-compose.yml application_name `  启动后自动创建默认网络和服务
- 查看服务：`docker stack ls`
- 查看进程 `docker stack ps application_name`



## 8. 部署流程（暂）
> 1.打包 → 2.上传 → 3.解压 → 4.安装py3 → 5.虚拟环境 → 6.安装包 → 7.gunicorn → 8.nginx → 9.进程管理 → 10.测试

**解压**
```sh
# 方式一：
[ -d "${LOG}" ] || mkdir -p ${LOG} # -p 递归创建目录，如果没有目标目录上级也会自动创建
[ -d "${BIN}" ] || mkdir -p ${BIN}
[ -d "${SYSTEM_SERVICE}" ] || mkdir -p ${SYSTEM_SERVICE}

# 方式二
PROJECT_DIR="$HOME/Projects"
PROJECT_NAME='deve1'
CODE_PATH="$HOME/devel.tar.gz"
function unpack_code
{
    if[ ! -d "${PROJECT_DIR}" ]; then  # 如果没该目录就创建目录
    {
        echo "${PROJECT_DIR} is't existed."
        mkdir -p ${PROJECT_DIR} && echo "created ${PROJECT_DIR} successfully!" || echo "created ${PROJECT_DIR} failed！"
    }
    cd "${PROJECT_DIR}"
    [ -e "${PROJECT_NAME}" ] && rm-rf "${ PROJECT_NAME}"  # 如果已经有该文件，就删除
    tar -xvzf "${CODE_PATH}" ./
}
```

