# shell命令常用

## 快捷键

| 快捷键 | 作 用 |
| :--- | :--- |
| Ctrl+A | 把光标移动到命令行开头。如果我们输入的命令过长，则在想要把光标移动到命令行开头时使用 |
| Ctrl+E | 把光标移动到命令行结尾 |
| Ctrl+C | 强制中止当前的命令 |
| Ctrl+L | 淸屏，相当于 clear 命令 |
| Ctrl+U | 刪除或剪切光标之前的命令。假设输入了一行很长的命令，无须使用退格键一个一个字符地刪除， 使用这个快捷键会更加方便 |
| Ctrl+K | 删除或剪切光标之后的内容 |
| Qrl+Y | 粘贴 Ctrl+U 或 Ctrl+K 剪切的内容 |
| Ctrl+R | 在历史命令中搜索，按下 Ctrl+R 组合键之后，就会出现搜索界面，只要输入搜索内容，就会从历史命令中搜索 |
| Ctrl+D | 退出当前终端 |
| Ctrl+Z | 暂停，并放入后台。这个快捷键涉及工作管理的内容，我们会在后续中详细介绍 |
| Ctrl+S | 暂停屏幕输出 |
| Ctrl+Q | 恢复屏幕输出 |
| Tab | 自动补充，点击两下会显示所有文件，例如：输入a，点击两下Tab，会显示出所有a开头的文件 |

## 多命令顺序

| 多命令执行符 | 格 式 | 作 用 |
| :--- | :--- | :--- |
| ； | 命令1 ; 命令2 | 多条命令顺序执行，命令之间没有任何逻辑关系 |
| && | 命令1 && 命令2 | 如果命令1正确执行（$?=0\)，则命令2才会执行&lt;/p&gt;如果命令1执行不正确（$?≠0\)，则命令2不会执行 |
| II | 命令1 \|\| 命令2 | 如果命令1执行不正确（$?≠0\)，则命令2才会执行&lt;/p&gt;如果命令1正确执行（$?=0\)，则命令2不会执行 |

```text
qydev@qydev011:~$ ls /root/test && echo "yes"||echo "no" #如果/root/test存在，则会打印yes;如果/root/test不存在，则会打印no
```

## echo

```text
qydev@qydev011:~$ echo "hello word" #直接打印内容
hello word

qydev@qydev011:~$ echo -n "hello word"  #加入了 "-n"选项，则在输出内容结束后，不会换行，直接显示新行的提示符
hello word[qydev@qydev011:~]$

qydev@qydev011:~$ echo -e "ab\bc"   #加入了 "-e"选项，可以支持控制字符，如表下表所示
ac
```

## history

```text
qydev@qydev011:~$ history #显示系统中的历史命令
…省略部分输出…
421 chmod 755 hello.sh
422/root/sh/hello.sh
423 ./hello.sh
424 bash hello.sh
425 history

qydev@qydev011:~$ !! #重复执行上一条命令，即将425命令再次执行

qydev@qydev011:~$ !bash #重复执行最后一条以bash开头的命令，即将424命令再次执行

qydev@qydev011:~$ vi !$ # "!$"代表上一条命令的最后一个参数,假如上一条命令是424,则"!$"就是hello.sh
```

## grep

```text
grep [选项] "搜索内容" 文件名

qydev@qydev011:~$ grep "400,Bad Request" test100.jtl #打印出test100.jtl文件中所有含"400,Bad Request"的内容

qydev@qydev011:~$ grep -c "400,Bad Request" test100.jtl #打印出test100.jtl文件中所有含"400,Bad Request"的行数

qydev@qydev011:~$ grep -i "400,Bad Request" test100.jtl #打印出test100.jtl文件中所有含"400,Bad Request"的内容，同时忽略大小写
```

## find（同grep属于精准查询）

```text
qydev@qydev011:~$ find -name "abc" #精确查找abc文件
```

## source

source 命令会强制执行脚本中的全部命令，而忽略脚本文件的权限。该命令主要用于让重新配置的环境变量配置文件强制生效。

```text
qydev@qydev011:~$ source 配置文件
或
qydev@qydev011:~$.配置文件          # "."就是 source 命令，使用哪种方法都是可以的。
```

## cut

grep 命令是在文件中提取符合条件的行，也就是分析一行的信息，如果行中包含需要的信息，就把该行提取出来。

而如果要进行列提取，就要利用 cut 命令了。不过要小心，虽然 cut 命令用于提取符合条件的列，但是也要一行一行地进行数据提取。也就是说，先要读取文本的第一行数据，在此行中判断是否有符合条件的字段，然后再处理第二行数据。我们也可以把 cut 成为字段提取命令。

```text
qydev@qydev011:~$ cut [选项] 文件名
```

选项：

* -f 列号：提取第几列；
* -d 分隔符：按照指定分隔符分割列；
* -c 字符范围：不依赖分隔符来区分列，而是通过字符范围（行首为 0）来进行字段提取。"n-"表示从第 n 个字符到行尾；"n-m"表示从第 n 个字符到第 m 个字符；"-m"表示从第 1 个字符到第 m 个字符；

## ll\(小写LL\)

```text
qydev@qydev011:~$ ll  #查看当前文件夹下文件的长格式
总用量 9948
drwxrwxr-x 2 qydev qydev     4096 5月   6 14:52 ./
drwxrwxr-x 4 qydev qydev     4096 5月   6 20:04 ../
-rw-rw-r-- 1 qydev qydev 10169098 5月   5 20:43 test100.jtl
-rw-rw-r-- 1 qydev qydev     7497 5月   5 20:38 test100.txt
```

## env和set

```text
qydev@qydev011:~$ env    #查看环境变量
qydev@qydev011:~$ set    #查看所有变量
```

## \|\(通道符\)

在 Bash 中，管道符使用"丨"代表。管道符也是用来连接多条命令的，如"命令1丨命令2"。不过和多命令顺序执行不同的是，用管道符连接的命令，命令 1 的正确输出作为命令 2 的操作对象。这里需要注意，命令 1 必须有正确输出，而命令 2 必须可以处理命令 1 的输出结果；而且命令 2 只能处理命令 1 的正确输出，而不能处理错误输出。

```text
qydev@qydev011:~$ ps -ef | grep jmeter #查看当前所有进程，然后从其中查找与jmeter相关的服务
qydev    16278  5469  0 20:48 pts/20   00:00:00 grep --color=auto jmeter
```

## 通配符

| 通配符 | 作 用 |
| :--- | :--- |
| ? | 匹配一个任意字符 |
| \* | 匹配 0 个或任意多个任意字符，也就是可以匹配任何内容 |
| \[\] | 匹配中括号中任意一个字符。例如，\[abc\] 代表一定匹配一个字符，或者是 a,或者是 b,或 者是 c |
| \[-\] | 匹配中括号中任意一个字符，- 代表一个范围。例如，\[a-z\] 代表匹配一个小写字母 |
|  | 逻辑非，表示匹配不是中括号内的一个字符。例如， 代表匹配一个不是数字的字符 |

```text
qydev@qydev011:~$ ls ????100.jtl #查找test100.jtl、auto100.jtl这一类文件,1个?代表一个字符

qydev@qydev011:~$ ls *100.jtl #查找test100.jtl、ab100.jtl这一类文件,*代表0或多个字符

qydev@qydev011:~$ ls * #查看当前文件夹下所有文件名，*代表0或多个字符

qydev@qydev011:~$ ls [a]* #查看当前文件夹下a开头的所有文件

qydev@qydev011:~$ ls [0-9]* #查看当前文件夹下数字开头的所有文件

qydev@qydev011:~$ ls [^0-9]* #查看当前文件夹下非数字开头的所有文件
```

## 双引号” “、单引号‘ ’

引号有单引号和双引号之分，二者的主要区别在于，被单引号括起来的字符都是普通字符，就算特殊字符也不再有特殊含义；而被双引号括起来的字符中，"$"、"\"和反引号是拥有特殊含义的，"$"代表引用变量的值，而反引号代表引用命令。

```text
qydev@qydev011:~$ name=sc
qydev@qydev011:~$ echo ’$name‘   #单引号作为普通字符

qydev@qydev011:~$ echo “$name”   #双引号可以引用
sc

qydev@qydev011:~$ echo “\”   #同直接执行\，反斜杠一般用作转义字符
```

## \( \)、{ }

在执行一串命令时，如果使用的是小括号，则这串命令所做的修改只在子 Shell 中生效，一旦命令执行结束，回到父 Shell 中，这个修改就会丟失；而如果使用的是大括号，则此串命令直接在父 Shell 中执行，命令执行结束后，修改依然会生效。

* \(\) 执行一串命令时，需要重新开启一个子 Shell 来执行。
* {} 执行一串命令时，在当前 Shell 中执行。
* \(\) 和 {} 都是把一串命令放田括号里面，并且命令之间用";"隔开。
* \(\) 最后一条命令可以不用分号。
* {} 最后一条命令要用分号。
* {} 的第一条命令和左括号之间必须有一个空格。
* \(\) 里的各命令不必和括号有空格。
* \(\) 和 {} 中括号里面的某条命令的重定向只影响该命令，但括号外的重定向则会影响到括号里的所有命令。

关于父 Shell 和子 Shell，大家可以想象成在 Windows 中我们开启了一个"cmd"字符操作终端，那么 Windows 本身就是父 Shell，而"cmd"终端则是子 Shell；也可以理解为在一个操作界面中又开启了一个操作界面。

## $

我们需要调用变量时，需要在变量名之前加入"$"符号。

```text
qydev@qydev011:~$ name=ab
qydev@qydev011:~$ echo $name
ab
```

## $\( \)

如果需要调用命令的输出，或把命令的输出赋予变量，则命令必须使用反引号包含，这条命令才会执行，反引号的作用和 $\(命令\) 是一样的，但是反引号非常容易和单引号搞混，所以推荐大家使用 $\(命令\) 的方式引用命令的输出。

```text
qydev@qydev011:~$ echo $(date)  #date为打印时间的命令，命令中套用命令要用$()
```

## ${ }

一般情况下，$var与${var}是没有区别的，但是用${ }会比较精确的界定变量名称的范围。

```text
qydev@qydev011:~$ A=(a b c def)
qydev@qydev011:~$ ${A[0]}  #返回数组第一个元素a，当出现空格符号等字符时${}可以精准圈定范围。
```

## $\(\( \)\)或$\[\]

```text
qydev@qydev011:~$ echo $((2*3))     #用于整数运算
6

qydev@qydev011:~$ echo $((2#110))     #其中，2为进制，110为该进制下某个数值，命令执行后可以得到该进制数转成十进制后的值。
6
```

## \(\( \)\)

```text
用于重定义变量值

qydev@qydev011:~$ a=5;b=7
qydev@qydev011:~$ ((a++));echo $a  
6
qydev@qydev011:~$ ((a<b));echo $?  
0
qydev@qydev011:~$ ((a>b));echo $?  
1
```

## $?、$、$!

$?是上一条命令执行的结果，如果 $? 返回值是 0，则证明上一条命令正确执行；如果 $? 返回值是非 0，则证明上一条命令执行错误。

| 预定义变量 | 作 用 |
| :--- | :--- |
| $? | 最后一次执行的命令的返回状态。如果这个变量的值为 0，则证明上一条命令正确执行；如果这 个变量的值为非 0 \(具体是哪个数由命令自己来决定\)，则证明上一条命令执行错误 |
| $$ | 当前进程的进程号（PID\) |
| $! | 后台运行的最后一个进程的进程号（PID\) |

## 变量

```text
name=sc  #定义变量name的值，用户自定义变量只在当前的 Shell 中生效

qydev@qydev011:~$ unset name   #删除自定义变量name，清空变量而不是调用变量所以不用加符号
```

* 变量名可以由字母、数字和下画线组成，但是不能以数字开头。如果变量名是"2name"，则是错误的。
* 在 Bash 中，变量的默认类型都是字符串型，如果要进行数值运算，则必须指定变量类型为数值型。
* 变量用等号"="连接值，"="左右两侧不能有空格。这是 Shell 语言特有的格式要求。
* 变量值中如果有空格，则需要使用单引号或双引号包含，如 test="hello world!"。双引号括起来的内容"$"和反引号者都拥有特殊含义，而单引号括起来的内容都是普通字符。
* 在变量值中，可以使用转义符"\"。
* 如果需要増加变量值，那么可以进行变量叠加。

  变量叠加可以使用两种格式："$变量名"或 ${变量名}。

* 如果要把命令的执行结果作为变量值赋予变量，则需要使用反引号或 $\(\) 包含命令。
* 环境变量名建议大写，便于区分。

## 位置参数（命令行参数）

当一条命令或脚本执行时，后面可以跟多个参数，我们使用位置参数变量来表示这些参数。

其中，$0 代表命令行本身，$1 代表第 1 个参数，$2 代表第 2 个参数，依次类推。当参数个数超过 10 个时，就要用大括号把这个数字括起来，例如，${10} 代表第 10 个参数，${14} 则代表第 14 个参数。

$_、$@区别：假如使用for循环时，$_会把所有参数视为一个整体，只循环1次;$@会把每一个参数视为一个整体，循环n次

| 位置参数变量 | 作 用 |
| :--- | :--- |
| $n | n 为数字，$0 代表命令本身，$1〜$9 代表第 1〜9 个参数，10 以上的参数需要用大括号包含， 如${10} |
| $\* | 这个变量代表命令行中所有的参数，把所有的参数看成一个整体 |
| $@ | 这个变量也代表命令行中所有的参数，不过 $@ 把每个参数区别对待 |
| $\# | 这个变量代表命令行中所有参数的个数 |

## read

```text
qydev@qydev011:~$ read [选项] [变量名]

qydev@qydev011:~$ read -t 30 -p "Please input your name、age:" name age
Please input your name、age:fengyibo 24
qydev@qydev011:~$ echo $name
fengyibo
qydev@qydev011:~$ echo $age
24
```

选项：

* -p "提示信息"：在等待read输入时，输出提示信息；
* -t 秒数：read命令会一直等待用户输入，使用此选项可以指定等待时间；
* -n 字符数：read命令只接收指定的字符数就会执行；
* -s： 隐藏输入的数据，适用于机密信息的输入；

变量名：

* 变量名可以自定义。如果不指定变量名，则会把输入保存到默认变量REPLY中；
* 如果只提供了一个变量名，则将整个输入行赋予该变量；
* 如果提供了一个以上的变量名，则输入行分为若干字，一个接一个地赋予各个变量，而命令行上的最后一个变量取得剩余的所有字；

## 数据类型（数字、字符串、数组）

```text
qydev@qydev011:~$ A="a b c def"   # 定义字符串,所有的变量的默认类型是字符串型
qydev@qydev011:~$ A=(a b c def)   # 定义字符数组

qydev@qydev011:~$ echo ${A[*]}    # 打印数组中的左右内容
qydev@qydev011:~$ echo ${A[1]}    # 打印数组中的第二个变量
```

## declare声明变量类型

```text
qydev@qydev011:~$ declare [+/-] [选项] 变量名

qydev@qydev011:~$ aa=1
qydev@qydev011:~$ bb=2
qydev@qydev011:~$ declare -i cc=$aa+$bb #声明变量cc的类型是整数型，它的值是aa和bb的和
qydev@qydev011:~$ echo $cc
3
```

选项：

* -：给变量设定类型属性；
* +：取消变量的类型属性；
* -a：将变量声明为数组型；
* -i：将变量声明为整数型（integer）；
* -r：将变量声明为只读变量。注意，一旦设置为只读变量，既不能修改变量的值，也不能删除变量，甚至不能通过 +r 取消只读属性；
* -x：将变量声明为环境变量；
* -p：显示指定变量的被声明的类型；

## 运算符

| 符号 | 功能 |
| :--- | :--- |
| + - \* / % | 分别为加、减、乘、除、余数运算\(模\) |
| & \| ^ ! | 分别为“AND、OR、XOR、NOT” |
| =,+=,•=，\*=,/=,%=,&=, \|=, &lt;&lt;=, &gt;&gt;= | 赋值、运算且赋值 |
| == ,!= | 等于、不等于 |
| &lt;=, &gt;=, &lt;, &gt; | 小于或等于、大于或等于、小于、大于 |
| &lt;&lt;, &gt;&gt; | 按位左移、按位右移 |

## 变量测试与内容置换

| 变量置换方式 | 变量y没有设置 | 变量y为空值 | 变量y设置值 |
| :--- | :--- | :--- | :--- |
| x=${y-新值} | x= 新值 | x 为空 | x=$y |
| x=${y:-新值} | x= 新值 | x= 新值 | x=$y |
| x=${y+新值} | x 为空 | x= 新值 | x=新值 |
| x=${y:+新值} | x 为空 | x 为空 | x=新值 |
| x=${y=新值} | x= 新值 | x 为空 | x=$y |
| y= 新值 | y 值不变 | y值不变 |  |
| x=${y:=新值} | x= 新值 | X= 新值 | x=$y |
| y= 新值 | y= 新值 | y值不变 |  |
| x=${y?新值} | 新值输出到标准错误输出（屏幕） | x 为空 | x=$y |
| x=${y:?新值} | 新值输出到标准错误输出 | 新值输出到标准错误输出 | x=$y |

如果大括号内没有":"，则变量 y 为空或没有被设置，处理方法是不同的；如果大括号内有":"，则变量 y 不论是为空，还是没有被设置，处理方法是一样的。

如果大括号内是"-"或"+"，则在改变变量 x 的值的时候，变量 y 的值是不改变的；如果大括号内是"="，则在改变变量 x 的值的同时，变量 y 的值也会改变。

如果大括号内是"?"，则当变量 y 不存在或为空时，会把"新值"当成报错输出到屏幕上。

