# 1. 简介
Django 本身基于 MVC 模型，即 Model（模型）+ View（视图）+ Controller（控制器）设计模式

MVC优势:
- 低耦合
- 开发快捷
- 部署方便
- 可重用性高
- 维护成本低

框架特点:
- 强大的数据库功能
- 自带强大的后台功能
- 优雅的路由

## django3 新特性
1. 支持ASGI（异步服务器网关接口）
- 支持WebSocket, 性能提升了3~5倍

## MVC与MTV模型
在django中因为Controller绝大部分情况下由框架自动处理,不需要使用者做什么东西.所以又为MTV模式.

MVC模型
- 模型（M）- 编写程序应有的功能，负责业务对象与数据库的映射(ORM)。
- 视图（V）- 图形界面，负责与用户的交互(页面)。
- 控制器（C）- 负责转发请求，对请求进行处理。

MTV模型
- M 表示模型（Model）：编写程序应有的功能，负责业务对象与数据库的映射(ORM)。
- T 表示模板 (Template)：负责如何把页面(html)展示给用户。
- V 表示视图（View）：负责业务逻辑，并在适当时候调用 Model和 Template。

除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template

响应顺序:
1. Web服务器（中间件）收到一个http请求 
2. Django在URLconf里查找对应的视图(View)函数来处理http请求 
3. 视图函数调用相应的数据模型来存取数据、调用相应的模板向用户展示页面 
4. 视图函数处理结束后返回一个http的响应给Web服务器 
5. Web服务器将响应发送给客户端 

## ORM 对象关系映射
使用 ORM 的好处：
- 提高开发效率。
- 不同数据库可以平滑切换。

使用 ORM 的缺点：
- ORM 代码转换为 SQL 语句时，需要花费一定的时间，执行效率会有所降低。
- 长期写 ORM 代码，会降低编写 SQL 语句的能力。

ORM 解析过程:
- ORM 会将 Python 代码转成为 SQL 语句。
- SQL 语句通过 pymysql 传送到数据库服务端。
- 在数据库中执行 SQL 语句并将结果返回。

![对应关系表](./image/ORM映射.png)

# 2. 基本使用
## 2.1 安装方法
1. 使用pip工具即可安装django: `pip install django`
2. 从github中下载
## 2.2 创建工程(project)
1. `django-admin startproject project_name`会在命令行所在目录生成project_name子目录
2. `django-admin startproject project_name .`(第四个参数指定目录)会在命令行所在目录生成相关文件
### 2.2.2 默认生成工程目录
1. `setting.py`初始化配置,项目有关参数配置
2. `urls.py`url配置表(urlconf),添加加载子路由信息
3. `wsgi.py`python服务网关标准
4. `asgi.py`异步网关(支持websocket, 3.X+新增特性)

|文件|描述|
|-|-|
|manage.py|以多种方式与Django项目交互的命令行工具|
|mysite|与项目根目录同名，项目相关的包|
|mysite/settings.py|项目全局配置文件|
|mysite/urls.py|声明的全局ur1路由表|
|mysite/wsgi.py|兼容WSGI协议的web服务器入口文件|
### 非默认文件
1. `migrations`存储应用的数据库表结构的指令
2. `db.sqlite3`默认数据库
## 2.3 启动工程
1. `python manage.py runserver` 会启动web服务器,具有django欢迎页面
2. `python manage.py runserver ip：端口` 指定运行ip和端口
## 2.4 生成应用(application)
1. `python manage.py startapp application_name` 生成文件应用
2. `django-admin startapp application_name` 与上个命令效果一样
### 2.4.2 
|文件|描述|
|-|-|
|migrations|用于存放数据库迁移历史记录的目录|
|admin.py|跟网站的后台管理站点配置相关的文件|
|apps.py|用于配置当前子应用相关信息的文件|
|models.py|保存数据库模型类|
|tests.py|用于编写单元测试|
|views.py|用于编写Web应用视图|
#### 默认生成应用目录
1. `admin.py`django管理工具
2. `apps.py`application名称
3. `models.py`数据模型
4. `tests.py`测试文档
5. `views.py`用户保存响应各种请求的函数或者类
#### 应用非默认生成的文件
1. `urls.py`: 应用内路由
### 注册子应用
在全局配置文件`settings.py`中的`INSTALLED_APPS`列表添加子应用
## 2,5 使用帮助
1. `django-admin` 或 `django-admin help` 可以看到一级命令的使用帮助
2. `django-admin help options_name` 可以看到二级命令options_name的使用帮助
## 2.6 setting.py 部分参数详解
1. `DEBUG = True` 是否开启调试模式
2. `ALLOWED_HOSTS` 指定服务的host和ports,默认为 127.0.0.1:8000
3. `INSTALLED_APPS` 允许使用的application
4. `DATABASES` 配置数据库
5. `TIME_ZONE` 设置时区,东八区(`Asia/Shanghai`)
6. `MIDDLEWARE` 中间件
7. `ROOT_URLCONF` 根路由
## 2.7 进入`manage.py`交互模式
`python3 manage.py shell` 直接引入`manage.py`
## 2.8 django.auth
默认使用PBKDF2加密算法

## setting设置
```py
LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'
USE_I18N = True 
USE_L10N = True 
USE_TZ = True
```
# 3. 数据模型(ORM)
优点:
1. 可移植性强,更改数据库只需要在setting.py中更改即可,无需更改代码
2. 安全性好,框架已有诸如sql注入等攻击,无需在安全性上花太多时间
3. 查询语法简单.

## 修改默认数据库为mysql
`setting.py`文件中`DATABASES`
```py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',  # 修改引擎
        'NAME': 'my_django',
        'USER': 'root',
        'PASSWORD': 'qazwsx',
        'HOST': 'localhost',
        'PORT': 3306
    },
    'sqlite3': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
# 可以支持多个数据库，在migrate时要指定
```
## 3.1 migrate
### 3.1.1 创建模型执行文件
`python3 manage.py makemigrations` 生成模型执行的初始化文件(xxxx_initial.py)

`python3 manage.py sqlmigrate blog xxxx` 查看初始化文件转化成原生sql语句(如下)

**django中通过ORM创建数据库表通用命名格式:"小写的application名" + "_" + "小写的类名", 例如blog_blogarticles**
```sql
BEGIN;
--
-- Create model BlogArticles
--
CREATE TABLE "blog_blogarticles" (
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
    "title" varchar(30) NOT NULL, 
    "body" text NOT NULL, 
    "publish" datetime NOT NULL, 
    "author_id" integer NOT NULL REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE INDEX "blog_blogarticles_author_id_ed798e23" ON "blog_blogarticles" ("author_id");
COMMIT;
```
### 3.1.2 执行模型文件
`python3 manage.py migrate` 写入database中

## 3.2 语法
1. 每一个应用下的数据库模型类，需要在当前应用下的models.py文件中定义
2. 一个数据库模型类相当与一个数据表（Table）
3. 一个数据库模型类需更继承Model或者Model的子类
4. 定义的一个类属性，就相当于数据库表中的一个字段
5. 默认会创建一个自动递增的id主键
6. 默认创建的数据库名： 应用名小写_模型类名小写
7. max_length为字段的最大长度
8. unique参数用于设置当前字段是否唯一，默认为unique=False
9. verbose_name用于设置跟人性化的字段名
10. help_text用于api文档中的一个中文名称
### 3.2.1 外键
`models.ForeignKey(User, related_name='blog_posts', on_delete=models.CASCADE)`

参数:
    
    1.User   外键关联类 
    2.related_name  关联类反向查询的属性名
    3.on_delete:关联删除,CASCADE:级联删除

**外键(一对多):一关联多,返回 查询集; 多关联一,返回 模型对象**
### 3.2.2 字段
    CharField: 用于保存字符串,一定要声明长度
    TextField: 理论上存储不限于长度
    EmailField、URLField: 继承于CharField,但各类型包含了验证它们值是否合规的方法
    FileField: 文件字段,接收上传文件并保存到服务器
    DateField、DateTimeField: 保存时间,可用default=timezone.now.或者 auto_now_add=True(推荐)自动保存时间
### 3.2.3 ManyToManyField 多对多
`users_like = models.ManyToManyField(User, related_name="articles_like", blank=True)`

设置该字段不会在表中创建该字段,会另外创建一张表
表中三个字段:ID、外键到设置表(设置该字段的表)的字段和外键到指定表(User)的字段
## 3.3 CURD
### 3.3.1 查询
```py
res = ORM_Class.objects.get(id=1)
```
查询不到时,弹错误页
```py
from django.shortcuts import reder, get_object_or_404
res = get_object_or_404(ORM_Class, id=1)
# 上下方法效果一致,上方更加简便
try:
    res = ORM_Class.objects.get(id=1) # 如果搜索为空会抛出DoesNotExist异常
except DoesNotExist:
    raise Http404()
```
查看orm的原生sql
```py
model.objects.all().query.__str__()
```
### 示例
```py
from django.db import models


class Person(models.Model):
    first_name = CharField(max_length=300)
    last_name = CharField(max_length=300)
    full_name = CharField(max_length=300, verbose_name='name', unique=True, help_text='名称')
    # max_length：最大长度   unique：是否唯一，默认False     verbose_name：用于设置更人性化的字段名
    # help_text：用于api文档中的中文名称
    desc = mo
    class Meta:
        db_table = 'tb_projects'

    def __str__():
        return "self.full_name"
```
CRUD
```py
# 创建数据
# 方法一：
one_obj = Projects(name="", leader="")
one_obj.save()
# 方法二：
one_obj = Projects.objects.create(name="", leader="")


#1. QuerySet 查询集，存放所有项目对象的列表 
obj = Projects.objects.all()
#2. 指定查询返回模型对象
obj = Projects.objects.get(id=1)  # 如果返回的是多条记录或者查询不存在会抛出异常，查询只能使用主键或为唯一键
#3. 获取某一些记录 返回查询集
some_obj = Projects.objects.filter(id=1)
#4. 反向命中 返回查询集
exclude_obj = Projects.objects.exclude(id=1)  # 获取除命中条件外的所有模型对象
#5. 模糊查询
contains_obj = Projects.objects.filter(id__contains=1)  # (where id like "%1%")
#6. 忽略大小写
icontains_obj = Projects.objects.filter(id__icontains=1)  # 
#7. 模糊查询开头
startswith_obj = Projects.objects.filter(id__startswith=1)
#8. 模糊查询结尾
endswith_obj = Projects.objects.filter(id__endswith=1)
#9. 正则表达式regex
#10. 精确匹配exact
#11. in范围获取
in_obj = Projects.objects.filter(id__in=['1', '2'])
#12. 关联查询(内连接) 通过子表查父表
foreign_obj = Projects.objects.filter(foreign__从表字段名__contains='')
#13. 关联查询 通过父表查子表
#14. 多字段查询(逻辑关系)
multi = Projects.objects.filter(leader='icon', name="")  # ＆的关系

#14.2 Q/F
from django.db import Q, F

# Q 对象可以使用 & | ~ （与 或 非）操作符进行组合,Q 对象要在所有关键字的前面
# 查询((结尾为"菜") 或 非(2010年10月))的查询集
models.Book.objects.filter(Q(title__endswith="菜") | ~Q(Q(pub_date__year=2010) & Q(pub_date__month=10)))


# F 动态获取对象字段的值，可以进行运算。对象和常数之间的加减乘除和取余的操作，修改操作（update）也可以使用
Project.objects.filter(F(salary__gt="age")).values()

Project.objects.update(price=F(age)*300)

#15. 比较查询
gt_obj = Projects.objects.filter(id__gt=2)  # id大于2

    __gt >
    __gte >=
    __lt <
    __lte <=

# 查询集相当于一个列表，支持列表中的大多数操作(下标索引，正向切片，for循环)
# 是对数据库操作的优化
# 会缓存结果（第一去查询，第二次不会再去查询，惰性查询）
# 支持链式操作
Project.object.filter(leader="").filter(name="")  # 基于前面的结果再次查询
```
U
```py
# 先获取 得到对象后直接赋值
res = Projects.objects.get(id=1)
res.name = "hahahxixi"
res.save()
```
D
```py
# 先获取 得到对象后直接赋值
res = Projects.objects.filter(name__contains="521")
one_project = res.first()
one_project.delete()  # 会自动保存，无需save
```
排序，分组
```py
order_obj = Projects.objects.filter(id__gte=3).order_by('-interfaces__name')  # 默认升序，如果要倒序则再前面加"-"
multi_order_obj = Projects.objects.filter(id__gte=3).order_by('-interfaces__name', "publish_app")  # 多重排序

```
高级查询

1. 聚合查询函数:aggregate

2. 额外查询:annotate
- values 或者 values_list 放在 annotate 前面：values 或者 values_list 是声明以什么字段分组，annotate 执行分组。
- values 或者 values_list 放在annotate后面： annotate 表示直接以当前表的pk执行分组，values 或者 values_list 表示查询哪些字段， 并且要将 annotate 里的聚合函数起别名，在 values 或者 values_list 里写其别名。
```py
# aggregate
Projects.objects.aggregate(Avg("id")).values()
# Out[24]: dict_values([1.0])


# annotate
Projects.objects.values('id', 'name').annotate(haha=Avg("id"))  # 声明分组字段
# <QuerySet [{'id': 1, 'name': 'name1', 'haha': 1.0}]>
Projects.objects.annotate(xixi=Avg("id")).values('name')  # 声明显示字段
# <QuerySet [{'id': 1}]>
Projects.objects.values('id', 'name').annotate(haha=Avg("id")).values("id")  # 可嵌套使用
```
## 3.4 一对一
```py
from django.db import models
from django.contrib.auth.models import User


class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, unique=True)
    # on_delete删除模式,CASCADE联级删除,unique字段是否唯一
    birth = models.DateField(blank=True, null=True)  # blank前端是否必填 null字段是否为空
    phone = models.CharField(max_length=20, null=True)

    def __str__(self):
        return 'user {}'.format(self.user.username)
```
## 3.5 继承
###  抽象模型继承
当实施数据迁移时,数据库不会创建抽象类
```py
from django.db import models 


class BaseModel(models.Model):
    name = model.ForeignKey(User, on_delete=models.CASCADE, related_name='%(app_label)s_%(class)s_related')  # 动态设置相关名字,避免子类冲突
    age = model.IntegerField()

    class Meta:
        abstract = True
        ordering = ['age']


class Programmer(BaseModel):
    lang = model.CharField(max_length=200)
```
### 多表继承
两个类都会创建数据库表
```py
from django.db import models


class Place(models.Model):
    name = models.CharField(max_length=300)

class address(models.Model):
    address = models.CharField(max_length=200)
```
### 代理模式
在内部类Meta中声明proxy=True,子类通过自定义的方法或者重写内部类Meta的方式,改变模型行为
```py
from django.db import models


class Student(models.Model):
    name = CharField(max_length=300)
    age = IntegerField()

class Teacher(Student):
    class Meta:
        proxy = True
        ordering = ['age']

    def teacher_age(self):
        return self.age + 17


```
## 3.6 存储文件
```py
def user_directory_path(instance, filename):  # ①接收模型实例 ②接收文件名
    return f"courses/user_{instance.user.id}/{filename}"

class Lesson(models.Model):
    video = models.FileField(upload_to=user_directory_path)
    attch = models.FIleField(upload_to=user_directory_path)


```
# 4. 创建用户
## 4.1 创建管理员
`python3 manage.py createsuperuser` 创建管理员

http://127.0.0.1:8000/admin/ 访问管理页面


# 6. 路由
## 路由匹配规则
1. urlpatterns为固定名称的列表
2. 列表中的元素就代表一个路由
3. 从上到下进行匹配，如果能匹配上，就调用和导入path函数的第二个参数（或去子路由文件中继续匹配）
4. 如果匹配不上，会自动抛出一个404异常

## 路由寻址顺序
1. 从根路由从上到下查找
2. 找到子应用/视图函数
3. 从子路由从上到下查找
4. 如果找不到返回404
## 6.1 工程路由
在项目同名目录下的`urls.py`文件中定义, 是Django解析路由的入口
```py
# 在工程目录下的urls.py中
from django.contrib import admin
from django.urls import path, include


urlpatterns = [
    path('admin/', admin.site.urls),  # 第一个参数是path, 第二参数是视图函数
    path('blog/', include('blog.urls')),  #　include 将指定path的路由都转到指定应用的路由管理
]
```
## 6.2 子应用路由
```py
# 在各application目录下创建urls.py文件
from django.urls import path
from django.contrib.auth import views as auth_views
from . import views


urlpatterns = [
    path('', view.blog_title),  # 第一个参数是path(空则为根), 第二参数是视图函数
    path('<int:article_id>', view.blog_article),  # 应用根后面的数字会当成参数传入
    path('login', auth.views.LoginView.as_view(template_name='account/login.html'), name='user_login')  # 使用内置的登录视图,登录后redirect默认为profile.此处需要在setting.py中修改
    path('logout/', auth_views.LogoutView.as_view(template_name='account/logout.html'), name='user_logout'),  # 内置的退出视图
]
```
### 6.2.2 命名路由
1. 方法一(推荐):直接在项目urls上传参app_name,在多应用下更方便管理
2. 方法二:在子应用中设置app_name变量

`project的urls.py`
```py
from django.urls import path, include


urlpatterns = [
    path("blog", include(('blog.urls', 'blog'), namespace='blog')),  # 方法一
    path("admin", include('admin.urls', namespace='admin'))  # 方法二
]
```
`app的urls.py`
```py
from django.urls import path
from . import views


app_name = 'admin'  # 方法二
urlpatterns = [
    path('', views.blog_article, name='blog_article')
]
```
### 6.2.3 路由重定向redirect
```py
LOGIN_REDIRECT_URL = '/blog/'  # 指定内置登录模块登录成功后redirect到正页
```
### 6.2.4 内置修改密码模块
```py
path('password_reset', auth_views.PasswordResetView.as_view(
    template_name='account/password_reset_form.html',
    email_template_name='account/password_reset_email.html',  # email_template_name发送的邮件模板
    success_url='/account/password_reset_done/')  # success_url如果成功跳转的地址
```
`setting.py`
```py
# email配置
EMAIL_HOST = 'smtp.163.com'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 25
EMAIL_USE_TLS = True
DEFAULT_FROM_EMAIL = ''
```
# 7. 表单
## 表单类
```py
from django import form


class LoginForm(form.Form):
    username = form.CharField()
    password = form.CharField(widget=forms.PasswordInput)


login_1 = LoginForm()  # 未向类传参,称为:未绑定实例
print(login_1.is_bound)  # False 未绑定实例则返回False
print(login_1)  # 生成如下HTML代码
"""
<tr><th><label for="id_username">Username:</label></th><td><input type="text" name="username" required id="id_username"></td></tr>
<tr><th><label for="id_password">Password:</label></th><td><input type="password" name="password" required id="id_password"></td></tr>
"""

account = {"username": "admin", "password": "qazwsxedc"}
login_2 = LoginForm(account)
print(login_2.is_bound)  # 已绑定实例则返回 True
print(login_2.is_valid())  # True ; 判断入参数据是否合法

# 只有实例使用过is_valid()这个方法才可以使用下面的方法
print(login_2.cleaned_data)  # {"username": "admin", "password": "qazwsxedc"}
# 以字典形式返回合法入参,若某项入参不合法则不显示
```
## 表单模板
```django
<form class="form-horizontal" action="." method="post">
    {% csrf_token %}
    <!-- post请求需要携带csrf,否则报错 -->
    {{ form.as_p }}
    <!-- 每个表单项都用<p>标签包围(会换行) -->
    {{ form.as_table }}
    <!-- 不做任何包围(不会换行) -->
    {{ form.as_ul }}
    <!-- 每个表单项都被用<li>标签包围(会换行,带·) -->

    <label for="{{ form.username.id_for_label }}"></label>
    <!-- 关联label和input -->
    <div>{{ form.username }}</div>
    <!-- form.表单项 可以提出单项表单 -->

    <input type="submit" value="Login" class="btn btn-primary btn-lg">
</form>
```
## 表单模型类
```py
from django import form
from django.contrib.auth.models import User
from .models import UserProfile


class RegistrationForm(form.ModelForm):
    password = forms.CharField(label="Password", widget=forms.PasswordInput)
    password2 = forms.CharField(label="Confirm Password", widget=forms.PasswordInput)

    class Meta:
        model = User  # 指定数据模型
        fields = ("username", "email")  # 指定需要显示为表单的字段
        # exclude = ('',)  # 排除元组中的字段外都需要显示为表单

    def clean_password(self):  # 以'clean_ + 名称'的方法都会在调用表单实例对象的is_valid()函数时被执行
        cd = self.cleaned_data
        if cd['password'] != cd['password2']:
            raise forms.ValidationError("password do not match")
        return cd['password']


class UserProfileForm(form.ModelForm):
    class Meta:
        model = UserProfile
        fields = ("phone", "birth")
```

# 视图
## 函数视图
1. 函数视图不方便在针对不同请求模式的时候做处理，会显的代码很臃肿
2. 使用函数视图时，任意请求方法都可以访问
## HttpResponse
```py
from django.http import HttpResponse

def login(request):
    dic = {
            "username": "admin",
            "password": "qazwsx"
        }
        res = json.dumps(dic)
    HttpResponse(content=res, content_type="application/json", status=200)  # 使用该函数，需要将返回文本处理成byte类型
    # ------------------------------
    h = HttpResponse
    h.write("")  # 支持如写文件一样写入
    return h
```
## 关联数据模型
```py
from .forms import RegistrationForm, UserProfileForm

def register(request):
    if request.method == "POST":
        register_form = RegistrationForm(request.POST)
        profile_form = UserProfileForm(request.POST)
        if register_form.is_vaild() * profile_form.vaild():  # 相当于and True*False → 0
            new_form = register_form.save(commit=False)  # 将表单数据存到数据库,并生成该数据对象.如果commit=False的话,仅生成数据对象
            new_form.set_password(register_form.cleaned_data['password'])  # User的内置函数,加盐加密后保存
            new_form.save()  # 默认为True
            new_profile = profile_form.save(commit=False)
            new_profile.user = new_form  # 关联两个数据模型
            new_profile.save()
            return HttpResponse("successfully")
        else:
            return HttpResponse("Sorry Invaild")
    elif request.method == "GET":
        register_form = RegistrationForm()
        profile_form = UserProfileForm()
        return render(request, "account/register.html", {"form":register_form, "profile": profile_form})
```
# 类视图
```py
from django.views.generic import ListView
from .models import Course


class CourseListView(ListView):
    model = Course  # 相当于Course.object.all()
    context_object_name = "courses"  # 结果集在模板中的变量名
    template_name = 'course/course_list.html"

```
类视图直接以不同的请求模式作为方法名，用作区分

在路由中映射类视图时，需要调用 `.as_view()`
```py
from django.views import View


class IndexView(View):

    def get(self, request):
        return ""
    
    def post(self, request):
        return ""

# ---------以下是路由------------------------
from django.urls import path
from . import views


urlpatterns = [
    path("", views.IndexView.as_view())
]

```
获取请求
```py
from django.views import View
from django.http import HttpResponse, JsonResponse


class IndexView(View):

    def get(self, request):
        value = request.GET["KEY"]  # 可以以字典的形式查询查询字符串
        lis = request.GET.getlist('name')  # 查询字符串中若有相同key，则该key的value以列表形式存储
        value2 = request.GET('name')  # 若直接查询，则得到列表中最后一个value
        return ""
    
    def post(self, request):
        form = request.POST["KEY"]  # 以字典的形式查询form表单

        import json 
        # 将request的json字节转化成字典
        body_byte = request.body  # 获取json字节
        body_str = body_byte.encode("UTF-8")  # 将字节转化成字符串
        body_dict = json.loads(body_str)  # 将字符串转化成字典
        
        # 将字典转化成json字节，返回给前端
        dic = {
            "username": "admin",
            "password": "qazwsx"
        }
        res = json.dumps(dic)
        return HttpResponse(content=res, content_type="application/json", status=200)  # 使用该函数，需要将返回文本处理成byte类型

    def put(self, request):
        dic = {
            "username": "admin",
            "password": "qazwsx"
        }
        return JsonResponse(data=dic)  # 该方法无需自行转换成json，如果data为json则需要将safe=False

```
