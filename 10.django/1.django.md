# 1. 简介
Django 本身基于 MVC 模型，即 Model（模型）+ View（视图）+ Controller（控制器）设计模式

MVC优势:
- 低耦合
- 开发快捷
- 部署方便
- 可重用性高
- 维护成本低

框架特点:
- 强大的数据库功能
- 自带强大的后台功能
- 优雅的路由

## django3 新特性
1. 支持ASGI（异步服务器网关接口）
- 支持WebSocket, 性能提升了3~5倍

## MVC与MTV模型
在django中因为Controller绝大部分情况下由框架自动处理,不需要使用者做什么东西.所以又为MTV模式.

MVC模型
- 模型（M）- 编写程序应有的功能，负责业务对象与数据库的映射(ORM)。
- 视图（V）- 图形界面，负责与用户的交互(页面)。
- 控制器（C）- 负责转发请求，对请求进行处理。

MTV模型
- M 表示模型（Model）：编写程序应有的功能，负责业务对象与数据库的映射(ORM)。
- T 表示模板 (Template)：负责如何把页面(html)展示给用户。
- V 表示视图（View）：负责业务逻辑，并在适当时候调用 Model和 Template。

除了以上三层之外，还需要一个URL分发器，它的作用是将一个个URL的页面请求分发给不同的View处理，View再调用相应的Model和Template

响应顺序:
1. Web服务器（中间件）收到一个http请求 
2. Django在URLconf里查找对应的视图(View)函数来处理http请求 
3. 视图函数调用相应的数据模型来存取数据、调用相应的模板向用户展示页面 
4. 视图函数处理结束后返回一个http的响应给Web服务器 
5. Web服务器将响应发送给客户端 

# 2. 基本使用
## 2.1 安装方法
1. 使用pip工具即可安装django: `pip install django`
2. 从github中下载
## 2.2 创建工程(project)
1. `django-admin startproject project_name`会在命令行所在目录生成project_name子目录
2. `django-admin startproject project_name .`(第四个参数指定目录)会在命令行所在目录生成相关文件
### 2.2.2 默认生成工程目录
- `manage.py`: 与Django项目交互的命令行工具
- 工程目录(与脚手架创建project同名)
    1. `setting.py`项目全局配置文件
    2. `urls.py`声明的全局ur1路由表,可添加子路由信息
    3. `wsgi.py`兼容WSGI协议的web服务器入口文件
    4. `asgi.py`异步网关(支持websocket, 3.X+新增特性)
- `db.sqlite3`默认数据库

## 2.3 启动工程
1. `python manage.py runserver` 会启动web服务器,具有django欢迎页面
2. `python manage.py runserver ip：端口` 指定运行ip和端口
## 2.4 生成应用(application)
1. `python manage.py startapp application_name` 生成文件应用
2. `django-admin startapp application_name` 与上个命令效果一样

|文件|描述|
|-|-|
|admin.py|跟网站的后台管理站点配置相关的文件|
|apps.py|用于配置当前子应用相关信息的文件|
|models.py|保存数据库模型类|
|tests.py|用于编写单元测试|
|views.py|用于编写Web应用视图|
### 1. 注册子应用
在全局配置文件`settings.py`中的`INSTALLED_APPS`列表添加子应用
## 2,5 使用帮助
1. `django-admin` 或 `django-admin help` 可以看到一级命令的使用帮助
2. `django-admin help options_name` 可以看到二级命令options_name的使用帮助
## 2.6 setting.py 部分参数详解
1. `DEBUG = True` 是否开启调试模式
2. `ALLOWED_HOSTS` 指定服务的host和ports,默认为 127.0.0.1:8000
3. `INSTALLED_APPS` 允许使用的application
4. `DATABASES` 配置数据库
5. `TIME_ZONE` 设置时区,东八区(`Asia/Shanghai`)
6. `MIDDLEWARE` 中间件
7. `ROOT_URLCONF` 根路由
8. `DATABASE_ROUTERS`: 数据库路由

```py
LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'
USE_I18N = True 
USE_L10N = True 
USE_TZ = True

# 项目.文件.变量  找到定义路由的变量字典
DATABASE_ROUTERS = ['Project.database_router.DatabaseAppsRouter']
```
## 2.7 进入`manage.py`交互模式
`python3 manage.py shell` 直接引入`manage.py`
## 2.8 django.auth
默认使用PBKDF2加密算法

# 3. 数据模型(ORM)
优点:
1. 可移植性强,更改数据库只需要在setting.py中更改即可,无需更改代码
2. 安全性好,框架已有诸如sql注入等攻击,无需在安全性上花太多时间
3. 查询语法简单.

- 模型类如果未指明表名，Django默认以 小写app应用名_小写模型类名 为数据库表名
- django会为表创建自动增长的主键列，每个模型只能有一个主键列，如果使用选项设置某属性为主键列后django不会再创建自动增长的主键列。默认创建的主键列属性为id，可以使用pk(primary key)代替
## ORM 对象关系映射&解析
使用 ORM 的好处：
- 提高开发效率。
- 不同数据库可以平滑切换。

使用 ORM 的缺点：
- ORM 代码转换为 SQL 语句时，需要花费一定的时间，执行效率会有所降低。
- 长期写 ORM 代码，会降低编写 SQL 语句的能力。

ORM 解析过程:
- ORM 会将 Python 代码转成为 SQL 语句。
- SQL 语句通过 pymysql 传送到数据库服务端。
- 在数据库中执行 SQL 语句并将结果返回。

![对应关系表](./image/ORM映射.png)

## mysql数据库配置
以下 3.4.5点是用于 migrate

1. 安装`pip install pymysql`
2. 在项目目录的`__init__.py`文件中
```py
from pymysql import install_as_MySQLdb

install_as_MySQLdb()
```
3. 升级pip`pip install --upgrade pip`
4. 安装`pip install setuptools_rust`
5. 安装`pip install cryptography`
6. 在`setting.py`的`DATABASES`中配置数据库配置
```py
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',  # 修改引擎
        'NAME': 'my_django',  # 数据库名
        'USER': 'root',  # 账号
        'PASSWORD': 'qazwsx',  # 密码
        'HOST': 'localhost', # 地址
        'PORT': 3306 # 端口
    },
    'sqlite3': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
# 可以支持多个数据库，在migrate时要指定  python manage.py migrate --database=sqlite3
```
## 3.1 migrate迁移
### 3.1.1 创建模型执行文件
- `python3 manage.py makemigrations` 生成模型执行的初始化文件(xxxx_initial.py)
- `python3 manage.py sqlmigrate 应用名 应用内migrations文件` 查看初始化文件转化成原生sql语句(如下)

django中通过ORM创建数据库表通用命名格式:
- `"小写的application名" + "_" + "小写的类名"`, 例如blog_blogarticles
```sql
BEGIN;
--
-- Create model BlogArticles
--
CREATE TABLE "blog_blogarticles" (
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
    "title" varchar(30) NOT NULL, 
    "body" text NOT NULL, 
    "publish" datetime NOT NULL, 
    "author_id" integer NOT NULL REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE INDEX "blog_blogarticles_author_id_ed798e23" ON "blog_blogarticles" ("author_id");
COMMIT;
```
### 3.1.2 执行模型文件
`python3 manage.py migrate --database=指定数据库` 写入database中

### 导出
`python manage.py dumpdata 应用名 --database=指定数据库 > text.json`

### 导入
`python manage.py loaddata text.json --database=指定数据库`

### 其他
如果migrations目录被删除,需要重新进行初始化

- `python manage.py makemigrations --empty app_name`: 生成空记录
- `python manage.py makemigrations `: 生成新记录(从头开始全部)
- `python manage.py migrate`: 执行记录

## 数据库路由(读写分离,多数据库)
当有多个数据库,或者需要进行读写分离时.需要设置数据库路由
### 数据库路由表
在`setting.py`中
- 设置`DATABASE_APPS_MAPPING`用于路由表映射
- 设置`DATABASE_ROUTERS`用于声明路由规则
```py
DATABASE_APPS_MAPPING = {  # 路由表映射 左侧是模型中app_label 右侧是数据库表中的key
    # example:
    # 'key':'database_name',
    'app02': 'db02',
    'app01': 'db01',
    'admin': 'db01',
    'auth':  'db01',
    'contenttypes': 'db01',
    'sessions': 'db01',
}

DATABASE_ROUTERS = ['Prject.database_router.DatabaseAppsRouter']  # 声明路由规则
```
### 数据库路由规则
在工程目录新建路由规则表`database_router.py`(命名随意), 创建路由规则类.

以下几个方法名不允许改变:
- db_for_read: 应用于读取类型对象的数据库模型，如果数据库提供附加信息会在hints字典中提供，最后如果没有则返回None
- db_for_write: 应用于写入类型对象的数据库模型，hints字典提供附加信息，如果没有则返回None
- allow_relation: 外键操作，判断两个对象之间是否是应该允许关系，是返回True,否则返回False，如果路由允许返回None
- allow_syncdb：　是否允许同步
- allow_migrate:是否允许对db这个数据库进行migrate
```py
from django.conf import settings

DATABASE_MAPPING = settings.DATABASE_APPS_MAPPING


class DatabaseAppsRouter(object):
    """
    A router to control all database operations on models for different
    databases.

    In case an app is not set in settings.DATABASE_APPS_MAPPING, the router
    will fallback to the `default` database.

    Settings example:

    DATABASE_APPS_MAPPING = {'app1': 'db1', 'app2': 'db2'}
    """

    def db_for_read(self, model, **hints):
        """"Point all read operations to the specific database."""
        if model._meta.app_label in DATABASE_MAPPING:
            return DATABASE_MAPPING[model._meta.app_label]  # 返回什么就指定什么数据库
        return None  # 返回为空就用DEFAULT

    def db_for_write(self, model, **hints):
        """Point all write operations to the specific database."""
        if model._meta.app_label in DATABASE_MAPPING:
            return DATABASE_MAPPING[model._meta.app_label]
        return None

    def allow_relation(self, obj1, obj2, **hints):
        """Allow any relation between apps that use the same database."""
        db_obj1 = DATABASE_MAPPING.get(obj1._meta.app_label)
        db_obj2 = DATABASE_MAPPING.get(obj2._meta.app_label)
        if db_obj1 and db_obj2:
            if db_obj1 == db_obj2:
                return True
            else:
                return False
        return None

    def allow_syncdb(self, db, model):
        """Make sure that apps only appear in the related database."""

        if db in DATABASE_MAPPING.values():
            return DATABASE_MAPPING.get(model._meta.app_label) == db
        elif model._meta.app_label in DATABASE_MAPPING:
            return False
        return None

    def allow_migrate(self, db, app_label, model=None, **hints):
        """
        Make sure the auth app only appears in the 'auth_db'
        database.
        """
        if db in DATABASE_MAPPING.values():
            return DATABASE_MAPPING.get(app_label) == db
        elif app_label in DATABASE_MAPPING:
            return False
        return None
```
### 设置模型指向
需要通过在模型的  `Meta`类中设置`app_label`声明(路由映射表左侧key).

如果不指定将指向为 default
```py
class Users(models.Model):
    name = models.CharField(max_length=50)
    passwd = models.CharField(max_length=100)
 
    def __str__(self):
        return "app01 %s " % self.name
 
    class Meta:
        app_label = "app01"  # 声明在路由映射表中key
        db_table = "myUsers"
```

### 手动选择数据库
```py
Users.objects.using("admin").all()

user = Users(name="xiaoming", passwd="123456")
user.save(using="admin")

user2 = Users(name="xiaohong", passwd="123")
user2.save(using="admin")
user2.pk = None  # 清除主键后再保存到其他,避免主键冲突
user2.save(using="app02")
```

## 3.2 基础语法
1. 每一个应用下的数据库模型类，需要在当前应用下的models.py文件中定义
2. 一个数据库模型类相当与一个数据表（Table）
3. 一个数据库模型类需更继承Model或者Model的子类
4. 定义的一个类属性，就相当于数据库表中的一个字段
5. 默认会创建一个自动递增的id主键
6. 默认创建的数据库名： 应用名小写_模型类名小写

### 字段类型
|类型|说明|参数|示例
|-|-|-|-|
AutoField|自动增长的IntegerField，通常不用指定，不指定时Django会自动创建属性名为id的自动增长属性。||id = models.AutoField()
BooleanField|布尔字段，值为True或False
NullBooleanField(已弃用)|支持Null、True、False三种值
CharField|字符串|max_length:表示最大字符个数|CharField(max_length=30)
EmailField|邮件|继承于CharField,包含校验规则
URLField|链接|继承于CharField,包含校验规则
TextField|大文本字段，一般超过4000个字符时使用
IntegerField|整数
DecimalField|十进制浮点数|max_digits:总位数;decimal_places:小数位数|DecimalField(max_digits=None, decimal_places=None)
FloatField|浮点数
DateField|日期|auto_now:每次保存对象时，自动设置该字段为当前时间，多用于"最后一次修改"的时间戳，使用当前日期;auto_now_add表示当对象第一次被创建时自动设置当前时间，用于创建的时间戳，使用当前日期;auto_now_add和auto_now相互排斥|DateField[auto_now=False, auto_now_add=False])
TimeField|时间|同上|TimeField[auto_now=False, auto_now_add=False]
DateTimeField|日期时间|同上|DateTimeField[auto_now=False, auto_now_add=False]
FileField|文件
ImageField|图像

### 选项
选项|说明
-|-
null|如果为True，表示允许为空，默认值是False。
blank|如果为True，则该字段允许为空白，默认值是False。
db_column|字段的名称，如果未指定，则使用属性的名称。
db_index|若值为True, 则在表中会为此字段创建索引，默认值是False。
default|默认值。
primary_key|若为True，则该字段会成为模型的主键字段，默认值是False，一般作为AutoField的选项使用。
unique|如果为True, 这个字段在表中必须有唯一值，默认值是False。
max_length|为字段的最大长度
verbose_name|详细字段名
help_text|用于api文档中帮助信息

- null是数据库范畴的概念，blank是表单验证范畴的。
### 外键
`models.ForeignKey(User, related_name='blog_posts', on_delete=models.CASCADE)`
1. User: 外键被关联的类 
2. related_name: 被关联的类反向查询的属性名(User.blog_posts可以查到当前关联类)
3. on_delete: 关联删除

on_delete选项:从`models的全局属性`
- CASCADE 级联: 删除主表数据时连通一起删除外键表中数据
- PROTECT 保护: 通过抛出ProtectedError异常，来阻止删除主表中被外键应用的数据
- SET_NULL 设置为NULL: 仅在该字段null=True允许为null时可用
- SET_DEFAULT 设置为默认值: 仅在该字段设置了默认值时可用
- SET() 设置为特定值或者调用特定方法
- DO_NOTHING 不做任何操作: 如果数据库前置指明级联性，此选项会抛出IntegrityError异常


```py
from django.db import models


class Account(models.Model):
    account = models.CharField(max_length=20)
    pwd = models.CharField(max_length=20)

    class Meta:
        app_label = "app"


class Users(models.Model):
    name = models.CharField(max_length=50)
    age = models.IntegerField()
    switch = models.BooleanField()
    account = models.ForeignKey(to=Account, related_name="user", on_delete=models.CASCADE)

    class Meta:
        app_label = "app"


account = Account(account="zhanghao", pwd="123456")
Users.objects.create(name="xiaoming", age=30, switch=True, account=account)
Account.objects.get(user=1)  # 获取外键=1的查询集
account.user  # 获取account实例的关联数据
```
### 查看原生sql
```py
model.objects.all().query.__str__()
```
## 数据库关系
- 一对多: 一找多,返回 查询集; 
- 多对一: 多找一,返回 模型对象
- 一对一: 
- 多对多: 
### 一对一
```py
from django.db import models
from django.contrib.auth.models import User


class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, unique=True)
    # on_delete删除模式,CASCADE联级删除,unique字段是否唯一
    birth = models.DateField(blank=True, null=True)  # blank前端是否必填 null字段是否为空
    phone = models.CharField(max_length=20, null=True)

    def __str__(self):
        return 'user {}'.format(self.user.username)
```

### ManyToManyField 多对多
`users_like = models.ManyToManyField(User, related_name="articles_like", blank=True)`

设置该字段不会在表中创建该字段,会另外创建一张表
表中三个字段:ID、外键到设置表(设置该字段的表)的字段和外键到指定表(User)的字段

## 3.3 CURD
本章节以下方两模型为原型举例
```py
from django.db import models


class BaseModel(models.Model):
    create_date = models.DateTimeField(auto_now_add=True)
    update_date = models.DateTimeField(auto_now=True)
    delete_date = models.DateTimeField(null=True)

    class Meta:
        abstract = True


class Account(BaseModel):
    account = models.CharField(max_length=20)
    pwd = models.CharField(max_length=20)

    class Meta:
        app_label = "app"


class Users(BaseModel):
    name = models.CharField(max_length=50)
    age = models.IntegerField()
    switch = models.BooleanField()
    account = models.ForeignKey(to=Account, related_name="user", on_delete=models.CASCADE)

    class Meta:
        app_label = "app"
```


### 增加
```py
# 通过实例化模型类进行创建
account = Account(account="zhanghao", pwd="mima")
account.save()


# 使用模型类创建
Users.objects.create(name="xiaohong", age=3, switch=True, account=account)  # <Users: Users object (4)>
```

### 查询
数据表
|id|name|age|switch|account_id|create_date|update_date|delete_date
-|-|-|-|-|-|-|-
|3|xiaoming|50|0|2|2021-04-25 12:17:52.777114|2021-04-25 12:17:52.777114
|4|xiaohong|3|1|3|2021-04-25 12:17:52.777114|2021-04-25 12:17:52.777114
```py
# 查询行数(只有查询集对象才可以使用)
Users.objects.count()  # 2  查询Users模型的全部行数
# 查询过滤后的行数
Users.objects.filter(name="xiaohong").count()  # 1 

# 查看全部对象
Users.objects.all()  # <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>
# 查看指定对象
Users.objects.get(id=3)  # <Users: Users object (3)>
# 查询不存在对象
Users.objects.get(id=-1)  # 抛出错误 app.models.Users.DoesNotExist: Users matching query does not exist.
# 查询存在多条记录
Users.objects.get(account_id__gt=2)  # 抛出错误app.models.Users.MultipleObjectsReturned: get() returned more than one Users -- it returned 2!


# 反向查询
Users.objects.exclude(id=3)  # 查询除id=3外的查询集 <QuerySet [<Users: Users object (4)>]>

# 过滤查询,返回查询集
Users.objects.filter(id=3) #  <QuerySet [<Users: Users object (3)>]>

# 聚合查询 Avg平均 Count数量 Max最大  Min最小 Sum求和

# 排序

# 关联

# 关联过滤
```
#### 过滤表达式
语法: `属性名称__比较运算符=值`

tip: 以下表达式并不是只有在过滤时才可以使用.但是只推荐在过滤时使用
```py
# 相等 exact
Users.objects.filter(id__exact=3)  
# <QuerySet [<Users: Users object (3)>]>

# 空 isnull
Users.objects.filter(name__isnull=False)  
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>


# 范围 in
Users.objects.filter(id__in=[1, 2, 3, 4, 5])  
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>
```
##### 模糊匹配
包含contains 开头startswith 结尾endswith

模糊匹配中: 最前面加`i`可忽略大小写
```py
Users.objects.filter(name__contains="xiao")  
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>
Users.objects.filter(name__icontains="xiao")  
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>

Users.objects.filter(name__startswith="xiao")  
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>
Users.objects.filter(name__istartswith="XIAO")  
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>

Users.objects.filter(name__endswith="xiao")  
# <QuerySet []>
```
##### 比较表达式
gt大于 gte大于等于 lt小于 lte小于等于
```py
Users.objects.filter(id__gt=3)
# <QuerySet [<Users: Users object (4)>]>
Users.objects.filter(id__gte=3)
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>
Users.objects.filter(id__lt=4)
# <QuerySet [<Users: Users object (3)>]>
Users.objects.filter(id__lte=4)
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>
```
##### 日期表达式
year month day week_day hour minute second 可以与比较表达式组合使用
```py
Users.objects.filter(create_date__year=2021)  
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>
Users.objects.filter(create_date__year__gte=2021)  
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>
Users.objects.filter(update_date__month__lt=12)  
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>
```
##### F对象
在F对象内进行简单的计算的操作
```py
from django.db.models import F

Users.objects.filter(create_date__year=F("update_date__year")) # 相同年份
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>
Users.objects.filter(age=F("account_id")+48)  # age=50 account_id=2
# <QuerySet [<Users: Users object (3)>]>
```
##### Q对象
逻辑处理 &与 |或 ~非
```py
from django.db.models import Q

# 如果只要and可以不使用Q对象, 链式查询是惰性查询,只会发起一次请求
Users.objects.filter(id__gt=2, age__gt=3)  # 可以多个表达式
# <QuerySet [<Users: Users object (3)>]>
Users.objects.filter(id__gt=2).filter(age__gt=3)  # 可以使用链式
# <QuerySet [<Users: Users object (3)>]>

# 如果需要涉及其他逻辑处理,就需要使用Q对象了
Users.objects.filter(Q(id__gt=2)&Q(age__gt=3))
# <QuerySet [<Users: Users object (3)>]>
Users.objects.filter(Q(id__gt=2)&Q(age__exact=3)|Q(age__exact=50))
# <QuerySet [<Users: Users object (3)>, <Users: Users object (4)>]>
```

#### 错误处理
```py
res = Users.objects.get(id=1)
```
查询不到时,弹错误页
```py
from django.shortcuts import reder, get_object_or_404
res = get_object_or_404(ORM_Class, id=1)
# 上下方法效果一致,上方更加简便
try:
    res = ORM_Class.objects.get(id=1) # 如果搜索为空会抛出DoesNotExist异常
except DoesNotExist:
    raise Http404()
```



### 修改
支持 单个修改, 也支持批量修改
```py
# 单个修改
single = Users.objects.get(id=3)
single.age = 50
single.save()


# 批量修改
multiple = Users.objects.all()  # <QuerySet [<Users: Users object (3)>]>
multiple.update(name="xiaoming")  # 1 返回修改的行(row)数
```

### 删除
支持 单个删除,也支持批量删除
```py
# 单个删除
account = Account.objects.get(id=1)  # 返回实例 <Account: Account object (1)>
account.delete()  # 删除,返回外键关联删除数 (2, {'app.Users': 1, 'app.Account': 1})

# 批量删除
user = Users.objects.filter(id=2)  # 返回查询集 <QuerySet [<Users: Users object (2)>]>
user.delete()  # 批量删除 (1, {'app.Users': 1})
```
### 示例
```py
from django.db import models


class Person(models.Model):
    first_name = CharField(max_length=300)
    last_name = CharField(max_length=300)
    full_name = CharField(max_length=300, verbose_name='name', unique=True, help_text='名称')
    # max_length：最大长度   unique：是否唯一，默认False     verbose_name：用于设置更人性化的字段名
    # help_text：用于api文档中的中文名称
    desc = mo
    class Meta:
        db_table = 'tb_projects'

    def __str__():
        return "self.full_name"
```
CRUD
```py
# 创建数据
# 方法一：
one_obj = Projects(name="", leader="")
one_obj.save()
# 方法二：
one_obj = Projects.objects.create(name="", leader="")


#12. 关联查询(内连接) 通过子表查父表
foreign_obj = Projects.objects.filter(foreign__从表字段名__contains='')
#13. 关联查询 通过父表查子表
```
U
```py
# 先获取 得到对象后直接赋值
res = Projects.objects.get(id=1)
res.name = "hahahxixi"
res.save()
```
D
```py
# 先获取 得到对象后直接赋值
res = Projects.objects.filter(name__contains="521")
one_project = res.first()
one_project.delete()  # 会自动保存，无需save
```
排序，分组
```py
order_obj = Projects.objects.filter(id__gte=3).order_by('-interfaces__name')  # 默认升序，如果要倒序则再前面加"-"
multi_order_obj = Projects.objects.filter(id__gte=3).order_by('-interfaces__name', "publish_app")  # 多重排序

```
高级查询

1. 聚合查询函数:aggregate

2. 额外查询:annotate
- values 或者 values_list 放在 annotate 前面：values 或者 values_list 是声明以什么字段分组，annotate 执行分组。
- values 或者 values_list 放在annotate后面： annotate 表示直接以当前表的pk执行分组，values 或者 values_list 表示查询哪些字段， 并且要将 annotate 里的聚合函数起别名，在 values 或者 values_list 里写其别名。
```py
# aggregate
Projects.objects.aggregate(Avg("id")).values()
# Out[24]: dict_values([1.0])


# annotate
Projects.objects.values('id', 'name').annotate(haha=Avg("id"))  # 声明分组字段
# <QuerySet [{'id': 1, 'name': 'name1', 'haha': 1.0}]>
Projects.objects.annotate(xixi=Avg("id")).values('name')  # 声明显示字段
# <QuerySet [{'id': 1}]>
Projects.objects.values('id', 'name').annotate(haha=Avg("id")).values("id")  # 可嵌套使用
```
## 3.5 继承
###  抽象模型继承
当实施数据迁移时,数据库不会创建抽象类
```py
from django.db import models 


class BaseModel(models.Model):
    name = model.ForeignKey(User, on_delete=models.CASCADE, related_name='%(app_label)s_%(class)s_related')  # 动态设置相关名字,避免子类冲突
    age = model.IntegerField()

    class Meta:
        abstract = True
        ordering = ['age']


class Programmer(BaseModel):
    lang = model.CharField(max_length=200)
```
### 多表继承
两个类都会创建数据库表
```py
from django.db import models


class Place(models.Model):
    name = models.CharField(max_length=300)

class address(models.Model):
    address = models.CharField(max_length=200)
```
### 代理模式
在内部类Meta中声明proxy=True,子类通过自定义的方法或者重写内部类Meta的方式,改变模型行为
```py
from django.db import models


class Student(models.Model):
    name = CharField(max_length=300)
    age = IntegerField()

class Teacher(Student):
    class Meta:
        proxy = True
        ordering = ['age']

    def teacher_age(self):
        return self.age + 17


```
## 3.6 存储文件
```py
def user_directory_path(instance, filename):  # ①接收模型实例 ②接收文件名
    return f"courses/user_{instance.user.id}/{filename}"

class Lesson(models.Model):
    video = models.FileField(upload_to=user_directory_path)
    attch = models.FIleField(upload_to=user_directory_path)


```
# 4. 创建用户
## 4.1 创建管理员
`python3 manage.py createsuperuser` 创建管理员

http://127.0.0.1:8000/admin/ 访问管理页面


# 6. 路由
## 路由匹配规则
1. urlpatterns为固定名称的列表
2. 列表中的元素就代表一个路由
3. 从上到下进行匹配，如果能匹配上，就调用和导入path函数的第二个参数（或去子路由文件中继续匹配）
4. 如果匹配不上，会自动抛出一个404异常

## 路由寻址顺序
1. 从根路由从上到下查找
2. 找到子应用/视图函数
3. 从子路由从上到下查找
4. 如果找不到返回404
## 6.1 工程路由
在项目同名目录下的`urls.py`文件中定义, 是Django解析路由的入口
```py
# 在工程目录下的urls.py中
from django.contrib import admin
from django.urls import path, include


urlpatterns = [
    path('admin/', admin.site.urls),  # 第一个参数是path, 第二参数是视图函数
    path('blog/', include('blog.urls')),  #　include 将指定path的路由都转到指定应用的路由管理
]
```
## 6.2 子应用路由
```py
# 在各application目录下创建urls.py文件
from django.urls import path
from django.contrib.auth import views as auth_views
from . import views


urlpatterns = [
    path('', view.blog_title),  # 第一个参数是path(空则为根), 第二参数是视图函数
    path('<int:article_id>', view.blog_article),  # 应用根后面的数字会当成参数传入
    path('login', auth.views.LoginView.as_view(template_name='account/login.html'), name='user_login')  # 使用内置的登录视图,登录后redirect默认为profile.此处需要在setting.py中修改
    path('logout/', auth_views.LogoutView.as_view(template_name='account/logout.html'), name='user_logout'),  # 内置的退出视图
]
```
### 6.2.2 命名路由
1. 方法一(推荐):直接在项目urls上传参app_name,在多应用下更方便管理
2. 方法二:在子应用中设置app_name变量

`project的urls.py`
```py
from django.urls import path, include


urlpatterns = [
    path("blog", include(('blog.urls', 'blog'), namespace='blog')),  # 方法一
    path("admin", include('admin.urls', namespace='admin'))  # 方法二
]
```
`app的urls.py`
```py
from django.urls import path
from . import views


app_name = 'admin'  # 方法二
urlpatterns = [
    path('', views.blog_article, name='blog_article')
]
```
### 6.2.3 路由重定向redirect
```py
LOGIN_REDIRECT_URL = '/blog/'  # 指定内置登录模块登录成功后redirect到正页
```
### 6.2.4 内置修改密码模块
```py
path('password_reset', auth_views.PasswordResetView.as_view(
    template_name='account/password_reset_form.html',
    email_template_name='account/password_reset_email.html',  # email_template_name发送的邮件模板
    success_url='/account/password_reset_done/')  # success_url如果成功跳转的地址
```
`setting.py`
```py
# email配置
EMAIL_HOST = 'smtp.163.com'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 25
EMAIL_USE_TLS = True
DEFAULT_FROM_EMAIL = ''
```
# 7. 表单
## 表单类
```py
from django import form


class LoginForm(form.Form):
    username = form.CharField()
    password = form.CharField(widget=forms.PasswordInput)


login_1 = LoginForm()  # 未向类传参,称为:未绑定实例
print(login_1.is_bound)  # False 未绑定实例则返回False
print(login_1)  # 生成如下HTML代码
"""
<tr><th><label for="id_username">Username:</label></th><td><input type="text" name="username" required id="id_username"></td></tr>
<tr><th><label for="id_password">Password:</label></th><td><input type="password" name="password" required id="id_password"></td></tr>
"""

account = {"username": "admin", "password": "qazwsxedc"}
login_2 = LoginForm(account)
print(login_2.is_bound)  # 已绑定实例则返回 True
print(login_2.is_valid())  # True ; 判断入参数据是否合法

# 只有实例使用过is_valid()这个方法才可以使用下面的方法
print(login_2.cleaned_data)  # {"username": "admin", "password": "qazwsxedc"}
# 以字典形式返回合法入参,若某项入参不合法则不显示
```
## 表单模板
```django
<form class="form-horizontal" action="." method="post">
    {% csrf_token %}
    <!-- post请求需要携带csrf,否则报错 -->
    {{ form.as_p }}
    <!-- 每个表单项都用<p>标签包围(会换行) -->
    {{ form.as_table }}
    <!-- 不做任何包围(不会换行) -->
    {{ form.as_ul }}
    <!-- 每个表单项都被用<li>标签包围(会换行,带·) -->

    <label for="{{ form.username.id_for_label }}"></label>
    <!-- 关联label和input -->
    <div>{{ form.username }}</div>
    <!-- form.表单项 可以提出单项表单 -->

    <input type="submit" value="Login" class="btn btn-primary btn-lg">
</form>
```
## 表单模型类
```py
from django import form
from django.contrib.auth.models import User
from .models import UserProfile


class RegistrationForm(form.ModelForm):
    password = forms.CharField(label="Password", widget=forms.PasswordInput)
    password2 = forms.CharField(label="Confirm Password", widget=forms.PasswordInput)

    class Meta:
        model = User  # 指定数据模型
        fields = ("username", "email")  # 指定需要显示为表单的字段
        # exclude = ('',)  # 排除元组中的字段外都需要显示为表单

    def clean_password(self):  # 以'clean_ + 名称'的方法都会在调用表单实例对象的is_valid()函数时被执行
        cd = self.cleaned_data
        if cd['password'] != cd['password2']:
            raise forms.ValidationError("password do not match")
        return cd['password']


class UserProfileForm(form.ModelForm):
    class Meta:
        model = UserProfile
        fields = ("phone", "birth")
```

# 视图
## 函数视图
1. 函数视图不方便在针对不同请求模式的时候做处理，会显的代码很臃肿
2. 使用函数视图时，任意请求方法都可以访问
## HttpResponse
```py
from django.http import HttpResponse

def login(request):
    dic = {
            "username": "admin",
            "password": "qazwsx"
        }
        res = json.dumps(dic)
    HttpResponse(content=res, content_type="application/json", status=200)  # 使用该函数，需要将返回文本处理成byte类型
    # ------------------------------
    h = HttpResponse
    h.write("")  # 支持如写文件一样写入
    return h
```
## 关联数据模型
```py
from .forms import RegistrationForm, UserProfileForm

def register(request):
    if request.method == "POST":
        register_form = RegistrationForm(request.POST)
        profile_form = UserProfileForm(request.POST)
        if register_form.is_vaild() * profile_form.vaild():  # 相当于and True*False → 0
            new_form = register_form.save(commit=False)  # 将表单数据存到数据库,并生成该数据对象.如果commit=False的话,仅生成数据对象
            new_form.set_password(register_form.cleaned_data['password'])  # User的内置函数,加盐加密后保存
            new_form.save()  # 默认为True
            new_profile = profile_form.save(commit=False)
            new_profile.user = new_form  # 关联两个数据模型
            new_profile.save()
            return HttpResponse("successfully")
        else:
            return HttpResponse("Sorry Invaild")
    elif request.method == "GET":
        register_form = RegistrationForm()
        profile_form = UserProfileForm()
        return render(request, "account/register.html", {"form":register_form, "profile": profile_form})
```
# 类视图
```py
from django.views.generic import ListView
from .models import Course


class CourseListView(ListView):
    model = Course  # 相当于Course.object.all()
    context_object_name = "courses"  # 结果集在模板中的变量名
    template_name = 'course/course_list.html"

```
类视图直接以不同的请求模式作为方法名，用作区分

在路由中映射类视图时，需要调用 `.as_view()`
```py
from django.views import View


class IndexView(View):

    def get(self, request):
        return ""
    
    def post(self, request):
        return ""

# ---------以下是路由------------------------
from django.urls import path
from . import views


urlpatterns = [
    path("", views.IndexView.as_view())
]

```
获取请求
```py
from django.views import View
from django.http import HttpResponse, JsonResponse


class IndexView(View):

    def get(self, request):
        value = request.GET["KEY"]  # 可以以字典的形式查询查询字符串
        lis = request.GET.getlist('name')  # 查询字符串中若有相同key，则该key的value以列表形式存储
        value2 = request.GET('name')  # 若直接查询，则得到列表中最后一个value
        return ""
    
    def post(self, request):
        form = request.POST["KEY"]  # 以字典的形式查询form表单

        import json 
        # 将request的json字节转化成字典
        body_byte = request.body  # 获取json字节
        body_str = body_byte.encode("UTF-8")  # 将字节转化成字符串
        body_dict = json.loads(body_str)  # 将字符串转化成字典
        
        # 将字典转化成json字节，返回给前端
        dic = {
            "username": "admin",
            "password": "qazwsx"
        }
        res = json.dumps(dic)
        return HttpResponse(content=res, content_type="application/json", status=200)  # 使用该函数，需要将返回文本处理成byte类型

    def put(self, request):
        dic = {
            "username": "admin",
            "password": "qazwsx"
        }
        return JsonResponse(data=dic)  # 该方法无需自行转换成json，如果data为json则需要将safe=False

```
