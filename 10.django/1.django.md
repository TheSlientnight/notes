# 1.django

## 1day

### 创建django project有两个方法

1. 使用命令行： `python3 django-admin startproject project_name`
2. 使用pycharm专业版，在新创建工程中选择django

   **运行服务**

3. 使用命令行： `python3 manage.py runserver`
4. 使用IDE启动

   **创建子应用**

5. 使用命令行： `python3 manage.py startapp application_name`
6. 使用IDE，点击tools，选择`Run manage.py Task..`.在该交互环境下，命令行：`startapp application_name`

   **注册子应用**

7. 在工程目录下，`setting.py`的`INSTALLED_APPS`中添加application\_name

   **路由匹配规则**

8. urlpatterns为固定名称的列表
9. 列表中的元素就代表一个路由
10. 从上到下进行匹配，如果能匹配上，就调用和导入path函数的第二个参数（或去子路由文件中继续匹配）
11. 如果匹配不上，会自动抛出一个404异常

    **视图**

    **函数视图**

12. 函数视图不方便在针对不同请求模式的时候做处理，会显的代码很臃肿
13. 使用函数视图时，任意请求方法都可以访问

    **类视图**

    类视图直接以不同的请求模式作为方法名，用作区分

    在路由中映射类视图时，需要调用 `.as_view()`

    \`\`\`py

    from django.views import View

class IndexView\(View\):

```text
def get(self, request):
    return ""

def post(self, request):
    return ""
```

## ---------以下是路由------------------------

from django.urls import path from . import views

urlpatterns = \[ path\("", views.IndexView.as\_view\(\)\) \]

```text
## 模板
`forloop.counter` for循环计数
M全拼为Model，与MVC中的M功能相同，负责和数据际交互，进行数据处理
V全拼为View，与MVC中的C功能相同，接收请求，进行业务处理，返国响应
T全拼为Template，与MVC中的V功能相同，负责构造要返的html页面

## 前后端
### 前后端不分离
    后端需控制数据的展示
    前后端不分家，耦合严重
    返回的是HTML页面，实应性、拓展性差
    只能用于浏览器，其他终端不适配
### 前后端分离
    当前主流
    后端只对数据进行处理，只提供数据
    前端效率、页面好不好看，全由前端负责，前后端完全独立
    解耦合
    前后端同时开始开发，缩小业务上线周期
    绝大多数情况下，后端发送json格式的参数，后端同样也json格式
    ·适应性、拓展性非常好
    ·适合多终端运行同一套接口（PC、APP、小程序等）

## 获取请求
```py
from django.views import View
from django.http import HttpResponse, JsonResponse


class IndexView(View):

    def get(self, request):
        value = request.GET["KEY"]  # 可以以字典的形式查询查询字符串
        lis = request.GET.getlist('name')  # 查询字符串中若有相同key，则该key的value以列表形式存储
        value2 = request.GET('name')  # 若直接查询，则得到列表中最后一个value
        return ""

    def post(self, request):
        form = request.POST["KEY"]  # 以字典的形式查询form表单

        import json 
        # 将request的json字节转化成字典
        body_byte = request.body  # 获取json字节
        body_str = body_byte.encode("UTF-8")  # 将字节转化成字符串
        body_dict = json.loads(body_str)  # 将字符串转化成字典

        # 将字典转化成json字节，返回给前端
        dic = {
            "username": "admin",
            "password": "qazwsx"
        }
        res = json.dumps(dic)
        return HttpResponse(content=res, content_type="application/json", status=200)  # 使用该函数，需要将返回文本处理成byte类型

    def put(self, request):
        dic = {
            "username": "admin",
            "password": "qazwsx"
        }
        return JsonResponse(data=dic)  # 该方法无需自行转换成json，如果data为json则需要将safe=False
```

## 4day

### ORM框架

#### 修改默认数据库为mysql

`setting.py`文件中`DATABASES`

```python
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',  # 修改引擎
        'NAME': 'my_django',
        'USER': 'root',
        'PASSWORD': 'qazwsx',
        'HOST': 'localhost',
        'PORT': 3306
    },
    'sqlite3': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': os.path.join(BASE_DIR, 'db.sqlite3'),
    }
}
# 可以支持多个数据库，在migrate时要指定
```

#### 模型类

1. 每一个应用下的数据库模型类，需要在当前应用下的models.py文件中定义
2. 一个数据库模型类相当与一个数据表（Table）
3. 一个数据库模型类需更继承Model或者Model的子类
4. 定义的一个类属性，就相当于数据库表中的一个字段
5. 默认会创建一个自动递增的id主键
6. 默认创建的数据库名： 应用名小写\_模型类名小写
7. max\_length为字段的最大长度
8. unique参数用于设置当前字段是否唯一，默认为unique=False
9. verbose\_name用于设置跟人性化的字段名
10. help\_text用于api文档中的一个中文名称

    \`\`\`py

    from django.db import models

class Person\(models.Model\): first\_name = CharField\(max\_length=300\) last\_name = CharField\(max\_length=300\) full\_name = CharField\(max\_length=300, verbose\_name='name', unique=True, help\_text='名称'\)

```text
# max_length：最大长度   unique：是否唯一，默认False     verbose_name：用于设置更人性化的字段名
# help_text：用于api文档中的中文名称
desc = mo
class Meta:
    db_table = 'tb_projects'

def __str__():
    return "self.full_name"
```

```text
CRUD
```py
# 创建数据
# 方法一：
one_obj = Projects(name="", leader="")
one_obj.save()
# 方法二：
one_obj = Projects.objects.create(name="", leader="")






#1. QuerySet 查询集，存放所有项目对象的列表 
obj = Projects.objects.all()
#2. 指定查询返回模型对象
obj = Projects.objects.get(id=1)  # 如果返回的是多条记录或者查询不存在会抛出异常，查询只能使用主键或为唯一键
#3. 获取某一些记录 返回查询集
some_obj = Projects.objects.filter(id=1)
#4. 反向命中 返回查询集
exclude_obj = Projects.objects.exclude(id=1)  # 获取除命中条件外的所有模型对象
#5. 模糊查询
contains_obj = Projects.objects.filter(id__contains=1)  # (where id like "%1%")
#6. 忽略大小写
icontains_obj = Projects.objects.filter(id__icontains=1)  # 
#7. 模糊查询开头
startswith_obj = Projects.objects.filter(id__startswith=1)
#8. 模糊查询结尾
endswith_obj = Projects.objects.filter(id__endswith=1)
#9. 正则表达式regex
#10. 精确匹配exact
#11. in范围获取
in_obj = Projects.objects.filter(id__in=['1', '2'])
#12. 关联查询(内连接) 通过子表查父表
foreign_obj = Projects.objects.filter(foreign__从表字段名__contains='')
#13. 关联查询 通过父表查子表
#14. 多字段查询(逻辑关系)
multi = Projects.objects.filter(leader='icon', name="")  # ＆的关系

#14.2 Q/F
from django.db import Q, F

# Q 对象可以使用 & | ~ （与 或 非）操作符进行组合,Q 对象要在所有关键字的前面
# 查询((结尾为"菜") 或 非(2010年10月))的查询集
models.Book.objects.filter(Q(title__endswith="菜") | ~Q(Q(pub_date__year=2010) & Q(pub_date__month=10)))


# F 动态获取对象字段的值，可以进行运算。对象和常数之间的加减乘除和取余的操作，修改操作（update）也可以使用
Project.objects.filter(F(salary__gt="age")).values()

Project.objects.update(price=F(age)*300)

#15. 比较查询
gt_obj = Projects.objects.filter(id__gt=2)  # id大于2

    __gt >
    __gte >=
    __lt <
    __lte <=

# 查询集相当于一个列表，支持列表中的大多数操作(下标索引，正向切片，for循环)
# 是对数据库操作的优化
# 会缓存结果（第一去查询，第二次不会再去查询，惰性查询）
# 支持链式操作
Project.object.filter(leader="").filter(name="")  # 基于前面的结果再次查询
```

U

```python
# 先获取 得到对象后直接赋值
res = Projects.objects.get(id=1)
res.name = "hahahxixi"
res.save()
```

D

```python
# 先获取 得到对象后直接赋值
res = Projects.objects.filter(name__contains="521")
one_project = res.first()
one_project.delete()  # 会自动保存，无需save
```

排序，分组

```python
order_obj = Projects.objects.filter(id__gte=3).order_by('-interfaces__name')  # 默认升序，如果要倒序则再前面加"-"
multi_order_obj = Projects.objects.filter(id__gte=3).order_by('-interfaces__name', "publish_app")  # 多重排序
```

高级查询

1. 聚合查询函数:aggregate
2. 额外查询:annotate
3. values 或者 values\_list 放在 annotate 前面：values 或者 values\_list 是声明以什么字段分组，annotate 执行分组。
4. values 或者 values\_list 放在annotate后面： annotate 表示直接以当前表的pk执行分组，values 或者 values\_list 表示查询哪些字段， 并且要将 annotate 里的聚合函数起别名，在 values 或者 values\_list 里写其别名。

   \`\`\`py

   **aggregate**

   Projects.objects.aggregate\(Avg\("id"\)\).values\(\)

   **Out\[24\]: dict\_values\(\[1.0\]\)**

## annotate

Projects.objects.values\('id', 'name'\).annotate\(haha=Avg\("id"\)\) \# 声明分组字段

Projects.objects.annotate\(xixi=Avg\("id"\)\).values\('name'\) \# 声明显示字段

Projects.objects.values\('id', 'name'\).annotate\(haha=Avg\("id"\)\).values\("id"\) \# 可嵌套使用

```text
# Django restframework
## REST API
RESTful 是一种开发理念，是设计风格而不是标准
- 具象状态传输
- 每一个URL代表一种资源（json, text, 图片, 视频等）
- 请求头Content-Type指明给服务端的参数类型
- 请求头Accept：指明希望接收服务端的数据类型

## 设计规则
1. URL
    - 尽量用名词复数形式
    - 往往与数据库表名相同
2. 过滤条件（查询字符串）
    - ?limit=10: 指定返回记录的数量
    - ?offset=10: 指定返回记录的开始位置
    - ?page=2&size=10: 指定第几页和每页的数据条数
    - ?sort=name: 指定返回结果按找哪个属性排序,以及排序顺序
3. 版本
    - 版本号可以放在URL也可以放在请求头


## django优劣
1. 代码冗余
2. 数据校验麻烦，复用性差
3. 编码规范不统一
4. 仅支持json格式的返回，不支持其他类型
5. 仅支持json格式的传参，不支持form表单传参
6. 列表页视图没有分页，过滤，排序

## 简介
- 在Django框架基础之上，进行二次开发
- 用于构建Restful API
- 简称为DRF框架

## 特性
- 提供强大的Serializer序列器，可以高效进行序列化和反序列化
- 提供了极为丰富的类视图,MiXIN扩展类,ViewSet视图集
- 提供只管的WebAPI界面
- 多种身份认证和权限认证
- 强大的排序，过滤，分页，搜索，限流等
- 可扩展性，插件丰富


## 安装
pip install djangorestframework

## 序列化器
```py
# 建立序列化器类
from rest_framework import serializer

class ProjectSerializer(serializer.Serializer):
    name = serializer.CharField(max_length=200)

# --------------------------------------------------
# 视图
from .model import Interfaces
from .serializer import ProjectSerializer
from django.http import JsonResponse

def view_1(request, pk):
    object = Interfaces.object.get(id=pk)
    serializer = ProjectSerializer(instance=object)  # 序列化输出
    return JsonResponse(serializer.data)

def view_2(request):
    object = Interfaces.object.all()
    serializer = ProjectSerializer(instance=object, many=True)  # 如果是查询集对象，需要设置many参数
    return JsonResponse(serializer.data, safe=True)  # 如果是多个数组嵌套，需要开启safe
```

```python
# 视图类
class ProjectDetail(View):

    @staticmethod  # 提取公用的方法
    def get_object(pk):
        try:
            project = Interfaces.objects.get(id=pk)
        except project.DoesNotExist:
            return Http404
        return project

    def post(self, request, pk):
        # 反序列化
        json_data = request.body.decode('utf-8')
        dict_data = json.loads(json_data, encoding='utf-8')

        serializer = ProjectSerializer2(data=dict_data)
        # 开始校验前端参数
        try:
            serializer.is_valid(raise_exception=True)  # 如果失败抛出异常
        # 当调用is_valid方法后，才可以调用errors属性，获取错误提示
        except Exception as e:
            return JsonResponse(serializer.errors)
        # 1. 如果在创建序列化器对象的时候，只给data传参，那么调用save()方法，实际调用就是序列化器对象的create()
        project_id = Projects.objects.get(name=dict_data.get("project"))
        serializer.save(project_id=project_id)  # 在save中传参会和合并到validated_data中

        return JsonResponse(serializer.data)

    def put(self, request, pk):
        # 反序列化
        json_data = request.body.decode('utf-8')
        dict_data = json.loads(json_data, encoding='utf-8')
        project = self.get_object(pk)
        serializer = ProjectSerializer2(instance=project, data=dict_data)
        try:
            serializer.is_valid(raise_exception=True)
        except Exception as e:
            return JsonResponse(serializer.errors)
        project_obj = Projects.objects.get(name=dict_data.get("project"))
        serializer.save(project=project_obj)
        # 创建序列化器对象时，同时给instance和data传参，在调用save方法时，实际调用序列化器内的update函数
        return JsonResponse({"success": True})


# -------------------------序列化器


# 自定义校验器
def is_unique_project_name(name):
    if '项目' not in name:
        raise serializers.ValidationError("项目名格式错误")


# 序列化器类
class ProjectSerializer2(serializers.Serializer):
    """demo2
        需要输出什么字段就在序列化器中定义什么
    """
    # label选项相当于verbose_name, help_text
    id = serializers.IntegerField(label='ID', read_only=True)
    # read_only=True指定该字段，只能做序列化输出;write_only=True指定该字段只进行反序列化输入，但不进行序列化输出
    name = serializers.CharField(label='项目名称', max_length=200, help_text='',
                                 validators=[UniqueValidator(queryset=Interfaces.objects.all(), message="name不能重复"),
                                             is_unique_project_name], error_messages={'max_length': '长度不能超过200'})  
                                             # 自定义错误提示 # validators校验器
    leader = serializers.CharField(label='领导', max_length=200)
    tester = serializers.CharField(label='测试', max_length=200)
    programer = serializers.CharField(label='开发', max_length=200)
    publish_app = serializers.CharField(label='发布备注', max_length=200)
    desc = serializers.CharField(label="概述", allow_blank=True, allow_null=True)

    # project = serializers.CharField(max_length=200)  # 外键可不用

    # 字段校验器顺序：在字段定义中从左到右校验 → 校验内置校验器(validate_*) → 多字段联合校验(validate)
    # 单字段的校验,无需在字段中注册,自动识别。
    # start with一定要为validate
    def validate_name(self, value):
        if not value.endswith('项目'):
            raise serializers.ValidationError('项目名称必须以项目结尾')
        # 当校验成功的时候一定要返回value
        return value

    # 多字段校验只能用这个方法名
    def validate(self, attrs):  # 会将所有的反序列化对象传入attrs参数
        if 'icon' not in (attrs['tester'], attrs['leader']):
            raise serializers.ValidationError('tester||leader错误')
        return attrs

    # 当实例化对象时仅传入【instance=模型对象】时在序列化器类对象调用.save()方法时调用该方法
    def create(self, validated_data):
        print(validated_data)
        project = Interfaces.objects.create(**validated_data)
        return project  # 要返回模型对象

    # 当实例化对象时传入【instance=模型对象】和【data=反序列化数据】时在序列化器类对象调用.save()方法时调用该方法
    def update(self, instance, validated_data):  # 在序列化器类对象调用.save()方法时调用该方法
        instance.name = validated_data['name']
        instance.leader = validated_data['leader']
        instance.tester = validated_data['tester']
        instance.programer = validated_data['programer']
        instance.publish_app = validated_data['publish_app']
        instance.desc = validated_data['desc']
        instance.project = validated_data['project']
        instance.save()
        return instance  # 要返回模型对象
```

#### CharField等类型限制

| 参数 | 说明 |
| :--- | :--- |
| max\_length | 最大长度 |
| min\_length | 最小长度 |
| allow\_blank | 是否允许为空 |
| trim\_whitespace | 是否截断空白字符 |
| max\_value | 最小值 |
| min\_value | 最大值 |

#### 字段通用限制

| 参数 | 说明 |
| :--- | :--- |
| read\_only | 表明该字段仅用于序列化输出，默认False |
| write\_only | 表明该字段仅用于反序列化输入，默认False |
| required | 表明该字段在反序列化时必须输入，默认True |
| default | 反序列化时使用的默认值 |
| allow\_null | 表明该字段是否允许传入None，默认False |
| validators | 该字段使用的验证器 |
| error\_messages | 包含错误编号与错误信息的字典label用于HTML展示API页面时，显示的字段名称 |
| help\_text | 用于HTML展示API页面时，显示的字段帮助提示信息 |

#### 7. 反序列化

* 演示反序列化操作：
* 数据校验
  * 在序列化器字段定义时，通过validators选项添加校验器
  * 单字段校验和多字段校验
  * 序列化器字段校验顺序
    * 字段定义时的限制（包含validators列表条目从左到右进行校验）→ 单字段校验（validate\_\*） → 多字段校验（validate）
* 保存或更新数据库模型

#### 8. ModelSerializer 模型序列化器

* 为了简化序列化器类的定义
* 功能
  * 基于模型类自动生成一系列字段
  * 基于模型类自动为Serializer生成validators，比如unique\_together
  * 包含默认的create\(\)和update\(\)的实现

    \`\`\`py

    **从表模型**

    class ProjectModelSerializer\(serializers.ModelSerializer\):

    **1. 显示创建序列化器字段（支持不是meta类中指定model的字段）**

    name = serializers.CharField\(label='项目名称', max\_length=200, help\_text='', \# 自定义的字段会cover自动创建的字段, validators=\[UniqueValidator\(queryset=Interfaces.objects.all\(\), message="name不能重复"\), is\_unique\_project\_name\]\) \# 当有校验器失败后,会继续校验全部指定的校验器\(类的校验器不会\)，通过后才会运行类校验器

    **外键 source默认为变量名，当变量名与外键字段名不同时，需指定source到外键字段名**

    **1. 数据库模型中的外键字段，默认会生成PrimaryKeyRelatedField序列化器类型，序列化输出的值为外键ID值**

    project\_str = serializers.StringRelatedField\(source='project'\)

    **2. 当设置为StringRelatedField类型的时候，将被序列化为关联对象字符串表达形式（str方法）**

    project\_slug = serializers.SlugRelatedField\(slug\_field='leader', source='project', queryset=Projects.objects.all\(\)\)

    **3. SlugRelatedField此字段将被序列化为关联对象的指定字段数据**

    project\_obj = XiProjectModelSerializer\(read\_only=True, source='project'\) \# 通常设置为只读

    **4. 使用关联对象的序列化器**

    **自动创建create update**

    class Meta: model = Interfaces fields = "**all**"

    **fields = \('id', 'name'\)**

    **exclude = \('',\)  \# 排除项**

    read\_only\_fields = \('id', ''\) \# 指定read\_only字段 extra\_kwargs = { \# 自动添加的才可以, 在该变量内可定制化字段，嵌套字典格式 'method': { \# 字段参数

    ```text
          # 'write_only': True,
          'error_messages': {'max_length': '不能大于200字数', 'min_length': '不能小于6位数'}
      },
      'url': {
          # 'write_only': True,
          'validators': [UniqueValidator(queryset=Interfaces.objects.all(), message="name不能重复"),
                         is_unique_project_name]
      }
    ```

    }

    def validate\_name\(self, value\): if not value.endswith\('项目'\): raise serializers.ValidationError\('项目名称必须以项目结尾'\)

    **当校验成功的时候一定要返回value**

    return value

    def validate\(self, attrs\): \# 会将所有的反序列化对象传入attrs参数 if 'icon' not in \(attrs\['url'\], attrs\['path'\]\): raise serializers.ValidationError\('tester\|\|leader错误'\) return attrs

```text
```py
# 父表模型
class XiProjectModelSerializer(serializers.ModelSerializer):

    # 父表默认不生成关联字段，可以手动指定，字段名默认为 "关联子表模型类_set"
    # 反向查询
    interfaces_set = serializers.StringRelatedField(many=True)  # 因为父表查子表为结果集，所以要many=True

    class Meta:
        model = Projects
        fields = "__all__"
```

#### 11. DRF的Request

`from rest_framework.views import APIView`视图类继承

* Request对Django中的HttpRequest进行了拓展
  * 会根据请求头中的Content-Type，自动进行解析
  * 无论前端发送的哪种格式的数据，都可以以相同的方式读取
* request.data
  * 类似于Django中的request.POST和request.FILES
  * 可以对POST、PUT、PATCH的请求体参数进行解析
  * 不仅支持form传参，也支持json格式传参
* request.query\_params
  * 类似于Django中的request.GET
  * 获取查询字符串参数
* 支持Django HttpRequest中所有的对象和方法

#### 12. DRF的Response

`from rest_framework.response import Response` `Response(data=None, status=None,template_name=None, headers=None,exception=False, content_type=None)`

* data
  * 序列化处理后的数据
  * 一般为serializer.data（python基本数据类型，字典，嵌套字典的列表）
* status
  * 状态码，默认为200
  * 可以使用`from rest_framework import status`中的常量设置
* template\_name
  * 模板名称，使用HTMLRenderer渲染时需指明
* headers
  * 用于存放响应头信息的字典
* content\_.type
  * 响应头中的Content-Type
  * 通常此参数无需设置，会自动根据前端所需类型数据来设置该参数

### 类视图

#### 1. APIView

* 继承Django中的View
* APIView与View的不同之处
  * 传入到视图方法中的是Request对象，而不是Django的HttpRequeset对象
  * 视图方法可以返回Response对象，会为响应数据处理（render）为符合前端要求的格式
  * 任何APIException异常都会被捕获到，并且处理成合适的响应信息
  * 在进行dispatch\(\)分发前，会对请求进行身份认证、权限检查、流量控制
* 常用类属性
  * authentication\_classes列表或元祖，身份认证类
  * permissoin\_classes列表或元祖，权限检查类
  * throttle\_classes 列表或元祖，流量控制类

#### 2. GenericAPIView

* 继承APIView
* 支持的类属性
  * 必须指定的属性
    * queryset
    * Iserializer\_class
* 支持的类方法
  * get\_queryset（self）
    * 返回视图使用的查询集对象
  * get\_object（self）
    * 返回详情视图所需的模型类对象
    * 默认使用lookup\_field（pk）参 数来过滤
    * 如果访问的模型类对象不存在，会返回404
  * get\_serializer（self，_args，\*_kwargs）
    * 返回序列化器对象
  * get\_serializer\_class（self）
    * 返回序列化器类，默认返回serializer\_class
    * 可以重写

**字段**

```python
# 1. 试图类中自定过滤引擎
filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
# 2. 指定需要排序的字段
ordering_fields = ['id', 'name', 'url']  # 查询字符串：path?ordering=-name
# 3. 指定查询集
queryset = Interfaces.objects.all()  # 实例时仅会请求一次，不能在方法中直接self.queryset进行使用
# 4. 指定序列化器
serializer_class = ProjectModelSerializer
# 5. 设置主键字段
lookup_field = 'pk'
# 6. 指定需要过滤的字段
filterset_fields = ['name', 'url']  # 查询字符串：path?name=user
# 7. 指定分页引擎
pagination_class = PageNumberPaginationManual
```

**排序**

* filter\_backends
* ordering\_fields

  \`\`\`py

  **1. 在类中设置**

  from rest\_framework import filters

## 2. 设置类属性

filter\_backends = \[filters.OrderingFilter\]

## 指定需要排序的字段

ordering\_fields = \['-name', 'leader'\] \# 查询字符串：path?ordering=-name -为倒序

## ---------------------------

## 3. 在setting中全局设置

REST\_FRAMEWORK{

```text
# 在全局指定过滤引擎
'DEFAULT_FILTER_BACKENDS': ['rest_framework.filters.OrderingFilter'],
```

}

```text
demo.py

```py
from rest_framework.generics import GenericAPIView
from rest_framework import filters  # 过滤引擎


class InterfacesTitle(GenericAPIView):
    # 常量设置：
    # 1. 试图类中自定过滤引擎
    filter_backends = [filters.OrderingFilter]
    # 2. 指定需要排序的字段
    ordering_fields = ['name', 'leader']
    # 3. 指定查询集
    queryset = Projects.objects.all()  # 实例时仅会请求一次，不能在方法中直接self.queryset进行使用
    # 4. 指定序列化器
    serializer_class = ProjectModelSerializer

    def get(self, request):
        # project = Interfaces.objects.all()
        project = self.get_queryset()
        cleaned_data = self.filter_queryset(project)
        # serializer = ProjectModelSerializer(instance=project, many=True)
        serializer = self.get_serializer(instance=cleaned_data, many=True)
        return Response(serializer.data)
```

**过滤**

* filter\_backends
* ordering\_fields

安装 django-filter库：`pip install django-filter` 过滤库

```python
# 1. 安装后需要在setting中设置
INSTALLED_APPS = [
    #...
    'django_filters'
]


# 2. 在类中设置
filter_backends = [DjangoFilterBackend]
# 指定需要过滤的字段
filterset_fields = ['name', 'leader']  # 查询字符串：path?name=user

# ---------------------------

# 3. 在setting中全局设置
REST_FRAMEWORK{
    # 在全局指定过滤引擎
    'DEFAULT_FILTER_BACKENDS': ['django_filters.rest_framework.backends.DjangoFilterBackend'],
}
```

**分页**

```python
# 在setting文件的
REST_FRAMEWORK{
    # 在全局指定分页的引擎
    'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',
    # 每页条数
    'PAGE_SIZE': 3,
}
```

#### MiXins

* RetrieveModelMixin
  * 提供retrieve（request，_args，\*_kwargs）方法
  * 获取已存在的详情数据（一 条记录）
  * 获取成功，则返回200 OK
  * 如果不存在，则返回404 Not Found
* UpdateModelMixin
  * 提供update（request，_args，\*_kwargs）方法，用于全更新
  * 提供partial\_update（request，_args，\*_kwargs）方法，用于部分更新，支持PATCH方法
  * 更新已存在的模型实例（更新一条记录）
  * 更新成功，则返回200 OK
  * 如果请求参数有误，则返回400 Bad Request
  * 如果不存在，则返回404 Not Found
* DestroyModelMixin
  * 提供destroy（request，_args，\*_kwargs）方法
  * 删除-条已存在的数据（删除一 条记录）
  * 删除成功，则返回204 No Content。如果不存在，则返回404 Not Found
* CreateModelMixin
  * 提供create（request，_args，\*_kwargs）方法
  * 创建新的模型实例（创建新的记录）
  * 创建成功，则返回201 Created
  * 如果请求参数有误，则返回400 Bad Request

```python
from django import mixins


class InterfacesTitleMiXinDemo(
    GenericAPIView,
    mixins.ListModelMixin,
    mixins.CreateModelMixin,
    mixins.RetrieveModelMixin,
    mixins.UpdateModelMixin,
    mixins.DestroyModelMixin):

    # 1. 试图类中自定过滤引擎
    filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
    # 2. 指定需要排序的字段
    ordering_fields = ['id', 'name', 'url']  # 查询字符串：path?ordering=-name
    # 3. 指定查询集
    queryset = Interfaces.objects.all()  # 实例时仅会请求一次，不能在方法中直接self.queryset进行使用
    # 4. 指定序列化器
    serializer_class = ProjectModelSerializer
    # 5. 设置主键字段
    lookup_field = 'pk'
    # 6. 指定需要过滤的字段
    filterset_fields = ['name', 'url']  # 查询字符串：path?name=user
    # 7. 指定分页引擎
    pagination_class = PageNumberPaginationManual

    def post(self, request, *args, **kwarg):
        return self.create(request, *args, **kwarg)

    def get_list(self, request, *args, **kwargs):  # 进行过滤 排序 分页后，输出列表
        return self.list(request, *args, **kwargs)

    def get(self, request, *args, **kwargs):  # 输出模型数据
        return self.retrieve(request, *args, **kwargs)  #

    def put(self, request, *args, **kwargs):
        return self.update(request, *args, **kwargs)

    def delete(self, request, *args, **kwargs):
        return self.destroy(request, *args, **kwargs)
```

#### Concrete Generic view

* RetrieveAPIView
  * 提供get方法I
  * 继承：RetrieveModelMixin、GenericAPIView
* UpdateAPIView。提供put和patch方法
  * 继承：UpdateModelMixin、GenericAPIView
* DestroyAPIView
  * 提供delete方法
  * 继承：DestoryModelMixin、GenericAPIView
* ListAPIView
  * 提供get方法
  * 继承：ListModelMixin、GenericAPIView
* CreateAPIView
  * 提供post方法
  * 继承：CreateModelMixin、GenericAPIView
* ListCreateAPIView
  * 提供post.get方法
  * 继承：ListModelMixin、CreateModelMixin、GenericAPIView
* RetrieveUpdateAPIView
  * 提供get、put、patch方法
  * 继承：RetrieveModelMixin、UpdateModelMixin、GenericAPIView
* RetrieveDestroyAPIViewI
  * 提供get、delete方法
  * 继承：RetrieveModelMixin、DestroyModelMixin、GenericAPIView
* RetrieveUpdateDestroyAPIView
  * 提供get、put、patch、delete方法
  * 继承：RetrieveModelMixin.UpdateModelMixin、DestroyModelMixin、GenericAPIView

#### ViewSet

| 请求方法 | 方法\(action\) | 描述 |
| :--- | :--- | :--- |
| GET | retriever | 获取详情数据（单条） |
| GET | list | 获取列表数据（多条） |
| POST | create | 创建数据 |
| PUT | update | 更新数据 |
| PATCH | partial\_update | 部分更新 |
| DELETE | destroy | 删除数据 |

```python
# ViewSet 不再支持get post等请求方法，只支持action动作
# 但该父类未提供generic的get_serializer、get_object等方法
# 继承GenericViewSet类可以解决
class InterfacesViewSet(viewsets.GenericViewSet):
    # 1. 试图类中自定过滤引擎
    filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
    # 2. 指定需要排序的字段
    ordering_fields = ['id', 'name', 'url']  # 查询字符串：path?ordering=-name
    # 3. 指定查询集
    queryset = Interfaces.objects.all()  # 实例时仅会请求一次，不能在方法中直接self.queryset进行使用
    # 4. 指定序列化器
    serializer_class = ProjectModelSerializer
    # 5. 设置主键字段
    lookup_field = 'pk'
    # 6. 设置url中查询字符串的关键字key名
    lookup_url_kwarg = 'pk'  # 默认与lookup_field相同
    # 7. 指定需要过滤的字段
    filterset_fields = ['name', 'url']  # 查询字符串：path?name=user
    # 8. 指定分页引擎
    pagination_class = PageNumberPaginationManual
    # 9. 设置url中查询字符串页数条数key名
    page_size_query_param = "page_size"

    def create(self, request, *args, **kwargs):
        serializer = self.get_serializer(data=request.data)
        serializer.is_valid(raise_exception=True)
        serializer.save()
        return Response(serializer.data, status=status.HTTP_201_CREATED)

    def list(self, request, *args, **kwargs):
        queryset = self.filter_queryset(self.get_queryset())

        page = self.paginate_queryset(queryset)
        if page is not None:
            serializer = self.get_serializer(page, many=True)
            return self.get_paginated_response(serializer.data)

        serializer = self.get_serializer(queryset, many=True)
        return Response(serializer.data)

    def retrieve(self, request, *args, **kwargs):
        instance = self.get_object()
        serializer = self.get_serializer(instance)
        return Response(serializer.data)

    def update(self, request, *args, **kwargs):
        partial = kwargs.pop('partial', False)
        instance = self.get_object()
        serializer = self.get_serializer(instance, data=request.data, partial=partial)
        serializer.is_valid(raise_exception=True)
        serializer.save()

        return Response(serializer.data)

    def destroy(self, request, *args, **kwargs):
        instance = self.get_object()
        instance.delete()
        return Response(data={"success": True}, status=status.HTTP_204_NO_CONTENT)
```

↓

```python
from rest_framework.decorators import action


# class InterfacesMiXinViewSets(viewsets.ViewSet,
#                               mixins.ListModelMixin,
#                               mixins.DestroyModelMixin,
#                               mixins.UpdateModelMixin,
#                               mixins.RetrieveModelMixin,
#                               mixins.CreateModelMixin):
class InterfacesMiXinViewSets(viewsets.ModelViewSet):
    # 1. 试图类中自定过滤引擎
    filter_backends = [filters.OrderingFilter, DjangoFilterBackend]
    # 2. 指定需要排序的字段
    ordering_fields = ['id', 'name', 'url']  # 查询字符串：path?ordering=-name
    # 3. 指定查询集
    queryset = Interfaces.objects.all()  # 实例时仅会请求一次，不能在方法中直接self.queryset进行使用
    # 4. 指定序列化器
    serializer_class = ProjectModelSerializer
    # 5. 设置主键字段
    lookup_field = 'pk'
    # 6. 设置url中查询字符串的关键字key名
    lookup_url_kwarg = 'pk'  # 默认与lookup_field相同
    # 7. 指定需要过滤的字段
    filterset_fields = ['name', 'url']  # 查询字符串：path?name=user
    # 8. 指定分页引擎
    pagination_class = PageNumberPaginationManual
    # 9. 设置url中查询字符串页数条数key名
    page_size_query_param = "size"

    # 1. 可以使用action装饰器来声明自定义的动作
    # 默认情况下，实例方法名就是动作名
    # methods：用于指定动作支持的请求方法
    # detail：用于指定动作要处理的是否未详情资源对象(url中是否需要传递查询字符串)
    # url_path: path部分名字， 默认为方法名
    # url_name: 设置reserve的端口名， 默认为 类_方法名
    @action(methods=['get'], detail=False, url_path="nm", url_name='get_interfaces_name')
    def names(self, request, *args, **kwargs):
        queryset = self.get_queryset()
        queryset = self.filter_queryset(queryset)
        page = self.paginate_queryset(queryset)
        if page:
            serializer = InterfacesNameSerializer(instance=page, many=True)
            return self.get_paginated_response(serializer.data)
        serializer = InterfacesNameSerializer(instance=queryset, many=True)
        return Response(serializer.data)

    @action(methods=['get'], detail=True, url_path='get_api_id', url_name='get_interfaces_id')
    def project_get_interfaces(self, request, *args, **kwargs):
        queryset = Projects.objects.get(id=kwargs["pk"])
        serializer = InterfacesByProjectIdSerializer(instance=queryset)
        return Response(serializer.data)
```

#### 视图集注册路由

```python
from rest_framework import routers


# 方法二,自动注册路由
# 1. 创建simplerouter路由对象
router = routers.SimpleRouter()
# 2. 注册路由
# 第一个参数prefix为路由前缀, 第二个参数viewset为视图集
router.register(r'projects', views.InterfacesMiXinViewSets)

# 方法一(不推荐)
urlpatterns = [
    path('setview/', views.InterfacesViewSet.as_view({
        'get': 'list',
        'post': 'create',
    })),
    path('setview/<int:pk>/', views.InterfacesViewSet.as_view({
        'get': 'retrieve',
        'put': 'update',
        'delete': 'destroy'
    })),
    path('setview/names/', views.InterfacesMiXinViewSets.as_view({
        "get": "names"
    })),
    path('setview/<int:pk>/interfaces/', views.InterfacesMiXinViewSets.as_view({
        "get": "get_id"
    })),
    # 写入映射
    path('', include(router.urls))

]
# 方法三
urlpatterns += router.urls
```

以下为自动生成的url

```text
interfaces/ ^projects/$ [name='interfaces-list']
interfaces/ ^projects/nm/$ [name='interfaces-get_interfaces_name']
interfaces/ ^projects/(?P<pk>[^/.]+)/$ [name='interfaces-detail']
interfaces/ ^projects/(?P<pk>[^/.]+)/get_api_id/$ [name='interfaces-get_interfaces_id']
```

#### 14. status

```python
from rest_framework import status


Response(serializer.data, status=status.HTTP_200_OK)  # 通过常量展示更加明显
```

#### 生成接口文档

**简介**

1. 生成API文档平台
2. 自动生成测试代码
3. 支持接口测试

   **安装**

4. coreapi
5. pygments
6. markdown

**coreapi**

```python
# 1. 要在setting中注册
REST_FRAMEWORK = {
    'DEFAULT_SCHEMA_CLASS': 'rest_framework.schemas.coreapi.AutoSchema',  # 设置自定导出api文档
}
# 2. 在project的urls中
from rest_framework.documentation import include_docs_urls


urlpatterns = [
    path('docs/', include_docs_urls(title='XX接口文档', description='这个是个接口文档'))
]

# 3. 注释

class InterfacesMiXinViewSets(viewsets.ModelViewSet):
    """
    项目视图集
    project_get_interfaces:  # 具体方法注释
    通过项目ID获取该项目全部接口
    """

# 4. 数据模型中的help_text会显示在具体字段的description
```

**swagger文档\(推荐\)**

安装：`pip install drf-yasg`

```python
# 1. setting
INSTALLED_APPS = ['drf_yasg',]

# 2. project的urls中
from drf_yasg.views import get_schema_view
from drf_yasg import openapi

schema_view = get_schema_view(
    openapi.Info(
        title='测试平台接口文档',
        default_version='v1',
        description="详细信息",
        terms_of_service="服务器路径",
        contact=openapi.Contact(email="fungageis@gmail.com"),
        license=openapi.License(name="Test license")
    ),
    public=True,
    # permission_classes=(permissions.AllowAny)
)


urlpatterns = [
    re_path(r'^swagger(?P<format>\.json|\.yaml)$', schema_view.without_ui(cache_timeout=0), name='schema-json'),
    path('swagger/', schema_view.with_ui('swagger', cache_timeout=0), name='swagger-ui'),
    path('redoc/', schema_view.with_ui('redoc', cache_timeout=0), name='swagger-redoc'),
]
```

## 测试平台实践

* 架构模式
  * 前后端分离
* 前端架构
  * vue + elementui + vue router + axios
* 后端架构
  * Django + Django restframework + mysql + swagger
* 分析用到的技术点
* 选择哪种数据库
* 如何管理源代码
* 测试平台结构
  * 项目模块
  * 接口模块
  * 用例模块
  * 配置模块
  * 内置函数模块
  * 环境变量模块
  * 套件模块
  * 报告模块
  * 用户模块

### 准备工作

1. setting.py中 `ALLOWED_HOSTS = ["*"]` 允许任意地址访问，否则只能在本机访问
2. setting.py设置日志模块

   \`\`\`py

   **判断是否存在文件夹**

   log\_dir = os.path.join\(BASE\_DIR, os.path.join\("logs", time.strftime\("%Y-%m"\)\)\) if not os.path.exists\(log\_dir\): os.makedirs\(log\_dir\)

LOGGING = { 'version': 1, 'disable\_existing\_loggers': False, 'formatters': { 'simple': { 'format': '%\(asctime\)s - \[%\(levelname\)s\] - \[msg\]%\(message\)s' }, 'verbose': { 'format': '%\(asctime\)s - \[%\(levelname\)s\] - %\(name\)s - \[msg\]%\(message\)s - \[%\(filename\)s:%\(lineno\)d\]' }, }, 'filters': { 'require\_debug\_true': { '\(\)': 'django.utils.log.RequireDebugTrue', }, }, 'handlers': { 'console': { 'level': 'DEBUG', 'filters': \['require\_debug\_true'\], 'class': 'logging.StreamHandler', 'formatter': 'simple' }, 'file': { 'level': 'INFO', 'class': 'logging.handlers.RotatingFileHandler', 'filename': os.path.join\(BASE\_DIR, os.path.join\(log\_dir, f"{time.strftime\('%Y-%m-%d'\)}.log"\)\), \# 日志存放位置 'maxBytes': 100  _1024_  1024, \# 单个文件100m 'backupCount': 10, \# 最多10个文件 'formatter': 'verbose' }, }, 'loggers': { 'mytest': { \# 定义日志器 'handlers': \['console', 'file'\], 'propagate': True, \# 是否允许轮转 'level': 'DEBUG', } } }

```text
# 认证和鉴权
## 1. Browsable API页面认证
- 指定permission_classes
- 添加rest_framework.urls路由
```py
from rest-framework import permission


# 1. 在ApiView类中设置属性
permission_classes = [permissions.IsAuthenticated]  # 
# 2. 在setting.py中设置属性
REST_FRAMEWORK = {
    'DEFAULT_PERMISSION_CLASSES': ["rest_framework.permissions.IsAuthenticated"] 
}
```

### 2. Json Web Token认证

* 最常用的认证机制.
  * Session认证
  * Token认证
* Session认证
  * 保持在服务端，增加服务器开销
  * 分布式架构中，难以维持Session会话同步
  * CSRF攻击风险
* Token认证\(服务端只验不存\)
  * 保存在客户端
  * 跨语言、跨平台
  * 拓展性强
  * 鉴权性能高.

#### 推荐使用：djangorestframework-jwt

安装： `pip install djangorestframework-jwt` _drf自带原生token认证，但是不安全不建议使用 authtoken_

```python
# 初始化设置
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [  # 优先级
        'rest_framework_jwt.authentication.JSONWebTokenAuthentication',  # token认证
        'rest_framework.authentication.SessionAuthentication',  # 会话认证
        'rest_framework.authentication.BasicAuthentication',  # 基础认证
    ]
}
```

请求格式，token需在请求头中

```python
http://127.0.0.1:8001/interfaces/projects/

header = {"Authorization": "jwt eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFlZ2lzIiwiZXhwIjoxNTk3MzM3NjM0LCJlbWFpbCI6ImFlZ2lzQDEyMy5jb20ifQ.MH9xhMZ1pAWmK3fPnHqdHTeh9aP51yKN7hU-osRpjYg"}  # value中 'jwt + " " + token' key默认为Authorization
```

**自定义配置**

在`rest_framework-jwt.setting` 存放着相关配置参数

自定义时在工程`setting.py`文件中

```python
JWT_AUTH = {
    'JWT_EXPIRATION_DELTA': datetime.timedelta(days=1),  # 默认为5分钟
    'JWT_AUTH_HEADER_PREFIX': "xixi",  # 请求前缀
    'JWT_RESPONSE_PAYLOAD_HANDLER': 'utils.jwt_handler.jwt_response_payload_handler',  # 重写方法，返回更多
}
```

新建utils文件夹，jwt\_handler.py中

```python
# 重写rest_framework_jwt.utils.jwt_response_payload_handler方法
def jwt_response_payload_handler(token, user=None, request=None):
    return {
    'token': token,
    'user': user.id,
    'username': user.username
    }
```

**token结构**

```text
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFlZ2lzIiwiZXhwIjoxNTk3NDI2NjA3LCJlbWFpbCI6ImFlZ2lzQDEyMy5jb20ifQ.m_S_dNIXqi_BzpxJz3AOoej2keiVYhT55XPwfJ3wV2Q
```

jwt由三部分组成：header, playload, signature

* header
  * 声明类型
  * 声明signature的加密算法，默认为HS256
  * 采用base64加密，可以解密

    \`\`\`py

    import base64

print\(base64.b64decode\("eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9"\)\) Out\[2\]: b'{"typ":"JWT","alg":"HS256"}'

```text
- playload(载荷)
    - 存放过期时间、签发用户等
    - 可以添加用户的非敏感信息
    - base64加密，可以解密
```py
base64.urlsafe_b64decode("eyJ1c2VyX2lkIjoyLCJ1c2VybmFtZSI6ImFlZ2lzIiwiZXhwIjoxNTk3NDI2NjA3LCJlbWFpbCI6ImFlZ2lzQDEyMy5jb20ifQ==")  # 用=补足3的倍数
Out[8]: b'{"user_id":2,"username":"aegis","exp":1597426607,"email":"aegis@123.com"}'
```

* signature
  * 由三部分组成
  * 使用base64加密之后的header +.+ 使用base64加密之后的playload + 使用HS256算法加密，同时secret加盐处理

![](../.gitbook/assets/jwt结构.png) ![](../.gitbook/assets/认证流程.png)

**生成token**

```python
from rest_framework_wjt.settings import api_settings


jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER

payload = jwt_payload_handler(user)  # user为用户模型对象
token = jwt_encode_handler(payload)
```

#### 注册功能

接口文档

| 参数 | 输入/输出 | 说明 |
| :--- | :--- | :--- |
| 用户名 | 输入输出 | 6-20位，不能重复 |
| 密码 | 输入 | 6-20位，不能重复 |
| 确认密码 | 输入 | 6-20位，不能重复 |
| 邮箱 | 输入 | 符合邮箱格式 |
| token | 输出 |  |

```python
# serializer.py
from diango.contrib.auth.models import User
from rest_framwork import serializer
from rest_framwork.validators import UniqueValidator
from rest_framework_wjt.settings import api_settings


class RegisterSerializer(serializer.ModelSerializer):
    password_confirm = serializers.CharField(label="二次确认密码", help_text="二次确认密码",
                                             max_length=20, min_length=6, write_only=True,
                                             error_messages={"max_length": "密码应该小于等于20位字符",
                                                             "min_length": "密码应该大于等于6位字符"})

    token = serializers.CharField(label="令牌", read_only=True)

    class Meta:
        model = User
        fields = ("username", "password", "password_confirm", "email", "token")
        extra_kwargs = {
            "username": {
                "label": "用户名",
                "help_text": "用户名",
                "min_length": 6,
                "max_length": 20,
                "error_messages": {
                    "max_length": "用户名应该小于等于20位字符",
                    "min_length": "用户名应该大于等于6位字符"
                }
            },
            "password": {
                "label": "密码",
                "help_text": "密码",
                "write_only": True,
                "min_length": 6,
                "max_length": 20,
                "error_messages": {
                    "max_length": "密码应该小于等于20位字符",
                    "min_length": "密码应该大于等于6位字符"
                }
            },
            "email": {
                "label": "邮箱",
                "help_text": "邮箱",
                "required": True,
                "allow_blank": False,
                "validators": [UniqueValidator(queryset=User.objects.all(), message="email不能重复")]
            }
        }


    def validate(self, attrs):
    # 联合校验，判断两次密码是否一致
    if not attrs["password"] == attrs["password_confirm"]:
        raise serializers.ValidationError("两次密码不一致")
    return attrs

    def create(self, validated_data: dict):
        validated_data.pop("password_confirm")

        # 方法一：
        # user = super(RegisterSerializer, self).create(validated_data)
        # user.set_password(validated_data["password"])  # 不用该方法密码不会加密
        # user.save()

        # 方法二
        user = User.objects.create_user(**validated_data)

        jwt_payload_handler = api_settings.JWT_PAYLOAD_HANDLER
        jwt_encode_handler = api_settings.JWT_ENCODE_HANDLER

        payload = jwt_payload_handler(user)
        token = jwt_encode_handler(payload)

        user.token = token
        return user
```

#### 逻辑删除

继承ModelViewSet，重写perform\_destroy方法

```python
def perform_destroy(self, instance):
    instance.is_delete = True
    instance.save()
```

#### 跨域（cors）

**后端**

1. `pip install django-cors-headers`
2. 在setting.py中注册
3. ```python
    'corsheaders.middleware.CorsMiddleware',  # 要放在下方中间件之前
    'django.middleware.common.CommonMiddleware',  #
   ```
4. 添加白名单

   ```python
   # True位指定所有域名都可以访问后端接口
   CORS_ORIGIN_ALLOW_ALL = True
   # 指定访问后端接口的白名单
   # CORS_ORIGIN_WHITELIST = [
   #
   # ]
   # 允许跨域携带cookie
   CORS_ALLOW_CREDENTIALS = True
   ```

| 参数 | 说明 |
| :--- | :--- |
|  |  |
| 参数 | 说明 |
| - | - |
|  |  |
| 参数 | 说明 |
| - | - |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |
|  |  |

```python

```

### 注意事项

```python
# 视图类关闭csrf验证
# 需要在url中
from django.views.decorators.csrf import csrf_exempt


urlpatterns = [
    path('<int:pk>/', csrf_exempt(views.ProjectDetail.as_view()))
]


# 外键 onetoone manytomany 字段类型
# 第一个参数为关联的模型路径(可以采用字符串路径，也可以引入)
# 第二个参数设置的是，父表删除之后，该字段的处理方式。
# CASCADE 级联删除，子表也会删除
# SET_NULL 当前外键值会被设置为None
# PROJECT 报错
# SET_DEFAULT 设置默认值
```

