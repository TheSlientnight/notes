# 1. 简介
Django 本身基于 MVC 模型，即 Model（模型）+ View（视图）+ Controller（控制器）设计模式

MVC优势:
- 低耦合
- 开发快捷
- 部署方便
- 可重用性高
- 维护成本低

框架特点:
- 强大的数据库功能
- 自带强大的后台功能
- 优雅的路由

## MVC与MTV模型
在django中因为Controller绝大部分情况下由框架自动处理,不需要使用者做什么东西.所以又为MTV

MVC模型
- 模型（M）- 编写程序应有的功能，负责业务对象与数据库的映射(ORM)。
- 视图（V）- 图形界面，负责与用户的交互(页面)。
- 控制器（C）- 负责转发请求，对请求进行处理。

MTV模型
- M 表示模型（Model）：编写程序应有的功能，负责业务对象与数据库的映射(ORM)。
- T 表示模板 (Template)：负责如何把页面(html)展示给用户。
- V 表示视图（View）：负责业务逻辑，并在适当时候调用 Model和 Template。

# ORM 对象关系映射
使用 ORM 的好处：
- 提高开发效率。
- 不同数据库可以平滑切换。

使用 ORM 的缺点：
- ORM 代码转换为 SQL 语句时，需要花费一定的时间，执行效率会有所降低。
- 长期写 ORM 代码，会降低编写 SQL 语句的能力。

ORM 解析过程:
- ORM 会将 Python 代码转成为 SQL 语句。
- SQL 语句通过 pymysql 传送到数据库服务端。
- 在数据库中执行 SQL 语句并将结果返回。

![对应关系表](./image/ORM映射.png)

# 2. 基本使用
## 2.1 安装方法
1. 使用pip工具即可安装django: `pip install django`
2. 从github中下载
## 2.2 创建工程(project)
1. `django-admin startproject project_name`会在命令行所在目录生成project_name子目录
2. `django-admin startproject project_name .`会在命令行所在目录生成相关文件
### 2.2.2 默认生成工程目录
1. `setting.py`初始化配置,项目有关参数配置
2. `urls.py`url配置表(urlconf)
3. `wsgi.py`python服务网关标准
4. `asgi.py`异步网关(支持websocket, 3.X+新增特性)
## 2.3 启动工程
1. `python manage.py runserver` 会启动web服务器,具有django欢迎页面
## 2.4 生成应用(application)
1. `python manage.py startapp application_name` 生成blog文件应用
2. `django-admin startapp application_name` 与上个命令效果一样
### 2.4.2 默认生成blog应用目录
1. `admin.py`django管理工具
2. `apps.py`application名称
3. `migrations`存储应用的数据库表结构的指令
4. `models.py`数据模型
5. `tests.py`测试文档
6. `views.py`用户保存响应各种请求的函数或者类
7. `db.sqlite3`默认数据库
## 2,5 使用帮助
1. `django-admin` 或 `django-admin help` 可以看到一级命令的使用帮助
2. `django-admin help options_name` 可以看到二级命令options_name的使用帮助
## 2.6 `setting.py` 部分参数详解
1. `DEBUG = True` 是否开启调试模式
2. `ALLOWED_HOSTS` 指定服务的host和ports,默认为 127.0.0.1:8000
3. `INSTALLED_APPS` 允许使用的application
4. `DATABASES` 配置数据库
5. `TIME_ZONE` 设置时区,东八区(`Asia/Shanghai`)
## 2.7 进入`manage.py`交互模式
`python3 manage.py shell` 直接引入`manage.py`
## 2.8 django.auth
默认使用PBKDF2加密算法

# 3. 数据模型(ORM)
优点:

    1. 可移植性强,更改数据库只需要在setting.py中更改即可,无需更改代码
    2. 安全性好,框架已有诸如sql注入等攻击,无需在安全性上花太多时间
    3. 查询语法简单.
## 3.1 migrate
### 3.1.1 创建模型执行文件
`python3 manage.py makemigrations` 生成模型执行的初始化文件(xxxx_initial.py)

`python3 manage.py sqlmigrate blog xxxx` 查看初始化文件转化成原生sql语句(如下)

**django中通过ORM创建数据库表通用命名格式:"小写的application名" + "_" + "小写的类名", 例如blog_blogarticles**
```sql
BEGIN;
--
-- Create model BlogArticles
--
CREATE TABLE "blog_blogarticles" (
    "id" integer NOT NULL PRIMARY KEY AUTOINCREMENT, 
    "title" varchar(30) NOT NULL, 
    "body" text NOT NULL, 
    "publish" datetime NOT NULL, 
    "author_id" integer NOT NULL REFERENCES "auth_user" ("id") DEFERRABLE INITIALLY DEFERRED);
CREATE INDEX "blog_blogarticles_author_id_ed798e23" ON "blog_blogarticles" ("author_id");
COMMIT;
```
### 3.1.2 执行模型文件
`python3 manage.py migrate` 写入database中

## 3.2 语法
### 3.2.1 外键
`models.ForeignKey(User, related_name='blog_posts', on_delete=models.CASCADE)`

参数:
    
    1.User   外键关联类 
    2.related_name  关联类反向查询的属性名
    3.on_delete:关联删除,CASCADE:级联删除

**外键(一对多):一关联多,返回 查询集; 多关联一,返回 模型对象**
### 3.2.2 字段
    CharField: 用于保存字符串,一定要声明长度
    TextField: 理论上存储不限于长度
    EmailField、URLField: 继承于CharField,但各类型包含了验证它们值是否合规的方法
    FileField: 文件字段,接收上传文件并保存到服务器
    DateField、DateTimeField: 保存时间,可用default=timezone.now.或者 auto_now_add=True(推荐)自动保存时间
### 3.2.3 ManyToManyField 多对多
`users_like = models.ManyToManyField(User, related_name="articles_like", blank=True)`

设置该字段不会在表中创建该字段,会另外创建一张表
表中三个字段:ID、外键到设置表(设置该字段的表)的字段和外键到指定表(User)的字段
## 3.3 CURD
### 3.3.1 查询
```py
res = ORM_Class.objects.get(id=1)
```
查询不到时,弹错误页
```py
from django.shortcuts import reder, get_object_or_404
res = get_object_or_404(ORM_Class, id=1)
# 上下方法效果一致,上方更加简便
try:
    res = ORM_Class.objects.get(id=1) # 如果搜索为空会抛出DoesNotExist异常
except DoesNotExist:
    raise Http404()

```
## 3.4 一对一
```py
from django.db import models
from django.contrib.auth.models import User


class UserProfile(models.Model):
    user = models.OneToOneField(User, on_delete=models.CASCADE, unique=True)
    # on_delete删除模式,CASCADE联级删除,unique字段是否唯一
    birth = models.DateField(blank=True, null=True)  # blank前端是否必填 null字段是否为空
    phone = models.CharField(max_length=20, null=True)

    def __str__(self):
        return 'user {}'.format(self.user.username)
```
## 3.5 继承
###  抽象模型继承
当实施数据迁移时,数据库不会创建抽象类
```py
from django.db import models 


class BaseModel(models.Model):
    name = model.ForeignKey(User, on_delete=models.CASCADE, related_name='%(app_label)s_%(class)s_related')  # 动态设置相关名字,避免子类冲突
    age = model.IntegerField()

    class Meta:
        abstract = True
        ordering = ['age']


class Programmer(BaseModel):
    lang = model.CharField(max_length=200)
```
### 多表继承
两个类都会创建数据库表
```py
from django.db import models


class Place(models.Model):
    name = models.CharField(max_length=300)

class address(models.Model):
    address = models.CharField(max_length=200)
```
### 代理模式
在内部类Meta中声明proxy=True,子类通过自定义的方法或者重写内部类Meta的方式,改变模型行为
```py
from django.db import models


class Student(models.Model):
    name = CharField(max_length=300)
    age = IntegerField()

class Teacher(Student):
    class Meta:
        proxy = True
        ordering = ['age']

    def teacher_age(self):
        return self.age + 17


```
## 3.6 存储文件
```py
def user_directory_path(instance, filename):  # ①接收模型实例 ②接收文件名
    return f"courses/user_{instance.user.id}/{filename}"

class Lesson(models.Model):
    video = models.FileField(upload_to=user_directory_path)
    attch = models.FIleField(upload_to=user_directory_path)


```
# 4. 创建用户
## 4.1 创建管理员
`python3 manage.py createsuperuser` 创建管理员

http://127.0.0.1:8000/admin/ 访问管理页面

# 5. 模板
## 5.1 模板语法
### 5.1.1 块标签%变量标签
```django
<!-- 块标签 -->
 {% block name %}
    ...content...
 {% endblock %}

 <!-- 变量标签 -->
 {{ name }}


 <!-- 赋值操作 -->
 {% with total_like=article.users_like.count %}
 {% endwith %}
```
### 5.1.2 静态资源
```django
<!-- {% load staticfiles %} django3.0已经弃用 -->
{% load static %}
<!-- 引入静态资源 -->

{% static '/images/logo.png' %}
<!-- 动态获取静态资源路径 -->
```
### 5.1.3 超链接
```django
{% url 'blog:blog_title' %}
<!-- blog应用中的blog_title视图的路由 -->
```

### 5.1.2 继承
```django
{% extends "base.html" %}
```
继承后可重写父模板的块标签重写

### 5.1.3 for循环
render模板时将参数一并传入
```django
{% for blog in blogs %}
    {{ blog.title }}  <!-- 引用变量 -->
{% empty %}
    可选项,当blogs为空时触发
{% endfor %}

<!-- 只能有用在for中,从1开始计数 -->
{{ forloop.counter }}
<!-- 从0开始计数 -->
{{ forloop.counter0 }}
```
### 5.1.4 if判断
```django
{% if condition %}
    do...something
{% endif %}

{% if condition %}
    do...something
{% else %}
    do...something
{% endif %}
```
### 5.1.5 登录状态
```django
{% user.authenticated %}
<!-- 返回用户登录状态,已登录为True -->

```
## 获取路由
```django
{% url 'blog:blog_article' %}
<!-- 获取路由, blog:为blog应用, blog_article:为blog_article端点路由(后端详情可见命名路由) -->
```
## 5.2 模板路径
**在`setting.py`文件中**

1. `TEMPLATES`的`APP_DIRS`:引擎是否在子应用程序（的目录）内查找模板源文件。
2. `TEMPLATES`的`'DIRS': [os.path.join(BASE_DIR, 'templates'), ]`: 如果需要采用在根目录内统一管理模板文件,则需要指定模板目录列表,否则为空列表
3. `STATIC_URL = '/static/'`:访问静态资源的path
4. `STATICFILES_DIRS = (os.path.join(BASE_DIR, "static"), )`: 静态资源文件夹
5. `STATICFILES_FINDERS`静态资源查找策略,隐私变量,在`setting.py`中没有展示
```py
STATICFILES_FINDERS = [
    'django.contrib.staticfiles.finders.FileSystemFinder',  # 查找存储在STATICFILES_DIRS设置中的文件
    'django.contrib.staticfiles.finders.AppDirectoriesFinder',  # 每个应用程序的子目录中static
]
```

# 6. 路由
## 6.1 工程路由
```py
# 在工程目录下的urls.py中
from django.contrib import admin
from django.urls import path, include


urlpatterns = [
    path('admin/', admin.site.urls),  # 第一个参数是path, 第二参数是视图函数
    path('blog/', include('blog.urls')),  #　include 将指定path的路由都转到指定应用的路由管理
]
```
## 6.2 子应用路由
```py
# 在各application目录下创建urls.py文件
from django.urls import path
from django.contrib.auth import views as auth_views
from . import views


urlpatterns = [
    path('', view.blog_title),  # 第一个参数是path(空则为根), 第二参数是视图函数
    path('<int:article_id>', view.blog_article),  # 应用根后面的数字会当成参数传入
    path('login', auth.views.LoginView.as_view(template_name='account/login.html'), name='user_login')  # 使用内置的登录视图,登录后redirect默认为profile.此处需要在setting.py中修改
    path('logout/', auth_views.LogoutView.as_view(template_name='account/logout.html'), name='user_logout'),  # 内置的退出视图
]
```
### 6.2.2 命名路由
1. 方法一(推荐):直接在项目urls上传参app_name,在多应用下更方便管理
2. 方法二:在子应用中设置app_name变量

`project的urls.py`
```py
from django.urls import path, include


urlpatterns = [
    path("blog", include(('blog.urls', 'blog'), namespace='blog')),  # 方法一
    path("admin", include('admin.urls', namespace='admin'))  # 方法二
]
```
`app的urls.py`
```py
from django.urls import path
from . import views


app_name = 'admin'  # 方法二
urlpatterns = [
    path('', views.blog_article, name='blog_article')
]
```
### 6.2.3 路由重定向redirect
```py
LOGIN_REDIRECT_URL = '/blog/'  # 指定内置登录模块登录成功后redirect到正页
```
### 6.2.4 内置修改密码模块
```py
path('password_reset', auth_views.PasswordResetView.as_view(
    template_name='account/password_reset_form.html',
    email_template_name='account/password_reset_email.html',  # email_template_name发送的邮件模板
    success_url='/account/password_reset_done/')  # success_url如果成功跳转的地址
```
`setting.py`
```py
# email配置
EMAIL_HOST = 'smtp.163.com'
EMAIL_HOST_USER = ''
EMAIL_HOST_PASSWORD = ''
EMAIL_PORT = 25
EMAIL_USE_TLS = True
DEFAULT_FROM_EMAIL = ''
```
# 7. 表单
## 表单类
```py
from django import form


class LoginForm(form.Form):
    username = form.CharField()
    password = form.CharField(widget=forms.PasswordInput)


login_1 = LoginForm()  # 未向类传参,称为:未绑定实例
print(login_1.is_bound)  # False 未绑定实例则返回False
print(login_1)  # 生成如下HTML代码
"""
<tr><th><label for="id_username">Username:</label></th><td><input type="text" name="username" required id="id_username"></td></tr>
<tr><th><label for="id_password">Password:</label></th><td><input type="password" name="password" required id="id_password"></td></tr>
"""

account = {"username": "admin", "password": "qazwsxedc"}
login_2 = LoginForm(account)
print(login_2.is_bound)  # 已绑定实例则返回 True
print(login_2.is_valid())  # True ; 判断入参数据是否合法

# 只有实例使用过is_valid()这个方法才可以使用下面的方法
print(login_2.cleaned_data)  # {"username": "admin", "password": "qazwsxedc"}
# 以字典形式返回合法入参,若某项入参不合法则不显示
```
## 表单模板
```django
<form class="form-horizontal" action="." method="post">
    {% csrf_token %}
    <!-- post请求需要携带csrf,否则报错 -->
    {{ form.as_p }}
    <!-- 每个表单项都用<p>标签包围(会换行) -->
    {{ form.as_table }}
    <!-- 不做任何包围(不会换行) -->
    {{ form.as_ul }}
    <!-- 每个表单项都被用<li>标签包围(会换行,带·) -->

    <label for="{{ form.username.id_for_label }}"></label>
    <!-- 关联label和input -->
    <div>{{ form.username }}</div>
    <!-- form.表单项 可以提出单项表单 -->

    <input type="submit" value="Login" class="btn btn-primary btn-lg">
</form>
```
## 表单模型类
```py
from django import form
from django.contrib.auth.models import User
from .models import UserProfile


class RegistrationForm(form.ModelForm):
    password = forms.CharField(label="Password", widget=forms.PasswordInput)
    password2 = forms.CharField(label="Confirm Password", widget=forms.PasswordInput)

    class Meta:
        model = User  # 指定数据模型
        fields = ("username", "email")  # 指定需要显示为表单的字段
        # exclude = ('',)  # 排除元组中的字段外都需要显示为表单

    def clean_password(self):  # 以'clean_ + 名称'的方法都会在调用表单实例对象的is_valid()函数时被执行
        cd = self.cleaned_data
        if cd['password'] != cd['password2']:
            raise forms.ValidationError("password do not match")
        return cd['password']


class UserProfileForm(form.ModelForm):
    class Meta:
        model = UserProfile
        fields = ("phone", "birth")
```

# 视图
## HttpResponse
```py
from django.http import HttpResponse

def login(request):
    dic = {
            "username": "admin",
            "password": "qazwsx"
        }
        res = json.dumps(dic)
    HttpResponse(content=res, content_type="application/json", status=200)  # 使用该函数，需要将返回文本处理成byte类型
    # ------------------------------
    h = HttpResponse
    h.write("")  # 支持如写文件一样写入
    return h
```
## 关联数据模型
```py
from .forms import RegistrationForm, UserProfileForm

def register(request):
    if request.method == "POST":
        register_form = RegistrationForm(request.POST)
        profile_form = UserProfileForm(request.POST)
        if register_form.is_vaild() * profile_form.vaild():  # 相当于and True*False → 0
            new_form = register_form.save(commit=False)  # 将表单数据存到数据库,并生成该数据对象.如果commit=False的话,仅生成数据对象
            new_form.set_password(register_form.cleaned_data['password'])  # User的内置函数,加盐加密后保存
            new_form.save()  # 默认为True
            new_profile = profile_form.save(commit=False)
            new_profile.user = new_form  # 关联两个数据模型
            new_profile.save()
            return HttpResponse("successfully")
        else:
            return HttpResponse("Sorry Invaild")
    elif request.method == "GET":
        register_form = RegistrationForm()
        profile_form = UserProfileForm()
        return render(request, "account/register.html", {"form":register_form, "profile": profile_form})
```
# 类视图
```py
from django.views.generic import TemplateView, ListView
from .models import Course


class CourseListView(ListView):
    model = Course  # 相当于Course.object.all()
    context_object_name = "courses"  # 结果集在模板中的变量名
    template_name = 'course/course_list.html"



```