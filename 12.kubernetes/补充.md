https://testerhome.com/articles/17752

- Pod是一个逻辑概念,是一组共享了某些资源的容器
- Pod 里的所有容器，共享的是同一个Network Namespace，并且可以声明共享同一个Volume
- POD是k8s调度的最小逻辑单位，一个POD中的所有容器都必须被调度到同一台机器上

## 网络模式

![](./images/pause.png)

infra container，它也叫做pause容器，也被称为sandbox,这个沙箱为其他容器提供共享的网络和文件挂载资源.它的逻辑跟docker中container网络模式的逻辑一样.当这个容器被创建出来并hold住Network Namespace之后，其他由用户自己定义的容器就可以通过container模式加入到这个容器的Network Namespace中,这也就意味着，对于在一个POD中的容器A和容器B来说，他们拥有相同的IP地址，可以通过localhost进行互相通信

## sidecar模式

在宿主机上开辟出一个空目录，然后把这个目录地址挂载到pod中的各个容器中就可以了。 而在k8s为POD做的声明式API中，专门有一个empty dir的volume类型。 就是专门在POD中开辟一个临时的可共享的空目录。这样在一个POD中的多个容器就可以通过这个目录进行文件的共享。 一个典型的例子就是日志收集。 在我们的产品之前的部署方式中，就是使用这种方式来做日志收集的。 在一个pod中启动一个服务容器，然后再启动一个filebeat容器，这两个容器通过这个 empty dir 共享了日志的目录。 服务容器把日志写到这个目录中， filebeat容器就可以同步的收集这些日志并发送到ES中

sidecar 指的就是我们可以在一个 Pod 中，启动一个辅助容器，来完成一些独立于主进程（主容器）之外的工作。 同时我们有时候也会叫它伴生容器，因为往往它与主容器伴生伴死。 这种sidecar模式有一个缺点就是由于这种伴生伴死的特性来的。 如果辅助容器出现了以外，比如oom，或者用来做健康检查的探针探测失败。 在POD层面都会触发重启，那么在重启结束前会导致主容器的不可用


```yaml
apivers ion : v1
kind : Pod
metadata: 
  	name: javaweb-2
spec:
	initContainers:
	-	image: geektime/sample:v2
    	name: war
        command: ["cp", "/sample.war", " / app"]
		volumeMounts:
		- mountPath: /app
		   name: app-volume
	containers:
	-	image: geektime/tomcat:7.0
		name : tomcat
        command: ["sh", "-C", "/root/apache-tomcat-7.0.42-v2/bin/start.sh"]
		volumeMounts:
		- mountPath: /root/apache-tomcat-7.0.42-v2/webapps
		name: app-volume
		ports:
		- containerPort: 8080
			hostPort : 8001
	volumes
    -   name: app-volume
		    emptyDir: {}
```

## label

`kubectl label nodes qa-test001 env=test`

部署POD的时候selector会部署在含有指定label的node