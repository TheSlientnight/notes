# 使用背景
在我们编写用例的过程中,因为被测程序往往都需要鉴权.在有些方便创建账号的地方我们可以,每个用例或者每个class级别都去创建账号.但在不能随便创建账号的场景下,这样就给用例运行带来了麻烦

特别是在我们使用[api-automatic-framework](https://github.com/fungaegis/api-automatic-framework) 测试框架的时候,因为该框架支持基于自定义的分组并发,所以往往每个分组都需要进行鉴权,针对这个现象,我思考了几种解决方案

# 解决方案
## 1.方案一
每个分组的鉴权,都提供独立的账号

## 2.方案二
class前置时去数据库拿相关的token

## 3.方案三
使用pytest-xdist提供的解决方案

注意: worker_id 如果是分布式运行的 管理端会是master

如果仅是单机并发运行,worker会是`gw0`,`gw1`等
```py
from filelock import FileLock


@pytest.fixture(scope="session", autouse=True)
def c_login_fixture(tmp_path_factory, worker_id):
    """执行用例前登录获取token"""
    if worker_id == "master":
        #如果是单线程执行，会走这里的逻辑
        user_account = os.environ["user_account"]
        password = os.environ["password"]
        res = login(user_account, password).json()
        #将token加入到环境变量中，测试用例可以直接从环境变量中取
        token = res["result"]["token"]
        os.environ["token"] = token
        return

    root_tmp_dir = tmp_path_factory.getbasetemp().parent

    fn = root_tmp_dir / "data.json"
    with FileLock(str(fn) + ".lock"):
        if fn.is_file():
            # 从缓存文件中读取token
            token = json.loads(fn.read_text())
            os.environ["token"] = token
        else:
            ## 登录后获取token，写入到缓存文件中
            user_account = os.environ["user_account"]
            password = os.environ["password"]
            res = login(user_account, password).json()

            token = res["result"]["token"]
            fn.write_text(json.dumps(token))
            os.environ["token"] = token
    return
```

## 4.方案四
鉴于方案三的弊端,在单机模式下,由gw0进程进行鉴权,将拿到的鉴权放在系统变量,其他进程则不断的轮询等待,直至拿到数据为止


```py
def get_token(worker_id):
    if worker_id == "gw0":
        token = login()
        os.environ["token"] = token
        return token
    while True:
        token = os.environ.get("token", None)
        return token
```
