# vue.js
本文章vue3.x作为记录对象
## 1. 简介

- 前端三大主流框架之一
    - Angular.js、React.js、Vue.js
- 简单小巧
    - 使用gzip压缩之后，只有20kb左右
    - 入门容易
- 自动进行响应式更新
    - 只需关注前端业务逻辑，无需操作DOM高级特性
    - 解耦视图与数据
    - 可复用组件
    - 前端路由
    - 状态管理
    - 虚拟DOM

Vue.js文档: https://cn.vuejs.org/v2/guide/index.html

### 1.1 MVVM模式
1. 常见架构
- java常采用MVC架构           模型(model)－视图(view)－控制器(controller)
- flask和django采用MVT架构    模型(model)－视图(view)－模板(templates)
- vue.js采用MVVM模式          模型(model)－ViewModel(视图模型)－视图(view) 

2. MVVM模式
- M:模型
    - 从后端获取的数据
- V:视图模板
    - 模板展示
- VM:视图模型
    - 核心控制

### 1.2 组件化

- 模块化
    - 以不同的组件，来划分不同的功能模块
- 复用
- 高效
- 解耦
## 2. 安装

### 2.1 准备环境

- 安装Node.js
    - node官方下载地址: https://nodejs.org/en/download/
    - `node -v` 查看node版本,验证是否安装成功
    - `npm -v` 查看npm版本,验证是否安装成功
    - `cnpm i -g n` 升级node.js
    - `n stable` 选择为稳定版
- 使用淘宝npm镜像源
    - `npm install -g cnpm --registry=https://registry.npm.taobao.org`
### 2.2 安装vue-cli脚手架

- 使用npm
    - `npm install -g @vue/cli`
- 使用淘宝npm镜像源
    - `cnpm install -g @vue/cli`

**tips: 需在要local安装`cnpm i node-saas`**

- `npm install module_name -S`    即    `npm install module_name --save`    写入dependencies
- `npm install module_name -D`    即    `npm install module_name --save-dev` 写入devDependencies
- `npm install module_name -g` 全局安装(命令行使用)
- `npm install module_name` 本地安装(将安装包放在 ./node_modules 下)
### 2.3 创建工程项目(脚手架)

`vue create project_name`

### 2.4 vscode插件

- vutur: 语法高亮、智能感知、Emmet等
- EsLint: 语法纠错
- view in browser: 右键可在浏览器运行html文件
- Auto Close Tag: 自动闭合HTML/XML标签
- Auto Rename Tag: 自动完成另一侧修改
- JavaScript(ES6) code snippets: ES6语法提示&快速输入
- Path Intellisense: 路径补全
- HTML CSS Support: 提示样式
- vue vscode snippets: 快捷键
    例如:
    - vbase:自动生成模板
    - vdata: 自动生成data对象
    - vmethod: 自动生成method对象等

### 2.5 webpack
是前端压缩打包的工具
## 3. 基础

简单vue示例

当这些数据改变时,视图会进行重渲染.需要注意的是只有当实例被创建时已经存在的property才是响应式的

如果需要添加一个新的property将不会有任何更新.

所以如果预期会需要一个property,但是一开始它为空或不存在,那么需要设置一些初始值
```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <title>DEMO</title>
        <script src="https://unpkg.com/vue@next"></script>
    </head>
    <body>
        <!-- MVVM模式中的视图  -->
        <div id="app"></div>
        <script>
            // 创建实例
            const app = Vue.createApp({ // 创建实例的对象
                data(){ return {  // M 数据层
                    msg: "hello world"
                    }},
                template: `<div>{{msg}}</div>` // V 模板层
            })
            // 根组件
            const vm = app.mount("#app")  // VM 视图数据链接层
            console.log(vm.$data) // 从根组件对象中可以获取所有的数据层 {msg: "hello world"}
        </script>
    </body>
    
</html>
```

### 3.1 UI组件库
https://zhuanlan.zhihu.com/p/61403630
#### 3.1.1 elementUI
https://element.eleme.cn/#/zh-CN/component/installation
- 安装 `cnpm i element-ui -S`
- 导入
```js
import Vue from 'vue';
// elementUI
import ElementUI from 'element-ui';
import 'element-ui/lib/theme-chalk/index.css';

import App from './App.vue';

// 使用
Vue.use(ElementUI);
```

### 3.2 插值表达式
`{{ 变量名 }}` 在"Mustache"语法 (双大括号) 中填写变量名即可

`<div>{{ msg }}</div>`


[代码示例](./practice/demo4.html)
#### v-once

如果使用了`v-once`指令,将只进行一次插值,之后数据改变将不会更新

`<div v-once>{{ msg }}</div>`

#### v-html
双大括号会将数据解释为普通文本，而非 HTML 代码。为了输出真正的 HTML

用v-html 指令, 可以支持解析html
```html
<span v-html="html"> Using v-html directive </span>

<script>
export default {
    data(){
        return {
            html: "<span style="color: red">This should be red.</span>"
        }
    }
}
</script>
```

#### v-bind
如果需要使用html的attribute,需要使用`v-bind`指令

如果绑定的值是 null 或 undefined，那么该 attribute 将不会被包含在渲染的元素上

```html
<!-- 完整语法 -->
<a v-bind:href="url">...</a>

<!-- 缩写 -->
<a :href="url">...</a>

<!-- 动态参数的缩写 (2.6.0+) -->
<a :[key]="url"> ... </a>

```
```html
<!-- 动态参数 -->
<button :isButtonDisabled="isButtonDisabled" :class="isButtonDisabled===true?'one':'two'">按钮</button>

<script>
export default {
    data(){
        isButtonDisabled: true
    },
    methods: {
        updateValue(){
            this.isButtonDisabled = this.isButtonDisabled === true?false:true
        }
    }
}
</script>
<style>
    .one{color: red}
    .two{color: green}
</style>
```
#### javascript表达式
每个绑定都只能包含单个表达式

模板表达式都被放在沙盒中，只能访问全局变量的一个白名单，如 Math 和 Date 。
```js
{{ number + 1 }}
{{ ok ? 'yes' : 'no' }}
{{ msg.split('').reverse().join('') }}
```
### 3.3 v-if & v-show
`v-if`更加灵活，可以增加多个判断，比如`v-else-if`和`else`，而`v-show`不具备这样的灵活性。

`v-if`
- `v-if` 是"真正"的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建。
- `v-if` 也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。

`v-show`
- `v-show`始终会被渲染, 只是控制DOM元素显示，其实控制的是css样式，也就是`display:none`

一般来说，`v-if`有更高的切换开销，而 `v-show` 有更高的初始渲染开销。
- 因此,如果需要非常频繁地切换，则使用 `v-show` 较好；
- 如果在运行时条件很少改变，则使用 `v-if` 较好。

[代码示例](./practice/demo7.html)

```html
<template>
  <!-- {{}}：插值表达式 -->
  <div class="wrapper">{{msg}}
      <!-- v-if：如果为true则显示，反之则不显示 -->
      <p v-if="isShow">{{xixi}}</p>
      年龄<input v-model="age">
      年龄：{{age}}
      <br>
      <p v-if="age >= 18">年龄大于18岁，已成年</p>
      <p v-else-if="0 < age && age < 18">年龄小于18岁，未成年</p>
      <p v-else>请输入年龄</p>
      <br>
      <p v-show="isShow">sadasdsadsa</p>
  </div>
  
</template>


<script>
export default {
  components:{},
  props:{
      xixi : String // 相当于形参
      },
  name: "learn_1",
  data(){
    return {
        msg : "hahahhahahaha",
        haha : "dxixixiix",
        isShow: true, //
        isShow2: false,
        age : ""
    }
  }
}
</script>
<style lang="scss" scoped>
</style>
```
- v-if:每次都会重新删除或者创建元素，少量操作时使用，较高的切换开销
- v-show:通过`style="display:none;"`将元素隐藏；在有频繁的显示/隐藏操作时使用，较高的渲染开销

### 3.4 v-for
[代码示例](./practice/demo8.html)

在`v-for`块中，可以访问所有父作用域的`property`, 每次使用`v-for`时都需要绑定一个唯一性`key`值.

唯一性`key`值的作用:
- 为了提高循环时性能，在数组其中一项变化后，整个数组不进行全部重新渲染，Vue提供了绑定key值的使用方法，目的就是增加渲染性能，避免重复渲染。
- 不推荐使用`index`, 如果有多个对象需要遍历时,索引不唯一

遍历对象:
- 第一个值: value
- 第二个值: key
- 第三个值: 索引

遍历数组:
- 第一个值: value
- 第二个值: 索引

```js
const app = Vue.createApp({
    data(){
        return {
            objectData: {
                A: 1,
                B: 2,
                C: 3
            },
            arrayData: ["G", "F", "Y"]
        }
    },
    template: `
        <div>
            <p v-for="(value, key, index) in objectData"> 我是对象: [{{ index }}] {{ key }}: {{ value }}</p>
            <p v-for="(item, index) of arrayData">我是数组: [{{ index }}] {{ item }}</p>
        </div>
    `
})
const vm = app.mount("#app")
```
#### 循环数字
数字是从1开始
```html
<span v-for="count in 10"> {{count}} </span>
```

#### 3.4.2 v-if & v-for
当 `v-if` 与 `v-for` 处于同一节点，`v-for` 具有比 `v-if` 更高的优先级。所以 `v-if` 不会生效

此时需要使用`<template></template>`虚拟标签,做一层嵌套,将`v-if`和`v-for`分开.该标签不会显示在实际的dom中
```js
        const app = Vue.createApp({
            data(){
                return {
                    objectData: {
                        A: 1,
                        B: 2,
                        C: 3
                    },
                    arrayData: ["G", "F", "Y"]
                }
            },
            template: `
                <div>
                    <div>
                        <p> for循环嵌套if, 只显示B</p>
                        <ul>
                            <template v-for="(value, key, index) in objectData">
                            <li v-if="key === 'B'">[{{index}}]-{{ value }}</li>
                            </template>
                        </ul>
                    </div>
                </div>
            `
        })
        const vm = app.mount("#app")
```


### 3.5 v-on 绑定事件
vue中的事件名相对于js 只是少了 `on`

如: `onclick` -> `click`

```html
<!-- 完整语法 -->
<a v-on:click="doSomething">...</a>

<!-- 缩写 -->
<a @click="doSomething">...</a>

<!-- 动态参数的缩写 (2.6.0+) -->
<!-- 可以直接使用data()对象中的数据,也可以在里面使用js表达式 -->
<a @[event]="doSomething"> ... </a>
```
```html
<p v-on:click="title='xixixixi'">{{title}}</p>
<p @click="title='xixixixi'">{{title}}</p>
<!-- v-on 缩写@ -->
```

```html
<div id="app"></div>
<script>
    Vue.createApp({
        data(){
            return{
                event1 = "click"
            },
        methods: {
            popup(){
                alert("动态参数")
            }
        },
        template: "<div :[event1]="popup"></div>"
        }
    }).mount("#app")
</script>
```

#### 修饰符
##### prevent
阻止默认行为

方法一: 推荐使用
```js
Vue.createApp({
    methods: {
        popup(){
            alert("提交拉")
        }
    },
    template: `
        <form @click.prevent="popup">
        <button type="submit">submit</button>
        </form>
    `

}).mount("#app")
```
方法二: 繁琐不方便
```js
Vue.createApp({
    methods: {
        popup(e){
            e.preventDefault()
            alert("提交拉")
        }
    },
    template: `
        <form @click="popup">
        <button type="submit">submit</button>
        </form>
    `

}).mount("#app")
```

### 3.6 v-model 数据双向绑定
- v-model 双向绑定,既可以将model中的数据传给输入框的value,也可以将value的数据传给model
- 只能在input、textarea、select元素上使用
- `textarea`等原需要两个标签, 在vue3中可以`<textarea v-model="inputValue" />`仅用一个标签
- 多选框绑定数组可以支持自由添加删减
- 单选框绑定字符串,可实现唯一
- 在使用多选框(checkbox)时,可以使用`true-value`和`false-value`的值做传参

[代码示例](./practice/demo11.html)

```html
<div>
    双向数据绑定{{ inputValue }}
    <input v-model="inputValue" />
    <textarea v-model="inputValue" />
    <hr>
    <div>
        <!-- 初始化时显示的为value中的值 之后会根据状态显示值 -->
        <p>通过选中与未选中判断展示内容:</p> [{{ value }}]
        <input type="checkbox" v-model="value" true-value="勾选我啦" false-value="还没勾选我吗?">
        <hr>
        <p>多选框 {{arrayData}}</p>
        A<input type="checkbox" v-model="arrayData" value="A" />
        B<input type="checkbox" v-model="arrayData" value="B" />
        C<input type="checkbox" v-model="arrayData" value="C" />
    </div>
        
    <div>
        <p>单选框 {{Data}}</p>
        G<input type="radio" v-model="Data" value="G" />
        F<input type="radio" v-model="Data" value="F" />
        H<input type="radio" v-model="Data" value="H" />
    </div>
</div>
```
#### 修饰符
- lazy: 当输入完成后，输入框失去焦点再进行改变
- trim: 消除input框输入内容前后的空格
- number: 字符类型改为数字, 只有首位字符为数字时才会为数字类型,且之后如果输入字符串类型,将不会传入

```html
<div>
    修饰符 lazy trim number
    <p>懒加载: {{lazyData}}</p>
    <input v-model.lazy="lazyData">
    <p>数字类型: {{typeof numberData}}- 值:{{ numberData }}</p>
    <input v-model.number="numberData">
    <p>去除前后端空格: {{trimData}}</p>
    <input v-model.trim="trimData">
</div>
```                    




#### 3.6.2 修饰符
默认情况下，v-model 在每次 input 事件触发后将输入框的值与数据进行同步
```html
<!-- .lazy转为在 change 事件_之后_进行同步  -->
<input v-model.lazy="age">

<!-- .number自动将用户的输入值转为数值类型 -->
<!-- 如果这个值无法被 parseFloat() 解析，则会返回原始的值。 -->
<input v-model.number="age" type="number">

<!-- .trim过滤用户输入的首尾空白字符 -->
<input v-model.trim="msg">
```

### 3.9 vue实例生命周期
![vue的生命周期](./image/lifecycle.svg)


#### 3.9.1 生命周期钩子
生命周期在某一时刻执行的函数
- `beforeCreate`: 在实例生成之前会自动执行函数
- `created`：在实例生成之后会自动执行函数
- `beforeMount`: 在模板渲染完成之前执行的函数
- `mounted`：实例挂载到DOM树之后(渲染完成后执行)
- `beforeUpdate`: 在data变化之前会立即运行函数
- `Updated`: 在data变化之后会立即运行函数
- `beforeUnmount`: 在取消挂载之前运行函数, 通过`app.unmount()`将实例销毁可以看到实例
- `unmounted`: 在取消挂载之后运行函数

[生命周期代码示例](./practice/demo3.html)
### 3.10 计算属性&侦听器&方法
- computed 和 method都能实现的功能，建议使用computed,因为有缓存，不用渲染页面就刷新。
- computed 和 watch 都能实现的功能，建议使用 computed，因为更加简洁。


[计算属性&侦听器 - 代码示例](./practice/demo5.html)
#### 3.10.2 计算属性&方法
- 计算属性的特性,当计算属性依赖的内容发生变化时,才会重新计算
    - 这就意味着只要 依赖内容 还没有发生改变，多次访问计算属性会立即返回之前的计算结果，而不必再次执行函数。比方法更加小的性能开销
- 方法在每次页面渲染的时候都会进行计算
- 在插值表达式中使用的时候,计算属性不需要加括号调用,方法内的需要加括号调用

#### 3.10.3 计算属性&侦听器
计算属性computed必须要返回一个值，而且在页面渲染的同时就会执行里边的业务逻辑，也就是会先执行一遍你写的业务逻辑，而watch只有发生变化时才会执行，也就是说值没有变化，它是不执行里边业务逻辑的

侦听器对象内,以需要侦听的数据作为方法名,会得到两个传参
- 第一个: 当前变化的值
- 第二个: 变化前的值

```js
const app = Vue.createApp({
    data(){
        return {
            price: 20,
            rise: 0,
            history: 0
        }
    },
    watch:{
        price(current, prev){
            console.log("当前变化的值", current);
            console.log("变化前的值", prev);
            this.rise = current - prev;
            this.history += this.rise;
        }

    }
}
)
```

### 3.11 方法
[代码示例](./practice/demo9.html)

- `v-on`指定的函数,如果仅一个函数且没有形参,则无需加`()`括号.
- 如果仅一个函数且只有一个形参,在指定时未使用`()`进行传参,则某人传入`event`对象
- 如果在`v-on`指定函数时仅一个函数且只有一个形参,有传参则按传参传入
- 如果函数有多个形参,则使用`$event`当作实参可传入`event`对象
- 一个事件指定多个函数,必须添加括号`()`, 函数间用逗号`,`隔开

```js
const app = Vue.createApp({
    data(){
        return {
            count : 1
        }
    },
    methods: {
        // 未指定传参则默认传入event对象
        addData(event){
            console.log(event);
            console.log(event.target);
        },
        // 如果要传入event对象,在调用时`$event`
        paramFunc(num, event){
            this.count += num;
            console.log(event.target);
        },
        // 多函数必须都要加括号
        multipleFunc(){
            alert("multiple function");
        }
    },
    template: `
        <div>
            <p>{{ count }}</p>
            <button @click="addData">默认传入事件</button>
            <button @click="paramFunc(5, $event)">带参传入</button>
            <button @click="paramFunc(3, $event), multipleFunc()">多事件</button>
        </div>
    `
})
const vm = app.mount("#app")
```
### 3.12 修饰符

[示例代码](./practice/demo10.html)
#### 事件修饰符
默认触发事件时,从内向外不断冒泡运行

- prevent: 阻止默认事件
- stop: 停止向上冒泡(从下向上)
- capture: 从顶向下
- self: 只有自己被点击才执行
- once: 只运行一次
- passive: 解决滚动时性能的修饰符

#### 键盘修饰符

- enter
- tab
- delete
- esc
- up
- down
- left
- right

```html
<input @keydown.enter="method" />
```

#### 鼠标修饰符

- left
- middle
- right

```html
<input @mousedown.middle="method" />
```
## 4. 组件
[代码示例](./practice/demo12.html)

因为dom标签中不支持大写,所以在命名组件时如果用了驼峰,在使用时需要以`-`做连接
- `XiaoJieJie`  ---->  `<xiao-jie-jie></xiao-jie-jie>`
### 根组件
传递给 `createApp` 的选项用于配置根组件。当我们挂载应用时，该组件被用作渲染的起点。

一个应用需要被挂载到一个 DOM 元素中。例如，如果你想把一个 Vue 应用挂载到` <div id="app"></div>`，应该传入 `#app`

```html
<div id="app">
    渲染的起点
</div>
<script>
    import { createApp } from "vue"
    const app = createApp({data() {return {count: 4}}}) // 实例
    const vm = mount("#app"); // 返回的是根组件实例
    vm.count; // 4
</script>
```

### 4.1 全局组件
只要定义了，处处可以使用，性能不高，但是使用起来简单
- 全局组件编写起来确实非常方便，当时全局组件就是你一旦定义了，就会占用系统资源。
- 它是一直存在的，你在任何地方都可以使用这个全局组件。

```js
app.component("titleData", {
    data(){
        return {
            data: "这是我的第" + this.num + "次demo"
        }   
    },
    props: ["num"],
    template: `
        <div>{{ data }}</div>
    `
})
```
### 4.2 局部组件
`{counter, btn: myBtn}`

局部组件在注册的时候可以以键值对的形式,也可以以set的形式
- 键值对形式的时候,key为标签名

```js
// 局部组件
const counter = {
    data(){
        return {
            count: 0
        }
    },
    methods:{
        counter(){
            this.count += 1;
        }
    },
    template: `
        <div>{{ count }}</div>
        <button @click.stop="counter">点我</button>
    `
}
// 局部组件
const myBtn = {
    template: `
        <button>点我无效</button>
    `
}

// 需要在实例中注册
const app = Vue.createApp({
    // 局部组件注册
    components: {counter, btn: myBtn},
    data(){
        return {
            num: 12
        }
    },
    template: `
        <div>
            <counter />
            <btn />
        </div>
    `
})
const vm = app.mount("#app")
```

### 4.3 组件传值
- 动态参数: 使用`v-bind`绑定的参数,该参数的数据类型根据绑定参数而定
- 静态参数: 直接以dom属性的形式传参,数据类型永远为字符串类型

参数校验: 如果校验不通过会在控制台中出现告警
- 支持对`String`、`Boolean`、`Array`、`Object`、`Function`和`Symbol`做校验
- 支持做必传校验: `required`
- 支持做默认值: `default`
- 支持`validator`校验器: 可自定义一个校验方法,返回为`true`即为通过
```js
Vue.component("组件名",{
    props: ["形参"],
    template: "生成的模板"
});

Vue.component('blog-post', {
  props: ['show'], // 声明形参
  template: '<h3>{{ show }}</h3>'
})

const component1 = {
    // 对传参的数据类型做校验
    props: {
        A: String,
        B: Boolean,
        C: Array,
        D: Object,
        E: Function,
        F: Symbol
    }
}

const component2 = {
    props: {
        A: {
            type: String,
            required: true  // 必传参数
        },
        B: {
            type: Array,
            default: [1, 2, 3, 4]
        },
        C: {
            type: Boolean,
            validator: (value)=>{
                return value === true
            }
        }
    }
}
```
---
```js
const counter = {
    props: ["name", "age", "height", "popup"],
    data(){
        return {
            count: 0
        }
    },
    methods:{
        counter(){
            this.count += 1;
        }
    },
    template: `
        <div>{{ count }}</div>
        <button @click.stop="counter">点我</button>
        <p>姓名:{{name}}</p> 
        <p>[年龄:{{age}} 数据类型: {{typeof age}}]</p>
        <p>[身高:{{height}} 数据类型: {{typeof height}}]</p>
        <button @click="popup">触发根组件方法</button>
    `
}

const app = Vue.createApp({
    // 局部组件注册
    components: {counter, btn: myBtn},
    data(){
        return {
            num: 12,
            name: "小明",
            age: 30,
            popup: ()=>{ // 传递方法
                alert("这里是根组件的方法")
            }
        }
    },
    template: `
        <div>
            <website />
            <titleData :num="num" />
            <counter :name="name" :age="age" height=200 :popup="popup" />
            <btn />
        </div>
    `
})
```
#### 4.4.2 监听子组件事件
实例1
```html
<!-- 根组件模板 -->
<div id="blog-posts-events-demo">
  <div :style="{ fontSize: postFontSize + 'em' }">
    <!-- 
        1. v-on:enlarge-text 监听子组件 
        2. $event用来接收子组件的传参
        3. 如果触发的是函数onEnlargeText则当参数传入-->
    <blog-post
      v-for="post in posts"
      v-bind:key="post.id"
      v-bind:post="post"
      v-on:enlarge-text="postFontSize += 0.1"

      v-on:enlarge-text="postFontSize += $event"

      v-on:enlarge-text="onEnlargeText"
    ></blog-post>
  </div>
</div>

<script>
// 子组件
const com = {
  props: ['post'],
  template: `
    <div class="blog-post">
        <h3>{{ post.title }}</h3>

        <button v-on:click="$emit('enlarge-text')">
        <!-- 如果监听到点击就发送给父组件的enlarge-text -->
            Enlarge text
        </button>

        <!-- 也可以直接由子组件传参到父组件 -->
        <button v-on:click="$emit('enlarge-text', 0.1)">
            Enlarge text
        </button>  

        <div v-html="post.content"></div>
    </div>
  `
}

// 数据对象
const TodoList = {  
    data(){
        return {
                {
                    [
                        { id: 1, title: 'My journey with Vue' },
                        { id: 2, title: 'Blogging with Vue' },
                        { id: 3, title: 'Why Vue is so fun' }
                    ],
                    postFontSize: 1
                }
            }
        }
    } 

// 根组件实例
const app = Vue.createApp(TodoList);
app.component("blog-post", com);
app.mount("#blog-posts-events-demo");

</script>
``` 

## 5. css
[代码示例](./practice/demo6.html)
### 样式绑定
Vue中对模板使用css样式, 支持用数组,字符串,对象的形式控制样式

如果绑定的是style属性, 可以使用 `{样式属性: 样式}` 这种格式声明

```html
<div>
    <p :class="classObject"> 组合显示 </p>
    <p :class="classArray"> 组合显示 </p>
    <p :class="classString"> 组合显示 </p>
    <button @click="updateStyle">你点我试试?</button>

    <p :style="styleObject">我绑定了style</p>

    <my-component style="background: orange" />
</div>
```                
```js
classObject: {red: true, greenBackGround: true, size: true},
classArray: ["red", "greenBackGround", {size: true}],
classString: "size",
styleObject: {color: "green", "font-size": "50px"} // 绑定style属性
```
### 子组件样式绑定
子组件的样式可以在 子组件标签处声明,也可以在子组件模板内声明

子组件模板内需要仅有一个一级标签,否则在子组件处声明样式无效

```js
// 根组件
template: `
<div>
    <p :class="classObject"> 组合显示 </p>
    <p :class="classArray"> 组合显示 </p>
    <p :class="classString"> 组合显示 </p>
    <button @click="updateStyle">你点我试试?</button>

    <p :style="styleObject">我绑定了style</p>

    <my-component style="background: orange" />
</div>
            `


// <!-- 仅有一个一级标签 -->

app.component("my-component", {
template: `
    <div>
        <div class="red">我是红</div>
        <div style="color: green">我是绿</div>    
    </div>
`
})
```

# 5. vue-router路由库
1. 安装路由插件：`cnpm install vue-router`
2. 为了方便维护路由，一般都要在src目录创建一个路由目录(route),创建js文件(index.js)
3. 将下面引用放置在js文件中
```js
// 导入库
import Vue from ' vue'
import VueRouter from ' vue-router'

// 使用插件
Vue.use(VueRouter)

// 导入组件
import learn_ui from '../components/learn_ui'
import learn_1 from '../components/learn_1'

// 创建路由
const router = new VueRouter({
    mode: 'history'
    routes: [
        // 每个对象都是一组路由
        {path: '/learn_ui', component: learn_ui, name: 'home'},
        {path: '/learn_1', component: learn_1, name: 'learn'}
        
    ]
});

// 导出路由
export default router;
```
4. 在根js中导入router对象
```js
import router from './router/index.js' 
import router from './router'  // 如果是index.js可不填后面得


// 加入实例中
new Vue({
    router, // 加入路由
    // do something
})
```
5. 在根组件中调用(嵌套路由)
```html
<router-view></router-view>
```
6. 在根组件中创建路由link
```html
<!-- to属性默认未path路径值 -->
<ul>
    <li><router-link to="{ name: 'home', params: { username: 123 }}">主页</router-link></li>
    <!-- 可以使用路由的名字，也可以使用path -->
    <li><router-link to="/learn_1">二页</router-link></li>
    <li><router-link to="{ name: 'learn' }">二页</router-link></li>
</ul>

```
7. 如果需要或者get的字符串参数
```js
// 在组件中可以通过this.$router.query 来获取查询字符串参数
created(){
    this.username = this.$router.query.name  // 将查询的值进行赋值 name为字符串的key
}
```
8. 路径参数
```js
// 创建路由
const router = new VueRouter({
    mode: 'history'
    routes: [
        // 每个对象都是一组路由
        {path: '/learn_ui/:username', component: learn_ui, name: 'home'}, // 路径参数
        {path: '/learn_1', component: learn_1, name: 'learn'}
        
    ]
});
```
9. 查询路径参数
```js
// 在组件中可以通过this.$router.params 来获取路径参数
created(){
    this.a = this.$router.params.username  // 将查询的值进行赋值 username 设定时的路径参数名
}
```
10. 内嵌路由
```js
// 创建路由
const router = new VueRouter({
    mode: 'history'
    routes: [
        // 每个对象都是一组路由
        {path: '/learn_ui/:username', component: learn_ui, name: 'home'}, // 路径参数
        {
            path: '/learn_1', 
            component: learn_1, 
            name: 'learn',
            children:[
                {
                    path: '', component: Defaulet // path为空 说明默认路由
                },{
                    path: '/learn_ui', component: learn_ui // 如果子路由的地址也从根开始，那么在搜索路由的时候会当作一级路由一样命中(即/learn_ui)
                },{
                    path: 'learn_ui', component: learn_ui // 如果没有根，那么path会与父路由拼接 learn_1/laran_ui
                }
            ]}
        
    ]
});
```

# 6. slot插槽
### 6.1 插槽
```html
<!-- 子组件 -->
<template>

<slot>
<!-- 第一种方式 -->
</slot>

<!-- 第二种方式 -->
<slot><p>这里是默认内容，如果在组件中有其他值会被覆盖</p></p></slot>


<!-- 命名插槽 -->
<slot name="part1"></slot>

<!-- 插槽作用域 -->

<slot name="part4" :user="username">  username 已经定义 </slot>

<slot name="part5" user="random参数">  username 已经定义 </slot>

<slot name="part6" user="random">  username 已经定义 </slot>


</template>

```
```html
<!-- 父组件 -->
<hello-world>

<p>这个是子组件，需要在模板处使用插槽</p>

</hello-world>


<!-- 命名插槽 -->

<!-- vue2.6之前 -->
<hello-world>

<p slot="part1">命名插槽</p>

</hello-world>


<!-- vue2.6之后 也会兼容2.6之前 -->
<template v-slot:part2>
    <p>vue2.6之后</p>
</template>

<template #part2>
    <p>vue2.6之后</p>
</template>


<!-- 插槽作用域 -->
<!-- vue2.6之前 -->
<p slot="part4" slot-scope="sope"> 插槽作用域 {{ sope.user }} 获取子组件中的属性 </p>


<!-- vue2.6之后 -->
<template #part5="sope">
    <p>{{ sope.user }} 获取子组件中的属性 </p>
</template>

<template #part6="{ user }">
    <p>{{ user }} 获取子组件中的属性 </p>
</template>
``` 
# 7.axios请求库

调用网站:https://dog.ceo/api/breeds/image/random

1. 简介
- 非常流行的请求库
- vue发起异步请求的标配
安装 `npm install axios -S`

```html
<script>
import axios from 'axios' // 导入


data() {
    return {
        url: "",
    }
}

// 方式一：不推荐
mounted(){
    axios.get('https://dog.ceo/api/breeds/image/random')
}.then(function(response){
    console.log(response.data)
    // this 指的是当前的function
})
.catch(function(err){
    console.log(err)
});


// 方法二：箭头函数
mounted(){
    axios.get('https://dog.ceo/api/breeds/image/random')
}.then(response => { //es6语法 箭头函数无this 所以指的是data
    console.log(response.data)
    this.url = response.data.message
})
.catch(err => {
    console.log(err)
});



mounted(){
    axios.post('https://dog.ceo/api/breeds/image/random', {name: '', age: 20})
}.then(response => { //es6语法 箭头函数无this 所以指的是data
    console.log(response.data)
    this.url = response.data.message
})
.catch(err => {
    console.log(err)
});

</script>
```

2. 集中管理api
在src下面创建api文件及api.js， 对请求方法二次封装
```js
var base_host = 'https://dog.ceo'

export const dogs = () => { // export 声明该方法可以在其他地方调用 const 常量 dogs函数名
    return axios.get(`${base_host}/api/breeds/image/random`)  // `${}` 解析里面的变量 
}

```
```js
import {dogs} from '../api/api'

dogs()
    .then(response => {

    })
    .catch(err => {

    });
```

# 8.vuex状态管理库