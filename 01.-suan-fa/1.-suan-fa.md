# 1.算法

### 练习题

#### 1. 第一个元素是数据标识，第二个元素的数值必须大于等于50才返回，不够50往后累加，加到最后如果不够50也直接返回，因为没有可加的数据了。

```text
例子1：
a = [[1,3],[2,51],[3,49],[4,42],[5,42]] # 入参
a1 = [[2,54],[4,91],[5,42]] # 返回
例子2：
b = [[1,50],[2,5],[3,10],[4,42],[5,42],[6,10]] # 入参
b1 = [[1,50],[4,57],[6,52]] # 返回
```

```python
def func1(args):
    total = 0
    amount = []
    for k, v in args:
        total += v
        if total >= 50 or k == len(args):
            amount.append([k, total])
            total = 0
    return amount


a = [[1, 3], [2, 51], [3, 49], [4, 42], [5, 42]]
print(func1(a))  # [[2, 54], [4, 91], [5, 42]]
b = [[1, 50], [2, 5], [3, 10], [4, 42], [5, 42], [6, 10]]
print(func1(b))  # [[1, 50], [4, 57], [6, 52]]
```

#### 2. cookie\_str=‘PHPSESSID=et4a33og7nbftv60j3v9m86cro; Hm\_lvt\_51e3cc975b346e7705d8c255164036b3=1561553685; Hm\_lpvt\_51e3cc975b346e7705d8c255164036b3=1561553685'

```python
cookie_str = "PHPSESSID=et4a33og7nbftv60j3v9m86cro; " \
             "Hm_lvt_51e3cc975b346e7705d8c255164036b3=1561553685; " \
             "Hm_lpvt_51e3cc975b346e7705d8c255164036b3=1561553685"

print({i.split("=")[0]: i.split("=")[1] for i in cookie_str.split(";")})
print({k: y for k, y in [x.split("=") for x in cookie_str.split(";")]})
```

_一：实现斐波那契数列数列，输入一个数列的位置数，返回斐波那契数列相应位置的值斐波那契数列\[1，1，2，3，5，8，13，21，34....\]，第一个数是1，后面的数等于前两个数相加的结果_

```python

```

_二、有一对兔子，第三个月其每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子\(意味着生长期为2个月\)，假如兔子都不死，问每个月的兔子总数为多少？_

```python

```

_三、小明有100元钱打算买100本书，A类书籍5元一本，B类书籍3元一本，C类书籍1元两本，请用程序算出小明一共够多少种买法？\(面试笔试题\)_

### 1. 排序算法

* **比较类排序**：通过比较来决定元素间的相对次序，由于其时间复杂度不能突破O\(nlogn\)，因此也称为非线性时间比较类排序。
* **非比较类排序**：不通过比较来决定元素间的相对次序，它可以突破基于比较排序的时间下界，以线性时间运行，因此也称为线性时间非比较类排序。 

  ![](../.gitbook/assets/算法类型.png)

* 稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面。
* 不稳定：如果a原本在b的前面，而a=b，排序之后 a 可能会出现在 b 的后面。
* 时间复杂度：对排序数据的总的操作次数。反映当n变化时，操作次数呈现什么规律。
* 空间复杂度：是指算法在计算机内执行时所需存储空间的度量，它也是数据规模n的函数。 

  ![](../.gitbook/assets/算法复杂度.png)

  **1. 冒泡算法**

  \`\`\`py

  **冒泡排序**

  @timer

  def bubble\_sort\_1\(value\):  \# 最原始版

    n = len\(value\)

    if n &lt;= 1:

  ```text
    return value
  ```

    for i in range\(n\):

  ```text
    for j in range(n - 1):
        if value[j] > value[j + 1]:
            value[j], value[j + 1] = value[j + 1], value[j]
  ```

    return value

@timer def bubble\_sort\_2\(value\): \# 优化版,提高了降低了时间复杂度,提高了效率 if len\(value\) &lt;= 1: return value for i in range\(1, len\(value\)\): for j in range\(len\(value\) - i\): \# 每次遍历完后最大值一定会在最后面,所以不需要重复遍历到最后,每次只要需要n-1次就可以了 if value\[j\] &gt; value\[j + 1\]: value\[j\], value\[j + 1\] = value\[j + 1\], value\[j\] return value

@timer def bubble\_sort\_3\(value\): \# 优化版,提高了降低了时间复杂度,提高了效率 if len\(value\) &lt;= 1: return value for i in range\(1, len\(value\)\): switch = True \# 如果在排序过程中一个大轮回都没有变化,此时可以当做已经完成排序.当数据量比较大时,才会有更短的时间,否则时间会更长 for j in range\(len\(value\) - i\): \# 每次遍历完后最大值一定会在最后面,所以不需要重复遍历到最后,每次只要需要n-1次就可以了 if value\[j\] &gt; value\[j + 1\]: value\[j\], value\[j + 1\] = value\[j + 1\], value\[j\] switch = False if switch: return value return value

print\(bubble\_sort\_1\(value\)\) print\(bubble\_sort\_2\(value\)\) print\(bubble\_sort\_3\(value\)\) \# 采用

## 小数据量:  v2&gt;v1&gt;v3          大数据量:  v3&gt;v2&gt;v1

```text
### 2. 选择插入排序
比对无序数据中最小值,将其插入在有序数据最后(或生成新的有序列表存储)
```py
# 选择算法  选择最小的数放在最前面
@timer
def select_sort(value):  # 新开一个列表存储, 数据稳定
    sort = []

    while len(value):
        a = value[0]
        for x in value:
            if x < a:
                a = x
        value.remove(a)
        sort.append(a)
    return sort


@timer
def select_sort2(value):  # 在原列表内排序, 数据稳定
    for i in range(len(value)):
        a = value[i]
        for x in value[i:]:
            if x < a:
                a = x
        index = value.index(a, i)  # 避免出现相同数时,得到最先的索引,所以不断缩小查询范围
        value.pop(index)
        value.insert(i, a)
    return value


# 原始采用互换位置的选择排列是不稳定的,方法二采用直接insert的方式插入数据,所以数据是稳定的
# 方法一 > 方法二
```

#### 3. 快速排序

采用分而治之的思想,每次递归都将数据按大小分列在pivot, 先排序后递归

```python
def quick_sort(value, start, end):
    if start >= end:
        return value
    pivot = value[start]
    low = start
    high = end
    while low < high:
        while low < high and value[high] >= pivot:
            high -= 1
        value[low] = value[high]

        while low < high and value[low] <= pivot:
            low += 1
        value[high] = value[low]

    value[low] = pivot

    quick_sort(value, start, low-1)
    quick_sort(value, low+1, end)

    return value
```

#### 4. 归并排序

```python
def merge_sort1(value):  # 不推荐此方法
    # 分
    if len(value) <= 1:  # 递归终止条件
        return value
    mid = len(value) // 2

    left = merge_sort1(value[:mid])
    right = merge_sort1(value[mid:])

    # 治
    li = []
    while left and right:
        if left[0] < right[0]:
            li.append(left.pop(0))  # pop 速度非常慢
            # li.append(left[0])
            # del left[0]
        else:
            li.append(right.pop(0))
            # li.append(right[0])
            # del right[0]
    # 剩下的数据都比其他的大
    if left:
        li += left
    if right:
        li += right

    return li


def merge_sort2(value):  # 推荐
    # 分
    if len(value) <= 1:  # 递归终止条件
        return value
    mid = len(value) // 2

    left = merge_sort2(value[:mid])
    right = merge_sort2(value[mid:])

    # 治
    li = []
    low = high = 0
    while low < len(left) and high < len(right):
        if left[low] < right[high]:
            li.append(left[low])
            low += 1
        else:
            li.append(right[high])
            high += 1
    # 剩下的数据都比其他的大
    if high == len(right):
        li += left[low:]
    else:
        li += right[high:]

    return li


# merge_sort2快于merge_sort1很多倍,因为删除列表的操作很耗时间(pop/remove/del)
# 略慢于快排,还存在优化空间
```

### 2. 查找算法

#### 1. 二分查找

```python
# 二分查找
# 非递归
def binary_search_loop(value, target):
    # 设定位置索引指针
    left = 0
    right = len(value) - 1
    while left <= right:
        mid = (right + left) // 2  # 动态取平均(左右区间之和/2)
        if value[mid] < target:
            left = mid + 1
        elif value[mid] > target:
            right = mid - 1
        else:
            return mid
    return -1


# 递归
def binary_search_recursion(value, target, start, end):
    if start > end:  # 递归终止条件
        return -1
    mid = (start + end) // 2
    if value[mid] == target:  # 递归终止条件
        return mid
    elif target > value[mid]:
        start = mid + 1
    else:
        end = mid - 1
    return binary_search_recursion(value, target, start, end)
```

