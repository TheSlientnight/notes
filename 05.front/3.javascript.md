https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Method_definitions
# 1. 基本语法


## 1.1. 注释

我们可以添加注释来对JavaScript进行解释，或者提高代码的可读性。

```javascript
// 单行注释

/*多行注释
多行注释*/
```

## 1.2. 变量

### 1.2.1 变量命名

* 变量可以使用短名称\(比如x和y\)，也可以使用描述性更好的名称\(比如 age，sum，totalvolume\)。
* 变量必须以字母开头
* 变量也能以$和\_符号开头\(不过我们不推荐这么做\)
* 变量名称对大小写敏感\(y和Y是不同的变量\)
* \(小\)驼峰式命名

### 1.2.2 变量声明


javaScript中变量可以先声明后赋值, 也可以在声明的时候赋值. 以及同时给多个变量赋值


```javascript
var age;
age = 30;
console.log(age)

var name = "hahaxi";
console.log(name)

var a=100; b=200; c="asdsad";
consloe.log(a)
consloe.log(b)
consloe.log(c)
```

## 1.3 数据类型

### 1.3.1 字符串、数字、布尔(Boolean)、Null、Undefined、数组**

```javascript
var a = 300;  //数值类型, 支持四则运算

var b = "haha";  //字符串类型

var c = true; d = false;  //布尔类型
var l = 2 > 1; // false

var f;  //undefind类型(声明未赋值)

var e = null;  //Null类型

var g = [1, 2, "g", null, true, "5"] // 数组
var f = new Array(1, 2, 3) // 不常用该方法

var n = NaN; // 特殊值
NaN === NaN; // false
isNaN(NaN); // true
```

### 1.3.2 字符串

```javascript
consloe.log(`dsad
dasda
asds`)  // 采用反引号支持换行

// 模板字符串


var name = '小明';
var age = 20;
// 方法一:
var message = '你好, ' + name + ', 你今年' + age + '岁了!';

// 方法二(ES6语法):
var message = `你好, ${name}, 你今年${age}岁了!`;


// 操作字符串

var b = "hello_world!"

b.length; // 12
```

#### 1.3.3 字符串方法

```javascript
// 变成大写 toUpperCase
var s = 'Hello';
s.toUpperCase(); // 返回'HELLO'


// 变成小写 toLowerCase
var s = 'Hello';
var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lower
lower; // 'hello'

// 获取索引
var s = 'hello, world';
s.indexOf('world'); // 返回7, 首个字母的索引
s.indexOf('WORLD'); // 没有找到指定的子串，返回-1

// 切片
var s = 'hello, world'
s.substring(0, 5); // 从索引0开始到5（不包括5），返回'hello'
s.substring(7); // 从索引7开始到结束，返回'world'
```

### 1.3.3 数组
```js
var g = [1, 2, "g", null, true, "5"] // 数组
var f = new Array(1, 2, 3) // 不常用该方法

// 可以通过控制length实现数组的长度
console.log(g.length) // 6
g.length = 10  // 多余索引的值为undefined
console.log(g) // [1, 2, "g", null, true, "5", undefined, undefined, undefined, undefined]
g.length = 2  // 相当于切片,取前n个
console.log(g) // [1, 2]

var arr = ['A', 'B', 'C', 'D', 'E', 'F', 'G'];
// indexof 获取索引
arr.indexof("A")  // 0
// slice 切片
arr.slice(1, 5) // ["B", "C", "D", "E"]
arr.slice(5) // ["F", "G"]
// push 从尾部添加
arr.push("X") 
console.log(arr) //  ["A", "B", "C", "D", "E", "F", "G", "X"]
// pop 从尾部弹出并删除该元素
var res = arr.pop()
console.log(res)  // X
console.log(arr) // ["A", "B", "C", "D", "E", "F", "G"]


var arr = [1, 2]
// unshift 向头部添加一个元素
arr.unshift("A", "B") // ["A", "B", 1, 2]
// shift 删掉头部第一个元素
arr.shift() // A
console.log(arr) // ["B", 1, 2]
// reverse 反转
arr.reverse() // [2, 1, "B"]
// splice 粘接 在指定索引处删除,返回原始元素并添加新元素
arr.splice(1, 2, "G", "F", "T") // [1, "B"]  将索引1到1+2前,即[1:3]删除并返回,并且在该区间内添加后续元素
console.log(arr) // [2, "G", "F", "T"]
arr.splice(3, 2) // ["T"]  仅删除不添加
arr.splice(2, 0, "O", "U", "Y") // 不删除仅添加
console.log(arr) // [2, "G", "O", "U", "Y", "F"]

// concat 连接 拼接数组
var arr = ['A', 'B', 'C'];
var new_arr =  arr.concat(1, 2, [3, 4]); // ['A', 'B', 'C', 1, 2, 3, 4]
console.log(arr) // ["A", "B", "C"]

// join 格式化输出字符串
var arr = ['A', 'B', 'C'];
var b = arr.join("-")
console.log(b)  // "A-B-C"
```
#### 数组排序
对数组的引用。请注意，数组在原数组上进行排序，不生成副本。

如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。

如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：

- 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。
- 若 a 等于 b，则返回 0。
- 若 a 大于 b，则返回一个大于 0 的值。

##### 排序字母
```js
var str = ["abd", "bda", "abc", "xdg", "pjg"];
str.sort();
console.log(str);  // ["abc", "abd", "bda", "pjg", "xdg"]
```
##### 排序数字(自定义排序)
```js
var arr = [10, 55, 2, 333];
var fn = (x,y) => {
    return x>y?1:-1;
};
arr.sort(fn);
console.log(arr);  // [2, 10, 55, 333]
```

### 1.3.4 对象
是一组由键-值组成的无序集合
- 方式一(不常用)： `objA = new object();`
- 方式二：类式于python中的字典， `var objA={};`

每个键又称为对象的属性, 对象方法:对象方法是作为属性来存储的函数。

对象属性key在非特殊字符串的情况下,无需使用引号`""`
```javascript
// 方法一
objA = new Object();

objA.name = "this is obja"
objA["age"] = 20
objA.func = function(var1, var2){
    alert(var1);
    alert(var2);
}

console.log(objA.name)  // 
console.log(objA["age"])
objA.func("xixixi", "asjdasjdlk")

// 方法二

var objB = {
    name : "js",
    age : 18,
    func : function (var1, var2) {
        alert(var1);
        alert(var2);
        return 20000
    }

}

console.log(objB.age)
console.log(objB["name"])
gg = objB.func("haha", 12345)


objB.year = 2020;  // 自由添加新的属性
console.log(objB.year);
delete objB.year;  // 自由删除属性
console.log(objB.year);  // undefined
console.log(objB);  // {name: "js", age: 18, func: ƒ}

// 检测对象中是否含有该属性(也有可能是继承的)
"name" in objB;  // true
"year" in objB;  // false

// hasOwnProperty可以判断该属性是否为对象自身的
objB.hasOwnProperty("name"); // true
objB.hasOwnProperty("toString"); // false
```

### 1.3.5 Map
ES6新增数据类型,类似于python中的字典

array元素越多时查找越慢,如果用map实现,无论元素有多少,速度都很快
- clear: 从映射中移除所有元素。
- delete: 从映射中移除指定的元素。
- forEach: 对映射中的每个元素执行指定操作。
- get: 返回映射中的指定元素。
- has: 如果映射包含指定元素，则返回 true。
- set: 添加一个新建元素到映射。
- toString: 返回映射的字符串表示形式。
- valueOf: 返回指定对象的原始值。
```js
var m = new Map([['Michael', 95], ['Bob', 75], ['Tracy', 85]]);
m.get('Michael'); // 95
m.set("Tom", 11); // m对象
m.delete("Michael"); // true
m.has("Michael");  // false
m.has("Tom");  // true
```
### 1.3.6 Set
ES6新增数据类型, 是一组key的集合，但不存储value。由于key不能重复，所以，在Set中，没有重复的key。
```js
var s = new Set([1, 2, 3, 3, '3']);
s; // Set {1, 2, 3, "3"}  数字3和字符串'3'是不同的元素
s.add("A");  // s对象
s; // Set {1, 2, 3, "3", "A"}
s.delete(2);  // true
s; // {1, 3, "3", "A"}
```

### 1.3.7 iterable
ES6标准引入了新的iterable类型，Array、Map和Set都属于iterable类型

具有iterable类型的集合可以通过新的`for ... of`循环来遍历。
```js
var arr = ["A", "B", "C"];
var set = new Set([1, 2, "g", "t"]);
var map = new Map([["Tom", 20], ["Jack", 100], ["Bob", 5]]);

for (var x of arr){
    console.log(x);  // A B C
}

for (var x of set){
    console.log(x); // 1 2 g t
}

for (var x of map){
    console.log(x[0]+"="+x[1]);  // Tom=20 Jack=100 Bob=5
}
```
#### forEach
接收一个函数，每次迭代就自动回调该函数, JavaScript的函数调用不要求参数必须一致，因此可以忽略它们
```JS
// 数组
var a = ['A', 'B', 'C'];
a.forEach(function (element, index, array) {
    // element: 指向当前元素的值
    // index: 指向当前索引
    // array: 指向Array对象本身
    console.log(element + ', index = ' + index);
});

// set
var s = new Set(['A', 'B', 'C']);
s.forEach(function (element, sameElement, set) {
    // 因为set没有索引, 所以前两个参数都是元素本身
    // set: 指向s对象本身
    console.log(element);
});

// map
var m = new Map([[1, 'x'], [2, 'y'], [3, 'z']]);
m.forEach(function (value, key, map) {
    // 
    console.log(value);  // x y z
    console.log(key);  // 1 2 3
    console.log(map); // 指向m对象本身
});

// 忽略部分参数
var a = ['A', 'B', 'C'];
a.forEach(element => {
    console.log(element);
});
```

## 1.4 运算符

- 算术运算符：+(加)、-(减)、*(乘)、/(除)、%(求余)
- 赋值运算符：=、+=、-=、*=、/=、%=、++
- 条件运算符：==、===、>、>=、<、<=、!=
- 逻辑运算符：&&(而且)、||(或者)、!(否)


- 第一种是 `==` 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；
- 第二种是 `===` 比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。
- 由于JavaScript这个设计缺陷，不要使用==比较，始终坚持使用===比较。

```javascript
// 如果需要对浮点数进行对比
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```
### 逻辑运算符
- `&&`运算是与运算，只有所有都为true，&&运算结果才是true：
- `||`运算是或运算，只要其中有一个为true，||运算结果就是true：
- `!`运算是非运算，它是一个单目运算符，把true变成false，false变成true：

```js
true && true; // 这个&&语句计算结果为true
true && false; // 这个&&语句计算结果为false
false && true && false; // 这个&&语句计算结果为false

false || false; // 这个||语句计算结果为false
true || false; // 这个||语句计算结果为true
false || true || false; // 这个||语句计算结果为true

! true; // 结果为false
! false; // 结果为true
! (2 > 5); // 结果为true

var age = 15;
if (age >= 18) {
    alert('adult');
} else {
    alert('teenager');
}
```
## 1.5 条件语句

### 1.5.1 if条件语句
`null`、`undefined`、`0`、`NaN`和空字符串`''`视为`false`，其他值一概视为`true`
```javascript
if(a > 10){
    console.log("a大于10");
}else if(a < 1){
    console.log("a小于1")
}else{
    console.log("a小于10 大于1")
}

// 上方语法相当于
if(a > 10){
    console.log("a大于10");
}else{ // 通常不这样写, 在一行表达式的时候可以忽略`{}`
    if(a < 1){
        console.log("a小于1")
    }else{
        console.log("a小于10 大于1")
    }
}

// 一行表达式, 可以忽略`{}`  但是不推荐这样写
if(a > 10)
    console.log("a大于10");
else if(a < 1){
    console.log("a小于1")
else
    console.log("a小于10 大于1")
```

### 1.5.2 switch表达式


计算一次 switch表达式
把表达式的值与每个case的值进行对比
如果存在匹配，则执行关联代码
遇到break 关键词，它会跳出switch代码块。
case 匹配不存在时，运行default的代码：


```javascript
switch(a+b){
    case c:
        console.log("等于c")
        break
    case b:
        console.log("等于b")
        break
    case d:
        console.log("等于d")
        break
    default:
        console.log("都不是")
}
```

## 1.6 函数

```javascript
// 命名函数
function func(var1, var2){
    console.log(var1);
    console.log(var2);
}

res = func(1, 3);

// 匿名函数
let func = function(var1, var2){
    console.log(var1);
    console.log(var2) ;
}
res = func(1, 3);
```


### 语法缩写(es6)
#### 方法
```js
var obj = {
  foo: function() {
    /* code */
  },
  bar: function() {
    /* code */
  }
};

// 可以缩写为
var obj = {
  foo() {
    /* code */
  },
  bar() {
    /* code */
  }
};

```
#### 生成器
```js
// 用有属性名的语法定义方法（ES6之前）：
var obj2 = {
  g: function*() {
    var index = 0;
    while(true)
      yield index++;
  }
};

// 同一个方法，简写语法：
var obj2 = { 
  * g() {
    var index = 0;
    while(true)
      yield index++;
  }
};

var it = obj2.g();
console.log(it.next().value); // 0
console.log(it.next().value); // 1
```
#### 异步方法
```js
// 用有属性名的语法定义方法（ES6之前）：
var obj3 = {
  f: async function () {
    await some_promise;
  }
};

// 同一个方法，简写语法：
var obj3 = { 
  async f() {
    await some_promise;
  }
};
```
#### async生成器方法
```js
var obj4 = {
  f: async function* () {
    yield 1;
    yield 2;
    yield 3;
  }
};

// 简写
var obj4 = {
  async* f() {
   yield 1;
   yield 2;
   yield 3;
  }
};
```
#### 支持计算的属性名
```js
var obj5 = {
    name: "foo",
    ["foo" + "2"](){return 1}  // 仅支持拼接之类的
}

```

## 1.7 循环

### 1.7.1 while循环

```javascript
while (条件)
{
    // 需要执行的代码
}
```

```javascript
while(a<5){  // 每次循环开始判断
    console.log("a小于5")
    a++
}
```
```js
var n = 0;
do {
    n = n + 1;  // 每次循环完成开始判断,将至少运行一次
} while (n < 100);
n; // 100
```

### 1.7.2 for循环

```javascript
for (语句 1; 语句 2; 语句 3)  // 3个条件都可以为空,但需要具备退出条件,否则将会进入死循环
{
    被执行的代码块
}
```

```javascript
for (var i=0;i<cars.length;i++)
{ 
    document.write(cars[i] + "<br>");
}
// 前置条件若已经声明 语句一可不写
var i=2,len=cars.length;
for (; i<len; i++)
{ 
    document.write(cars[i] + "<br>");
}
// 语句三 若已经在代码块中有相应代码 也可不写
var i=0,len=cars.length;
for (; i<len; )
{ 
    document.write(cars[i] + "<br>");
    i++;
}

// 遍历对象属性，得到的是属性名
var person={fname:"John",lname:"Doe",age:25}; 

for (var x in person)  // x 为属性名
{
    txt=txt + person[x];
}

// 遍历数组
var aList = (1, 33, 55, 99);
for (var y in aList){
    console.log(y)  // y 为数组索引(字符串类型)
    a = aList[y]
}
```

## 箭头函数
- 当不需要多行表达式时,可以直接一行表示,省略`{}`和`return`
- 如果仅有一位参数时,支持无需`()`, 其他情况都要加括号(无参数也需要)
- 如果返回一个对象,且仅有一行表达式,则必须在对象外加括号
```js
var x = function(i, o){
    return i + o;
};
// 以下是箭头函数, 相当于
var x = (i, o) => {
    return i + o;
};
// 当不需要多行表达式时,可以直接一行表示,省略`{}`和`return`
var x = (i, o) => i + o;
```
```js
// 如果仅有一位参数时,支持无需`()`
i => i * i;
// 无参数,必须`()`
() => 123;
// 返回一个对象
i => ({"name": i})
```
## this
箭头函数内部的this是词法作用域，由上下文确定, this总是指向词法作用域，也就是外层调用者

```js
var obj = {
    birth: 1990;
    getAge: function(){
        var b = this.birth; // 1990
        var fn = () => new Date().getFullYear() - this.birth;
        return fn()
    }
}
obj.getAge()
```
```js
var obj = {
    birth: 1990,
    c: console.log(this),  // window
    getAge(year){
        console.log(this);  // obj
        console.log(year);  // 2015
        var b = this.birth;
        console.log(b);  // 1990
        var fn = y => y - this.birth;
        console.log(fn(year));  // 25
        return fn.call({birth:2000}, year);
    }
};
var b = obj.getAge(2015); // 25
console.log(b);  // 25
```
为何上面这个getAge对象无法写成箭头函数, 因为在箭头函数中this总是指向词法作用域
```js
// 
var obj = {
    birth: 1990,
    c: console.log(this);  // window
    getAge: year => {
        console.log(this);  // window, 作用域还是在window
        console.log(year);  // 2015
        var b = this.birth;
        console.log(b);  // undefined
        var fn = y => y - this.birth;
        console.log(fn(year));  // NaN
        return fn.call({birth:2000}, year);
    }
};
var b = obj.getAge(2015);
console.log(b)  // NaN
```
### 实例
```js
function multiply(a, b) {
    if (b === undefined) {  // 当b为空时,返回一个函数
        return function (b) {
            return a * b;
        }
    }
    return a * b;
}

const double = multiply(2);
double(3); // => 6  // 调用内部的函数
multiply(2, 3); // => 6


// 用箭头函数表达
const multiply = (a, b) => b === undefined ? b => a * b : a * b;
const double = multiply(2);
double(3);      // => 6
multiply(2, 3); // => 6
```

## 三元运算符
格式: 条件?真结果:假结果
```js
var a = 30
var b = a>50?1:-1
console.log(b) // -1


var c = ""
var d = ""
a>50?(c="a大于50", d=true):(c="a小于50", d=false)  // 多行表达式
console.log(c)  // a小于50
console.log(d)  // false

// 支持多重嵌套
a>50?(a>100?(c="a大于100", d=true):(c="a大于50小于100", d=true)):(a>25?(c="a大于25小于50", d=false): (c="a小于25", d=false))
console.log(c)  // a大于25小于50
console.log(d)  // false
```

# 2. JS操作页面(原生)

- 通过HTMLDOM，可访问JavaScript HTML文档的所有元素。
- 当网页被加载时，浏览器会创建页面的文档对象模型(Document Object Model)。
- HTMLDOM模型被构造为对象的树。


![HTML DOM树](./images/DOM树.png)


节点树中的节点彼此拥有层级关系。
- 父(parent)、子(child)和同胞(sibling)等术语用于描述这些关系。
- 父节点拥有子节点。同级的子节点被称为同胞(兄弟或姐妹)


## 2.1 获取页面标签


获取标签的方式
- 通常，通过JavaScript操作HTML元素，可以使用内置对象document的方法来找到该标签
- 通过id 找到HTML元素(常用)  document.getElementByld()
- 通过标签名找到HTML元素  getElementsByTagName()  获取出来的是列表
- 通过类名找到HTML元素(通过类名查找HTML元素在IE5，6，7，8中无效) getElementsByClassName()  取出来的是列表


```javascript
var id = document.getElementById("project_site");
console.log(id);

var cls = document.getElementsByClassName("project_title");
console.log(cls);
console.log(cls[0]);

var tag = document.getElementsByTagName("p");
console.log(tag);
console.log(tag[0]);
```

## 2.2 操作标签内容

```javascript
var tag = document.getElementsByTagName("p");

var tag_0 = tag[0].innerText;
console.log(tag_0);
tag[0].innerText = "哈哈哈哈";
console.log(tag[1].innerHTML)
tag[1].innerHTML = "<h1>嘻嘻嘻</h1>"
```

## 2.3 修改标签属性

```javascript
var tag = document.getElementsByTagName("p");

tag[0].style.height = "300px";
```

## 2.4. onclick事件


# 3.内部函数

## call&apply&bind
call()、apply()、bind() 都是用来重定义 this 这个对象的！
### call()
- 调用函数对象的call方法时，会调用函数对象
- call方法的参数，会传递给this引用
```js
function func(name, age){
    console.log(name);
    console.log(age);
}

// call()的第一个参数会传递给this，call()还可以有其他参数，其他的实参，都会传递给函数对象的形参
func.call("this对象", "Tom", 20);  // Tom  20
```
```JS
var obj = {
    a: "Jack",
    b: 20,
    print(name, age){
        console.log(this.a);
        console.log(this.b);
        console.log("我的名字是:" + name);
        console.log("我的年龄是:" + age);
    }
}

var obj2 = {
    "a": "Tom",
    "b": 99
};
obj.print.call(obj2, "JOY", 66)  // Tom 99  我的名字是:JOY 我的年龄是:66
```
### apply()
与call()的用法大致相同, apply()只有两个形参
- 第一个形参接收的值会传递给this（这一点与call()相同）
- 第二个型参是一个数组，他接受函数对象的形参所封装成的数组
```js
function func(name, age){
    console.log(name);
    console.log(age);
}

func.apply("this", ["Jack", 100]);  // Jack  100   
```
```js
var obj = {
    a: "Jack",
    b: 20,
    print(name, age){
        console.log(this.a);
        console.log(this.b);
        console.log("我的名字是:" + name);
        console.log("我的年龄是:" + age);
    }
}

var obj2 = {
    "a": "Tom",
    "b": 99
};
var print = obj.print.apply(obj2, ["JACK", 999])  // Tom 99 我的名字是:JACK 我的年龄是:999
```
### bind()
bind与上面两个函数使用方法差不多,不过返回的是新的一个对象,需要进行调用
```js
var obj = {
    a: "Jack",
    b: 20,
    print(name, age){
        console.log(this.a);
        console.log(this.b);
        console.log("我的名字是:" + name);
        console.log("我的年龄是:" + age);
    }
}

var obj2 = {
    "a": "Tom",
    "b": 99
};
var print = obj.print.bind(obj2, "JACK", 2000);
print()  // Tom 99 我的名字是:JACK 我的年龄是:2000
```
