https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Method_definitions
# 1. 基本语法


## 1.1. 注释

我们可以添加注释来对JavaScript进行解释，或者提高代码的可读性。

```javascript
// 单行注释

/*多行注释
多行注释*/
```

## 1.2. 变量

### 1.2.1 变量命名

* 变量可以使用短名称\(比如x和y\)，也可以使用描述性更好的名称\(比如 age，sum，totalvolume\)。
* 变量必须以字母开头
* 变量也能以$和\_符号开头\(不过我们不推荐这么做\)
* 变量名称对大小写敏感\(y和Y是不同的变量\)
* \(小\)驼峰式命名

### 1.2.2 变量声明


javaScript中变量可以先声明后赋值, 也可以在声明的时候赋值. 以及同时给多个变量赋值


```javascript
var age;
age = 30;
console.log(age)

var name = "hahaxi";
console.log(name)

var a=100; b=200; c="asdsad";
consloe.log(a)
consloe.log(b)
consloe.log(c)
```

## 1.3 数据类型：

### 1.3.1 字符串、数字、布尔\(Boolean\)、Null、Undefined、数组**

```javascript
var a = 300;  //数值类型

var b = "haha";  //字符串类型

var c = true; d = false;  //布尔类型

var f;  //undefind类型(声明未赋值)

var e = null;  //Null类型

var g = [1, 2, "g", null, true, "5"] // 数组
var f = new Array(1, 2, 3) // 不常用该方法
```

### 1.3.2 字符串

```javascript
consloe.log(`dsad
dasda
asds`)  // 采用反引号支持换行

// 模板字符串


var name = '小明';
var age = 20;
// 方法一:
var message = '你好, ' + name + ', 你今年' + age + '岁了!';

// 方法二(ES6语法):
var message = `你好, ${name}, 你今年${age}岁了!`;


// 操作字符串

var b = "hello_world!"

b.length; // 12
```

### 1.3.3 字符串方法

```javascript
// 变成大写 toUpperCase
var s = 'Hello';
s.toUpperCase(); // 返回'HELLO'


// 变成小写 toLowerCase
var s = 'Hello';
var lower = s.toLowerCase(); // 返回'hello'并赋值给变量lower
lower; // 'hello'
```

## 1.4 运算符

- 算术运算符：+(加)、-(减)、*(乘)、/(除)、%(求余)
- 赋值运算符：=、+=、-=、*=、/=、%=、++
- 条件运算符：==、===、>、>=、<、<=、!=
- 逻辑运算符：&&(而且)、||(或者)、!(否)


- 第一种是 `==` 比较，它会自动转换数据类型再比较，很多时候，会得到非常诡异的结果；

- 第二种是 `===` 比较，它不会自动转换数据类型，如果数据类型不一致，返回false，如果一致，再比较。

```javascript
// 如果需要对浮点数进行对比
Math.abs(1 / 3 - (1 - 2 / 3)) < 0.0000001; // true
```

## 1.5 条件语句

### 1.5.1 if条件语句

```javascript
if(a > 10){
    console.log("a大于10");
}else if(a < 1){
    console.log("a小于1")
}else{
    console.log("a小于10 大于1")
}
```

### 1.5.2 switch表达式


计算一次 switch表达式
把表达式的值与每个case的值进行对比
如果存在匹配，则执行关联代码
遇到break 关键词，它会跳出switch代码块。
case 匹配不存在时，运行default的代码：


```javascript
switch(a+b){
    case c:
        console.log("等于c")
        break
    case b:
        console.log("等于b")
        break
    case d:
        console.log("等于d")
        break
    default:
        console.log("都不是")
}
```

## 1.6 函数

```javascript
// 命名函数
function func(var1, var2){
    console.log(var1);
    console.log(var2);
}

res = func(1, 3);

// 匿名函数
let func = function(var1, var2){
    console.log(var1);
    console.log(var2) ;
}
res = func(1, 3);
```

### call()
call()、apply()、bind() 都是用来重定义 this 这个对象的！


- 调用函数对象的call方法时，会调用函数对象
- call方法的参数，会传递给this引用
```js
function func(name, age){
    console.log(name);
    console.log(age);
}

// call()的第一个参数会传递给this，call()还可以有其他参数，其他的实参，都会传递给函数对象的形参
func.call("this对象", "Tom", 20);  // Tom  20
```
```JS
var obj = {
    a: "Jack",
    b: 20,
    print(name, age){
        console.log(this.a);
        console.log(this.b);
        console.log("我的名字是:" + name);
        console.log("我的年龄是:" + age);
    }
}

var obj2 = {
    "a": "Tom",
    "b": 99
};
obj.print.call(obj2, "JOY", 66)  // Tom 99  我的名字是:JOY 我的年龄是:66
```
### apply()
与call()的用法大致相同, apply()只有两个形参
- 第一个形参接收的值会传递给this（这一点与call()相同）
- 第二个型参是一个数组，他接受函数对象的形参所封装成的数组
```js
function func(name, age){
    console.log(name);
    console.log(age);
}

func.apply("this", ["Jack", 100]);  // Jack  100   
```
```js
var obj = {
    a: "Jack",
    b: 20,
    print(name, age){
        console.log(this.a);
        console.log(this.b);
        console.log("我的名字是:" + name);
        console.log("我的年龄是:" + age);
    }
}

var obj2 = {
    "a": "Tom",
    "b": 99
};
var print = obj.print.apply(obj2, ["JACK", 999])  // Tom 99 我的名字是:JACK 我的年龄是:999
```
### bind()
bind与上面两个函数使用方法差不多,不过返回的是新的一个对象,需要进行调用
```js
var obj = {
    a: "Jack",
    b: 20,
    print(name, age){
        console.log(this.a);
        console.log(this.b);
        console.log("我的名字是:" + name);
        console.log("我的年龄是:" + age);
    }
}

var obj2 = {
    "a": "Tom",
    "b": 99
};
var print = obj.print.bind(obj2, "JACK", 2000);
print()  // Tom 99 我的名字是:JACK 我的年龄是:2000
```

## 1.7 对象
是一组由键-值组成的无序集合
- 方式一(不常用)： `objA = new object();`
- 方式二：类式于python中的字典， `var objA={};`

每个键又称为对象的属性, 对象方法:对象方法是作为属性来存储的函数。

```javascript
// 方法一
objA = new Object();

objA.name = "this is obja"
objA["age"] = 20
objA.func = function(var1, var2){
    alert(var1);
    alert(var2);
}

console.log(objA.name)
console.log(objA["age"])
objA.func("xixixi", "asjdasjdlk")

// 方法二

var objB = {
    name : "js",
    age : 18,
    func : function (var1, var2) {
        alert(var1);
        alert(var2);
        return 20000
    }

}

console.log(objB.age)
console.log(objB["name"])
gg = objB.func("haha", 12345)
```
### 语法缩写(es6)
#### 方法
```js
var obj = {
  foo: function() {
    /* code */
  },
  bar: function() {
    /* code */
  }
};

// 可以缩写为
var obj = {
  foo() {
    /* code */
  },
  bar() {
    /* code */
  }
};

```
#### 生成器
```js
// 用有属性名的语法定义方法（ES6之前）：
var obj2 = {
  g: function*() {
    var index = 0;
    while(true)
      yield index++;
  }
};

// 同一个方法，简写语法：
var obj2 = { 
  * g() {
    var index = 0;
    while(true)
      yield index++;
  }
};

var it = obj2.g();
console.log(it.next().value); // 0
console.log(it.next().value); // 1
```
#### 异步方法
```js
// 用有属性名的语法定义方法（ES6之前）：
var obj3 = {
  f: async function () {
    await some_promise;
  }
};

// 同一个方法，简写语法：
var obj3 = { 
  async f() {
    await some_promise;
  }
};
```
#### async生成器方法
```js
var obj4 = {
  f: async function* () {
    yield 1;
    yield 2;
    yield 3;
  }
};

// 简写
var obj4 = {
  async* f() {
   yield 1;
   yield 2;
   yield 3;
  }
};
```
#### 支持计算的属性名
```js
var obj5 = {
    name: "foo",
    ["foo" + "2"](){return 1}  // 仅支持拼接之类的
}

```

## 1.8 循环

### 1.8.1 while循环

```javascript
while (条件)
{
    需要执行的代码
}
```

```javascript
while(a<5){
    console.log("a小于5")
    a++
}
```

### 1.8.2 for循环

```javascript
for (语句 1; 语句 2; 语句 3)
{
    被执行的代码块
}
```

```javascript
for (var i=0;i<cars.length;i++)
{ 
    document.write(cars[i] + "<br>");
}
// 前置条件若已经声明 语句一可不写
var i=2,len=cars.length;
for (; i<len; i++)
{ 
    document.write(cars[i] + "<br>");
}
// 语句三 若已经在代码块中有相应代码 也可不写
var i=0,len=cars.length;
for (; i<len; )
{ 
    document.write(cars[i] + "<br>");
    i++;
}

// 遍历对象属性，得到的是属性名
var person={fname:"John",lname:"Doe",age:25}; 

for (x in person)  // x 为属性名
{
    txt=txt + person[x];
}

// 遍历数组
var aList = (1, 33, 55, 99);
for (y in aList){
    console.log(y)  // y 为数组下标
    a = aList[y]
}
```

## 箭头函数
- 当不需要多行表达式时,可以直接一行表示,省略`{}`和`return`
- 如果仅有一位参数时,支持无需`()`, 其他情况都要加括号(无参数也需要)
- 如果返回一个对象,且仅有一行表达式,则必须在对象外加括号
```js
var x = function(i, o){
    return i + o;
};
// 以下是箭头函数, 相当于
var x = (i, o) => {
    return i + o;
};
// 当不需要多行表达式时,可以直接一行表示,省略`{}`和`return`
var x = (i, o) => i + o;
```
```js
// 如果仅有一位参数时,支持无需`()`
i => i * i;
// 无参数,必须`()`
() => 123;
// 返回一个对象
i => ({"name": i})
```
## this
箭头函数内部的this是词法作用域，由上下文确定, this总是指向词法作用域，也就是外层调用者

```js
var obj = {
    birth: 1990;
    getAge: function(){
        var b = this.birth; // 1990
        var fn = () => new Date().getFullYear() - this.birth;
        return fn()
    }
}
obj.getAge()
```
```js
var obj = {
    birth: 1990,
    c: console.log(this);  // window
    getAge: function (year) {
        console.log(this);  // obj
        console.log(year);
        var b = this.birth;
        var fn = y => y - this.birth;
        return fn.call({birth:2000}, year)
    }
};
var b = obj.getAge(2015); // 25
console.log(b)
```
为何上面这个getAge对象无法写成箭头函数, 因为在箭头函数中this总是指向词法作用域
```js
// 
var obj = {
    birth: 1990,
    c: console.log(this);  // window
    getAge: year => {
        console.log(this);  // window, 作用域还是在window
        console.log(year);  // 2015
        var b = this.birth;
        console.log(b);  // undefined
        var fn = y => y - this.birth;
        console.log(fn(year));  // NaN
        return fn.call({birth:2000}, year);
    }
};
var b = obj.getAge(2015);
console.log(b)  // NaN
```
```js
var obj = {
    birth: 1990,
    c: console.log(this),  // window
    getAge(year){
        console.log(this);  // obj
        console.log(year);  // 2015
        var b = this.birth;
        console.log(b);  // 1990
        var fn = y => y - this.birth;
        console.log(fn(year));  // 25
        return fn.call({birth:2000}, year);
    }
};
var b = obj.getAge(2015); // 25
console.log(b);  // 25
```
### 实例
```js
function multiply(a, b) {
    if (b === undefined) {  // 当b为空时,返回一个函数
        return function (b) {
            return a * b;
        }
    }
    return a * b;
}

const double = multiply(2);
double(3); // => 6  // 调用内部的函数
multiply(2, 3); // => 6


// 用箭头函数表达
const multiply = (a, b) => b === undefined ? b => a * b : a * b;
const double = multiply(2);
double(3);      // => 6
multiply(2, 3); // => 6
```

## 三元运算符
格式: 条件?真结果:假结果
```js
var a = 30
var b = a>50?1:-1
console.log(b) // -1


var c = ""
var d = ""
a>50?(c="a大于50", d=true):(c="a小于50", d=false)  // 多行表达式
console.log(c)  // a小于50
console.log(d)  // false

// 支持多重嵌套
a>50?(a>100?(c="a大于100", d=true):(c="a大于50小于100", d=true)):(a>25?(c="a大于25小于50", d=false): (c="a小于25", d=false))
console.log(c)  // a大于25小于50
console.log(d)  // false
```

# 2. JS操作页面(原生)

- 通过HTMLDOM，可访问JavaScript HTML文档的所有元素。
- 当网页被加载时，浏览器会创建页面的文档对象模型(Document Object Model)。
- HTMLDOM模型被构造为对象的树。


![HTML DOM树](./images/DOM树.png)


节点树中的节点彼此拥有层级关系。
- 父(parent)、子(child)和同胞(sibling)等术语用于描述这些关系。
- 父节点拥有子节点。同级的子节点被称为同胞(兄弟或姐妹)


## 2.1 获取页面标签


获取标签的方式
- 通常，通过JavaScript操作HTML元素，可以使用内置对象document的方法来找到该标签
- 通过id 找到HTML元素(常用)  document.getElementByld()
- 通过标签名找到HTML元素  getElementsByTagName()  获取出来的是列表
- 通过类名找到HTML元素(通过类名查找HTML元素在IE5，6，7，8中无效) getElementsByClassName()  取出来的是列表


```javascript
var id = document.getElementById("project_site");
console.log(id);

var cls = document.getElementsByClassName("project_title");
console.log(cls);
console.log(cls[0]);

var tag = document.getElementsByTagName("p");
console.log(tag);
console.log(tag[0]);
```

## 2.2 操作标签内容

```javascript
var tag = document.getElementsByTagName("p");

var tag_0 = tag[0].innerText;
console.log(tag_0);
tag[0].innerText = "哈哈哈哈";
console.log(tag[1].innerHTML)
tag[1].innerHTML = "<h1>嘻嘻嘻</h1>"
```

## 2.3 修改标签属性

```javascript
var tag = document.getElementsByTagName("p");

tag[0].style.height = "300px";
```

## 2.4. onclick事件


# 3.内部函数
## 数组排序
对数组的引用。请注意，数组在原数组上进行排序，不生成副本。

如果调用该方法时没有使用参数，将按字母顺序对数组中的元素进行排序，说得更精确点，是按照字符编码的顺序进行排序。要实现这一点，首先应把数组的元素都转换成字符串（如有必要），以便进行比较。

如果想按照其他标准进行排序，就需要提供比较函数，该函数要比较两个值，然后返回一个用于说明这两个值的相对顺序的数字。比较函数应该具有两个参数 a 和 b，其返回值如下：

- 若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值。
- 若 a 等于 b，则返回 0。
- 若 a 大于 b，则返回一个大于 0 的值。

### 排序字母
```js
var str = ["abd", "bda", "abc", "xdg", "pjg"];
str.sort();
console.log(str);  // ["abc", "abd", "bda", "pjg", "xdg"]
```
### 排序数字
```js
var arr = [10, 55, 2, 333];
var fn = (x,y) => {
    return x>y?1:-1;
};
arr.sort(fn);
console.log(arr);  // [2, 10, 55, 333]
```