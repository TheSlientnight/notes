# 入门
## 管理命令
- `pip install -U pytest`: 安装pytest
- `pytest -V`: 查看pytest版本
- `pytest -h`: 显示命令行及配置文件选项帮助信息
- `pytest --fixtures`: 显示可用的内置方法参数
- `pytest --cache-show`: 查看缓存
- `pytest --collect-only`: 显示用例ID

## 运行命令
- `pytest`: 会执行当前目录及子目录下所有符合发现标准的文件
- `pytest test_sample.py`: 指定模块运行
- `pytest testing/`: 指定目录
参数
- `-q` 静默模式 
    - ex: `pytest -q test_sample.py`
- `s`: 输出程序输出
- `v`: 详细模式
- `-x`: 第1次失败后停止
    - ex: `pytest -x`
- `--maxfail=n`: 第n次失败后停止
    - ex: `pytest --maxfail=3`
- `-k 'expression'`: 运行表达式匹配的用例,包括文件名,类名,函数名作为变量,支持 ython运算符(`and`和`or`) 运算符
    - ex: `pytest -k "MyClass and not method"` 运行含有 `"MyClass"`的文件名,类名,函数名, 不运行含有`method`的文件名,类名,函数名.例如:将运行`TestMyClass.test_something`但不运行`TestMyClass.test_method_simple`
- `pytest modular::Class::function`按节点id(nodeid)运行: 模块名::类名::函数名::参数
    - ex: `pytest test_sample.py::test_answer` 运行`test_sample.py`模块内的`test_answer`用例
    ```py
    def func(n):
        return n+1


    def test_answer(): # 只会运行这个
        assert func(3) == 5


    class TestDemo:
        def test_answer(self):
            assert func(3) == 5
    ```

### 标记运行

- `pytest -m mark`: 通过标记(mark)运行
    - ex: `pytest -m smoke` 运行所有带有`@pytest.mark.smoke`装饰器的用例
    ```py
    @pytest.mark.smoke
    class TestDemo:
        def test_answer(self):
            assert func(3) == 5
    ```

### 指定状态摘要

- `pytest -r`: 指定状态结果摘要(short test summary info) 有的话会显示,如果没有的话完全不显示
    - `pytest -ra`: 除了执行通过(Pass)以外所有的结果
    - `pytest -rf`: 失败的用例
    - `pytest -rE`: 出错的用例
    - `pytest -rs`: 跳过的用例
    - `pytest -rx`: 标记失败的用例
    - `pytest -rX`: 标记成功的用例
    - `pytest -rp`: 成功用例
    - `pytest -rP`: 成功用例并输出信息

也可以进行组合
    - ex: `pytest -rfs` 只查看失败和跳过的用例

- `--durations=n`: 显示执行最慢的n条用例
    - 默认情况下不展示<0.005的用例, 使用`-vv`可开启 ex: `--durations=n -vv`

### 根据结果重运行
同状态按文件修改时间排序, 最新的文件首先出现
- `pytest --lf` or `pytest --last-failed`: 只重新运行故障
- `pytest --ff` or `pytest --failed-first`: 先运行故障然后再运行其余的测试
- `pytest --nf` or `pytest --new-first`: 首先运行新的测试,然后是其余的测试
```py
import pytest

@pytest.mark.parametrize("i",range(50))
def test_num(i):
    if i in (17,25):
       pytest.fail("bad luck")
```

## 原生报告
pytest原生支持三种类型的报告
1. xml文件 
2. log 
3. html

脚本中：
```py
# path 为存放路径
pytest.main("--junitxml=path", "--resultlog=path", "--html=path")
```
命令行：
```shell
pytest --junitxml=path --resultlog=path --html=path
# path 为存放路径
```

## 退出code
- exit code 0: 收集并成功通过所有测试用例
- exit code 1: 收集并运行了测试,部分测试用例执行失败
- exit code 2: 测试执行被用户中断
- exit code 3: 执行测试中发生内部错误
- exit code 4: pytest命令行使用错误
- exit code 5: 没有收集到测试用例

## 用例发现规则
1. file name：`test_*.py` 或者 `*test.py`
2. class name：`Test*` 且类内没有 `__init__` 函数
3. function name: `test_*`

ex:
```py
# test_sample.py

def func(x):
    return x + 1

def test_answer():
    assert func(3) == 5

class TestDemo:

    def test_answer():
        assert func(3) == 4

```
```sh
dev012@dev012:~/workspace/demo$ pytest
========== test session starts ===========
platform linux -- Python 3.7.5, pytest-6.1.2, py-1.9.0, pluggy-0.13.1
rootdir: /home/dev012/workspace/demo
plugins: allure-pytest-2.8.6
collected 2 items

test_sample.py .F                          [100%]

================ FAILURES ================
__________ TestDemo.test_answer __________

self = <test_sample.TestDemo object at 0x7fdb41554e10>

    def test_answer(self):
>       assert func(3) == 5
E       assert 4 == 5
E        +  where 4 = func(3)

test_sample.py:11: AssertionError
======== short test summary info =========
FAILED test_sample.py::TestDemo::test_answer - assert 4 == 5
====== 1 failed, 1 passed in 0.02s =======
```

## 缓存
- 设置缓存: `request.config.cache.set("缓存名", 值)`
- 读取缓存: `request.config.cache.get("缓存名", 默认值)`

```py
@pytest.fixture
def mydata(request):
    val = request.config.cache.get("example/value", None)  # 读取缓存
    if val is None:
        val = "=========42==========="
        request.config.cache.set("example/value", "================")  # 写入缓存
        request.config.cache.set("example/value", val)  # 键值对形式会update成最新的值
        print("running expensive computation...")
    return val
```

命令行: 
- `pytest --cache-show`: 查看缓存
- `pytest --cache-clear`: 清除所有缓存文件和值

缓存中只要运行过用例,未清除的情况下一定会有:上次失败的用例,运行过的用例id

outputs:
```
========================= test session starts ==========================
platform linux -- Python 3.7.5, pytest-6.1.2, py-1.9.0, pluggy-0.13.1
rootdir: /home/qydev012/workspace/demo
plugins: allure-pytest-2.8.6
cachedir: /home/qydev012/workspace/demo/.pytest_cache
----------------------------------------------------- cache values for '*' -----------------------------------------------------
cache/lastfailed contains:
  {'conftest.py::test_function': True,
   'test_foocompare.py::test_compare': True,
   'test_sample.py::TestDemo': True,
   'test_sample.py::TestDemo::test_answer': True,
   'test_sample.py::test_has_atter': True}
cache/nodeids contains:
  ['conftest.py::test_function',
   'test_foocompare.py::test_compare',
   'test_sample.py::TestDemo::test_answer',
   'test_sample.py::TestDemo::test_one[1]',
   'test_sample.py::TestDemo::test_one[2]',
   'test_sample.py::test_module[mod1]',
   'test_sample.py::test_module[mod2]',
   'test_sample.py::test_needsfiles',
   'test_sample.py::test_valid_string[hello]',
   'test_sample.py::test_valid_string[stringinput0]',
   'test_sample.py::test_valid_string[world]']
cache/stepwise contains:
  []
example/value contains:
  '========2========'

======================== no tests ran in 0.01s =======================
```

# 语法
## 断言 assert

### assert 断言

自定义断言失败消息,但将不会显示断言失败的具体对比信息
```py
def test_in():
    x = "this"
    assert "h" in x, "断言消息"
```

### pytest.raises异常断言
见[函数](#pytest.raises-异常断言)

### 万物都可做断言
```py

# in
def test_in():
    x = "this"
    assert "h" in x

# hasattr
def test_has_atter():
    x = "hello"
    print(hasattr(str, x))
    assert hasattr(str, x)
```



## 3. 夹具 fixture
fixture发现顺序: 从测试类开始,然后是测试模块,然后是`conftest.py`文件,最后是内置和第三方插件

fixture放置位置: 可放在测试模块内,也可以放在conftest内.在conftest模块内,同级及下级目录的测试模块都可以访问
### 1. 参数介绍
```python
@pytest.fixture(scope, params, autouse, ids, name)  # 因为都是关键字参数，所以使用时务必指定传参
```
- `scope`: 可选参数:`function`(函数),`class`(类),`module`(模块),`package`(包)及 `session`(会话(一次运行算一次会话)), 默认为`function`级别
- `params`: 可以传入列表参数，进行数据驱动测试
- `autouse`: 是否自动使用该前后置条件
    - autouse fixtures服从scope=关键字参数:如果autouse fixture具有scope='session'它,它将只运行一次,无论它在何处定义。scope='class'意味着它将每班运行一次,等等。
    - 如果在测试模块中定义了autouse fixture,则其所有测试函数都会自动使用它。
    - 如果在conftest.py文件中定义了autouse fixture,那么其目录下所有测试模块中的所有测试都将调用fixture。
- `ids`: 字符串id
- `name`: 装饰器的引用名字, 默认为装饰函数的名称

ex:
```py
# yield
@pytest.fixture(scope="module", params=["1", "2"])  # 使用params将运行 len(params) 次
def init_driver(request):
    print("这是个模块级的前置条件")
    print(request.param)  # 使用params的参数
    # 以上是setup
    yield driver
    # 以下是 teardown
    print("这是个模块级的后置条件")
```

### 2. 自定义fixture方法

#### 1. fixture的代码结构
1. 使用`yield`, 若fixture函数在setup时(yield之前)发生异常,则不会调用teardown代码(在yield之后)
2. [使用`addfinalizer`函数注册teardown函数](#request)
    - 可以注册多个teardown函数
    - 无论fixture中setup代码是否异常,始终会调用注册的teardown
    - 如果在执行`addfinalizer`之前发生异常,则一样不会被执行

```py
# addfinalizer
@pytest.fixture
def smtp_connection(request):
    smtp_connection = smtplib.SMTP("smtp.gmail.com",587,timeout=5)
        def fin():  # teardown
            print("teardown smtp_connection")
            smtp_connection.close()
    request.addfinalizer(fin)
    return smtp_connection
```



#### 2. fixture的引用&传参
- 如果需要当参数使用,可以直接在函数()中写入要引用的函数名
- 否则的话可以使用装饰器`@pytest.mark.usefixtrue("引用的fixtrue方法名")`
- 支持多重使用

直接使用
```python
@pytest.fixture()
def default_fixture(init_driver): # 同模块直接使用函数名
    print("这是个用例级的前置条件")
    yield init_driver
    print("这是个用例级的后置条件")
```

使用装饰器(模块必须在`conftest.py`模块的同级目录或下级目录)
```py
@pytest.mark.usefixtures("down")
def test_answer():  # match 可选,支持正则表达式匹配错误信息
    with pytest.raises(ValueError, match=r'.* 123 .*') as e:  # 在此处上下文中出现预期异常,异常将被捕获不会被抛出,断言成功
        func()
```

- fixture函数的传参要放置在生成器 `yield` 后
- 测试用例要使用参数时在函数()中当参数一样填入用例名即可，如果yield后面没有值即返回为 None
    
```python
@pytest.mark.usefixture("default_fixture")
class TestLogin:

    def test_login_success(self, default_fixture):
        lp(init_driver).login(ld.success_data["account"], ld.success_data["password"])
        title = mp(init_driver).get_my_order_title()
        assert ld.success_data["title"] in title
```

#### 3. fixture的工厂方法
为便于一个测试内需要多次使用参数,直接将方法传入
```py
@pytest.fixture
def make_customer_record():
    created_records = []

    def _make_customer_record(name):
        record = models.Customer(name=name,orders=[])
        created_records.append(record)
        return record

    yield _make_customer_record

    for record in created_records:
        record.destroy()

def test_customer_records(make_customer_record):
    customer_1 = make_customer_record("Lisa")
    customer_2 = make_customer_record("Mike")
    customer_3 = make_customer_record("Meredith")
```

#### 4. request对象内省参数
request对象内省“请求”测试函数,类或模块上下文
```py
# conftest.py
import pytest

@pytest.fixture()
def down(request):
    num = getattr(request.module, "num", "default")
    yield num
    print(num)
```
```py
# test_demo.py

num = 20  # 提取模块中num的vlaue

def test_demo(down):
    print(down)
```

#### 5. `pytest.fixture`参数化
`pytest.fixture(params=["param1", "param1", ....], ids=["id1", "id2", ....])`
- 传入params的参数长度有多少便运行多少次(含fixture函数, 关联用例及其他依赖)
- ids用于自定义用例的ID,可用`-k` 指定运行用例,若返回值为`none`则使用pytest自动生成的ID
- 只支持单个参数
- `pytest --collect-only`: 显示用例ID

单参数 ex:
```py
# test_demo.py
import pytest

@pytest.fixture(params=["第一组数据", "第一组数据"], ids=["one", "two"])  # 运行两次
def demo_single_fixture(request):
    print(request.param)

def test_fixture(demo_single_fixture):
    pass


# outputs:
# <Module test_demo.py>
#   <Function test_fixture[one]>
#   <Function test_fixture[two]>
```

`ids`也可以调用函数生成ID

ex:
```py
def idfn(fixture_value):  # 调用时会将当前fixture_value传入
    if fixture_value == 0:
        return "eggs"
    else:
        return None

@pytest.fixture(params=[0,1],ids=idfn)
def b(request):
    return request.param

def test_b(b):
    pass

#outputs:
# <Module test_demo.py>
#   <Function test_b[eggs]>
#   <Function test_b[1]>
```

多参数 ex: (fixture参数化只支持单参数,但可以用二维数组进行二次解析)
1. `pytest.fixture(params=[[], (), (), ...])`: 
    支持列表元组二维混嵌, 一维为次数, 二维为参数

```py
# test_demo.py
import pytest


@pytest.fixture(params=[(1, 2), [3, 4], (4, 5)])
def demo_many_fixture(request):  # 在fixture函数中使用组合参数并不会如parametrize中可设置解析
    print(request.param)


def test_demo(demo_many_fixture):
    pass


# outputs:
# (1, 2)
# [3, 4]
# (4, 5)
```

2. `pytest.fixture(params=(pytest.param(*values, marks=marks, id=id),))`

tips: 如果要使用该模式需要将`pytest.param()`用元组或列表嵌套起来.否则params会运行三次,一次value,一次marks,一次id
```py
# test_demo.py
import pytest


@pytest.fixture(params=[1, 2, pytest.param(2, marks=pytest.mark.skip), pytest.param(5)])  # 跳过第三个测试
def fixture_demo(request):
    # print(pytest.param(1))  # ParameterSet(values=(1,), marks=(), id=None)
    print(request.param, "=================")


def test_demo(fixture_demo):
    pass


# outputs:
# <Module test_sample.py>
#   <Function test_demo[1]>
#   <Function test_demo[2]>
#   <Function test_demo[xixixi]>  skip
#   <Function test_demo[5]>
# 3 passed, 1 skipped in 0.00s
```

#### 6. fixture调用运行顺序
- 较高范围的fixture(例如`session`会话级) 较 低范围的fixture(例如`function`函数级或`class`类级)优先执行。
- 相同范围的fixture对象的按引入的顺序及fixtures之间的依赖关系按顺序调用

```py
@pytest.fixture(scope="session")
def s1():
    pass

@pytest.fixture(scope="module")
def m1():
    pass

@pytest.fixture
def f1(tmpdir):
    pass

@pytest.fixture
def f2():
    pass

def test_foo(f1,m1,f2,s1):
    pass

# 范围层面: s1 > m1 > f1 = f2
# 引用层面: f1 > f2
# 依赖层面: tmpdir > f1
# 故 运行顺序:  s1 > m1 > tmpdir > f1 > f2
```
1. s1:是最高范围的fixture(会话级)
2. m1:是第二高的fixture(模块级)
3. tmpdir:是一个函数级的fixture,f1依赖它,因此它需要在f1前调用
4. f1:是test_foo参数列表中第一个函数范围的fixture。
5. f2:是test_foo参数列表中最后一个函数范围的fixture。

多重装饰使用时pytest依旧采取最小活动范围的策略
```py
@pytest.mark.usefixture("1")
@pytest.mark.usefixture("2", "3")
def test_demo():
    pass
```

#### 7. fixture运行顺序实例

运行ex:
```py
import pytest


@pytest.fixture(scope="module", params=["mod1", "mod2"])
def modarg(request):
    param = request.param
    print("  模块级前置 %s" % param)
    yield param
    print("  模块级后置 %s" % param)


@pytest.fixture(scope="function", params=[1, 2])
def otherarg(request):
    param = request.param
    print("  函数级前置 %s" % param)
    yield param
    print("  函数级后置 %s" % param)


def test_function(otherarg):
    print("  RUN function fixture %s" % otherarg)


def test_module(modarg):
    print("  RUN module fixture %s" % modarg)


def test_func_module(otherarg, modarg):
    print("  RUN func_module with function %s and module %s" % (otherarg, modarg))
```
outputs:
```py
test_sample.py::test_function[1]   函数级前置 1
  RUN function fixture 1
PASSED  函数级后置 1

test_sample.py::test_function[2]   函数级前置 2
  RUN function fixture 2
PASSED  函数级后置 2

test_sample.py::test_module[mod1]   模块级前置 mod1
  RUN module fixture mod1
PASSED
test_sample.py::test_func_module[mod1-1]   函数级前置 1
  RUN func_module with function 1 and module mod1
PASSED  函数级后置 1

test_sample.py::test_func_module[mod1-2]   函数级前置 2
  RUN func_module with function 2 and module mod1
PASSED  函数级后置 2

test_sample.py::test_module[mod2]   模块级后置 mod1
  模块级前置 mod2
  RUN module fixture mod2
PASSED
test_sample.py::test_func_module[mod2-1]   函数级前置 1
  RUN func_module with function 1 and module mod2
PASSED  函数级后置 1

test_sample.py::test_func_module[mod2-2]   函数级前置 2
  RUN func_module with function 2 and module mod2
PASSED  函数级后置 2
  模块级后置 mod2
```
总结:
- session(会话)级fixture 将最先运行前置,最后运行后置.同级间看调用先后
- module(模块)级fixture 会在运行关联的每个模块前运行前置,每个模块后运行后置
- class(类)会在运行关联的每个类前运行前置,每个类后运行后置


#### 8. conftest.py 作用域
`conftest.py`文件的作用域是 文件当前目录层级及当前目录更低的所有层级

conftest.py文件建议放在python包中(含``__init__.py`),否则将无法导包

#### 9. fixture函数重写
1. 跨文件夹重写

基础/上级fixtures方法可以被子文件夹下的conftest.py中同名的fixtures方法覆盖

```py
tests/
    __init__.py

    conftest.py
        # content of tests/conftest.py
        import pytest

        @pytest.fixture
        def username():
            return 'username'

    test_something.py
        # content of tests/test_something.py
        def test_username(username):
            assert username == 'username'

    subfolder/
        __init__.py

        conftest.py
            # content of tests/subfolder/conftest.py
            import pytest

            @pytest.fixture
            def username(username):  # 覆盖并使用
                return 'overridden-' + username

        test_something.py
            # content of tests/subfolder/test_something.py
            def test_username(username):
                assert username == 'overridden-username'
```

2. 跨模块重写

用例模块(文件)中的fixture方法可以覆盖文件夹conftest.py中同名的fixtures方法

```py
tests/
    __init__.py

    conftest.py
        # content of tests/conftest.py
        @pytest.fixture
        def username():
            return 'username'

    test_something.py
        # content of tests/test_something.py
        import pytest

        @pytest.fixture
        def username(username):
            return 'overridden-' + username

        def test_username(username):
            assert username == 'overridden-username'

    test_something_else.py
        # content of tests/test_something_else.py
        import pytest

        @pytest.fixture
        def username(username):
            return 'overridden-else-' + username

        def test_username(username):
            assert username == 'overridden-else-username'
```

3. 参数化方法中覆盖fixtures方法

参数化内参数优先级更高
```py
tests/
    __init__.py

    conftest.py
        # content of tests/conftest.py
        import pytest

        @pytest.fixture
        def username():
            return 'username'

        @pytest.fixture
        def other_username(username):
            return 'other-' + username

    test_something.py
        # content of tests/test_something.py
        import pytest

        @pytest.mark.parametrize('username',['directly-overridden-username'])
        def test_username(username):
            assert username == 'directly-overridden-username'

        @pytest.mark.parametrize('username',['directly-overridden-username-other'])
        def test_username_other(other_username):
            assert other_username == 'other-directly-overridden-username-other'
```

4. 重写作用域

作用域仅限于重写后的作用域
- 子文件内 `conftest.py`重写作用于: 同级及文件下级
- 模块内重写: 当前模块
- 类级重写: 当前类

```py
tests/
    __init__.py

    conftest.py
        # content of tests/conftest.py
        import pytest

        @pytest.fixture(params=['one','two','three'])
        def parametrized_username(request):
            return request.param

        @pytest.fixture
        def non_parametrized_username(request):
            return 'username'

    test_something.py
        # content of tests/test_something.py
        import pytest

        @pytest.fixture
        def parametrized_username():  # 模块级重写
            return 'overridden-username'

        @pytest.fixture(params=['one','two','three'])
        def non_parametrized_username(request):
            return request.param

        def test_username(parametrized_username):  # 调用的是同模块的函数
            assert parametrized_username == 'overridden-username'

        def test_parametrized_username(non_parametrized_username):
            assert non_parametrized_username in ['one','two','three']

    test_something_else.py
        # content of tests/test_something_else.py
        def test_username(parametrized_username):  # 调用conftest.py文件的函数
            assert parametrized_username in ['one','two','three']

        def test_username(non_parametrized_username):
            assert non_parametrized_username == 'username'
```

### 3. 内置fixture方法

#### 1. tmp_path  临时目录和文件
在临时目录根目录中创建一个独立的临时目录以供测试调用

ex:
```py
CONTENT = u"content"


def test_create_file(tmp_path):
    d = tmp_path / "sub"
    print(d)  # /tmp/pytest-of-dev012/pytest-11/test_create_file0/sub
    d.mkdir()
    p = d / "hello.txt"
    p.write_text(CONTENT)
    assert p.read_text() == CONTENT
    assert len(list(tmp_path.iterdir())) == 1
```

#### 2. tmpdir_factory 
是一个session范围的fixture,可用于从任何其他测试用例及fixture中创建任意临时目录

ex:
```py
# conftest.py文件内容
import pytest


@pytest.fixture(scope="session")
def image_file(tmpdir_factory):
    img = compute_expensive_image()
    fn = tmpdir_factory.mktemp("data").join("img.png")
    img.save(str(fn))
    return fn


# contents of test_image.py
def test_histogram(image_file):
    img = load_image(image_file)
    # 计算和测试histogram
```
## 7. 用例执行顺序

安装：
```shell
    pip install pytest-ordering
```

使用：
```python
    @pytest.mark.run(order=1) # 仅支持装饰function
    def func():
       pass
```
-- --




## 1. 函数 function
### pytest.approx 浮点比较
```py
from pytest import approx

0.1 + 0.2 == approx

(0.1 + 0.2,0.2 + 0.4) == approx((0.3,0.6))  # 元组

{'a': 0.1 + 0.2,'b': 0.2 + 0.4} == approx({'a': 0.3,'b': 0.6})  # 字典

1.0001 == approx(1,rel=1e-3)  # 相对容差

1.0001 == approx(1,abs=1e-3)  # 绝对容差
```

### pytest.fail 设置用例为失败状态

`fail(msg='', pytrace=True)`: 使用给定消息显式地设置用例为失败状态

### pytest.skip 设置跳过测试用例

`skip(msg[, allow_module_level=False])`: 使用给定消息跳过测试用例
- allow_module_level(bool) - 允许在模块级别调用此函数,跳过模块的其余部分。默认为False。

### pytest.importorskip 导入模块/跳过
如果无法导入模块,则跳过当前测试

`importorskip(modname, minversion=None, reason=None)`: 导入并返回请求的模块modname,或者如果无法导入模块,则跳过当前测试
- modname(str) - 要导入的模块的名称
- minversion(str) - 如果给定,导入的模块__version__属性必须至少为此最小版本,否则仍会跳过测试。
- reason(str) - 如果给定,则无法导入模块时,此原因显示为消息。

### pytest.xfail 强制标记失败用例/准备函数
只能在测试函数, setup函数或teardown函数中使用此函数

`xfail(reason='')`: 由于给定的原因,强制标记失败测试用例或测试准备函数

### pytest.exit 退出测试过程
`exit(msg, returncode=None)`: 退出测试过程。
- msg(str) - 退出时显示的消息。
- returncode(int) - 返回退出pytest时使用的代码。

### pytest.main 执行进程
`main(args=None, plugins=None)`: 执行进程内测试运行后返回退出代码
- args- 命令行参数列表。
- plugins- 初始化期间要自动注册的插件对象列表。

### pytest.param 指定参数
`param(*values[, id][, marks])`: 在[pytest.mark.parametrize指定参数
- values- 按顺序的参数集值的变量args。
- 标记- 要应用于此参数集的单个标记或标记列表。
- id(str) - 属于此参数集的id。

```py
@pytest.mark.parametrize("test_input,expected",
    [
        ("3+5",8), 
        pytest.param("6*9",42,marks=pytest.mark.xfail), 
    ])
def test_eval(test_input,expected):
    assert eval(test_input) == expected

```

```py
import pytest
import sys

@pytest.mark.parametrize(
    ("n","expected"),
    [
        (1,2),
        pytest.param(1,0,marks=pytest.mark.xfail),
        pytest.param(1,3,marks=pytest.mark.xfail(reason="某个bug")),
        (2,3),
        (3,4),
        (4,5),
        pytest.param(
            10,11,marks=pytest.mark.skipif(sys.version_info >= (3,0),reason="py2k")
        ),
    ],
)
def test_increment(n,expected):
    assert n + 1 == expected
```


### pytest.raises 异常断言
`with raises(expected_exception: Exception[, match][, message]) as excinfo`:断言代码块/函数调用会引发expected_exception或引发失败异常。
- match- 如果指定,则断言异常与text或regex匹配

在上下文中出现预期异常,异常将被捕获不会被抛出,断言成功
```py
import pytest


def func():
    raise ValueError("test Exception 123 raised")


# @pytest.mark.xfail(raises=RuntimeError)
def test_answer():  # match 可选,支持正则表达式匹配错误信息
    with pytest.raises(ValueError, match=r'.* 123 .*') as e:  # 在此处上下文中出现预期异常,异常将被捕获不会被抛出,断言成功
        func()
    print("==============")
    print(e.value)  # 错误的msg
    print(e.type)  # 错误类型
    print(e.traceback)  # 错误溯源

```

## 2. Marks(标记)

### 1. `pytest.mark.filterwarnings` 警告过滤器
`pytest.mark.filterwarnings(filter)`

### 2. `pytest.mark.parametrize` 参数化
`@pytest.mark.parametrize(argnames,argvalues,indirect = False,ids = None,scope = None)`
- argnames- 以逗号分隔的字符串,表示一个或多个参数名称,或参数字符串的列表/元组。
- argvalues-argvalues列表确定使用不同参数值调用测试的频率。如果只指定了一个argname,则argvalues是值列表。如果指定了N个argnames,则argvalues必须是N元组的列表,其中每个tuple-element为其各自的argname指定一个值。
- indirect- argnames或boolean的列表。参数列表名称(argnames的子集)。如果为True,则列表包含argnames中的所有名称。对应于此列表中的argname的每个argvalue将作为request.param传递到其各自的argname fixture函数,以便它可以在测试的设置阶段而不是在收集时执行更昂贵的设置。
- ids- 字符串ID列表或可调用的列表。如果字符串,则每个字符串对应于argvalues,以便它们是测试ID的一部分。如果将None作为特定测试的id给出,则将使用该参数的自动生成的id。如果是可调用的,它应该采用一个参数(单个argvalue)并返回一个字符串或返回None。如果为None,将使用该参数的自动生成的id。如果没有提供id,它们将自动从argvalues生成。
- scope- 如果指定,则表示参数的范围。范围用于按参数实例对测试进行分组。它还将覆盖任何fixture函数定义的范围,允许使用测试上下文或配置设置动态范围。

```python
@pytest.mark.parametrize("test_input,expected",[("3+5",8),("2+4",6),("6*9",42)])
def test_eval(test_input,expected):
    assert eval(test_input) == expected
```

两组及以上参数化时,pytest会进行一一匹配.
- 将运行与设定参数的测试 x=0/y=2,x=1/y=2,x=0/y=3,x=1/y=3 四次测试

```py
import pytest

@pytest.mark.parametrize("x",[0,1])
@pytest.mark.parametrize("y",[2,3])
def test_foo(x,y):
    pass
```

- [也可基于pytest_generate_tests钩子函数在collecting阶段就进行参数化](#pytest_generate_tests-自定义生成用例)

#### 1. 参数化显示中文

```ini
[pytest]
disable_test_id_escaping_and_forfeit_all_rights_to_community_support = True
```

#### 2. 参数化标记
见[pytest.param 指定参数](#pytest.param-指定参数)

### 3. `pytest.mark.skip` 跳过测试函数

`pytest.mark.skip(*,reason = None)`: 无条件地跳过测试函数
- reason(str) - 跳过测试函数的原因

```py
@pytest.mark.skip(reason="目前没办法测试该用例")
def test_the_unknown():
    pass

# 常用于导入时间内无法评估跳过条件
def test_function():
    if not valid_config():
        pytest.skip("不支持该配置")
```

模块级跳过(使用此方法跳过整个模块时会抛出Skipped异常，如果在脚本下方使用pytest.main()执行，会执行不到。此时应使用命令行pytest命令执行)
```py
import sys
import pytest

if not sys.platform.startswith("win"):
    pytest.skip("跳过只支持Windows平台的用例", allow_module_level=True)
```

### 4. `pytest.mark.skipif` 条件跳过测试函数
`pytest.mark.skipif(condition,*,reason=无)`
- condition(bool)。
- reason(str) - 跳过测试函数的原因。

```py
import pytest

@pytest.mark.skipif(sys.version_info<(3,6),reason="需要Python3.6版本以上")
def test_function():
    pass
```

```py
@pytest.mark.skipif(sys.platform=="win32",reason="不在Windows系统运行")
class TestPosixCalls(object):
    def test_function(self):  # 若跳过成立,类中每个用例都跳过
        pass
```


支持共享标记
```py
import mymodule

minversion = pytest.mark.skipif(
    mymodule.__versioninfo__ < (1,1),reason="至少mymodule-1.1版本以上"
)

@minversion
def test_function():
    pass
```

支持跨模块标记
```py
# skipif_marks.py
import mymodule


minversion = pytest.mark.skipif(
    mymodule.__versioninfo__ < (1,1),reason="至少mymodule-1.1版本以上"
)


# test_demo.py
from skipif_marks.py import minversion


@minversion
def test_function():
    pass
```

####  缺少依赖跳过
模块级别或以下可用
```py
docutils = pytest.importorskip("docutils")  # 没有依赖则跳过
docutils = pytest.importorskip("docutils",minversion="0.3")  # 依赖版本不足跳过
```

### 5. `pytest.mark.usefixtures` 使用类,模块或项目中的Fixture方法
`pytest.mark.usefixtures(args)`
- args- 要使用的fixture的名称,作为字符串


### 6. `pytest.mark.xfail` 将测试函数标记为预期失败
命令行: `pytest -rxXs` / `pytest --runxfail`: 强制运行预期失败(按无标记处理)

`pytest.mark.xfail(condition = None,reason = None,raises = None,run = True,strict = False)`
- condition(bool。
- reason(str) - 测试函数标记为xfail的原因。
- raises(异常) - 期望由测试函数引发的异常子类;其他例外将无法通过测试。
- run(bool) - 如果实际应该执行测试函数。如果False,该函数将始终为xfail并且不会被执行(如果函数是segfaulting则很有用)。
- strict(布尔) 
    - 如果False(默认值),该函数将在终端输出中显示,就xfailed好像它失败一样,就像xpass`它通过一样。在这两种情况下,这都不会导致测试套件整体失败。这对于标记稍后要解决的片状测试(随机失败的测试)特别有用。
    - 如果True,该函数将在终端输出中显示为xfailed失败,但如果它意外通过则将使测试套件失败。这对于标记始终失败的函数特别有用,并且应该有明确的指示它们是否意外地开始通过(例如,库的新版本修复了已知错误)。


运行此测试,在失败时不会报告回溯。终端报告会将其列在“预期失败”(XFAIL)或“意外传递”(XPASS)部分中
```py
@pytest.mark.xfail
def test_function():
    pass


def test_function():
    if not valid_config():
        pytest.xfail("failing configuration (but should work)")  # 若调用该方法,不会继续执行该用例
```

strict参数设置为True, 如果出现xpass，测试套件的结果将视为失败
```py
@pytest.mark.xfail(strict=True)
def test_function():
    pass
```

也可以使用xfail_strict变量配置到pytest.ini文件中
```ini
[pytest]
xfail_strict=true
```

```py
@pytest.mark.xfail(sys.version_info >= (3,6),reason="Python3.6 API变更")
def test_function():
    pass


@pytest.mark.xfail(raises=RuntimeError)
def test_function():
    pass


@pytest.mark.xfail(run=False)
def test_function():
    pass
```

### 7. `pytest.mark` 自定义标记


用例标记
```python
@pytest.mark.smoke # smoke可以进行替换
def func():
    pass
```

标记使用
- 控制台:

```shell
    pytest -m smoke
```
- pytest.main()中使用命令:

```python
    pytest.main("-m", "smoke")
```

### 8. 配置文件pytest.ini

`pytest --markers`查看配置所有
1. 可以在这里做mark的备注
2. 指定测试用例路径
3. 作用域为当前目录及当前目录的下级

```ini
[pytest]
mark=
    mark1: remake
    mark2: remake
testpaths=path
```

#### 2. strict 未知标记引发异常
- 未知标记: 未在pytest.ini声明的既为未知标记
- 使用: `pytest --strict`

ex: 直接在配置文件中设置可默认开启该功能
```ini
[pytest]
addopts = --strict
markers =
    slow
    serial
```

# hook(钩子)方法

## `pytest_assertrepr_compare`自定义断言对比信息

```py
# test_foocompare.py

class Foo(object):
    def __init__(self, val):
        self.val = val

    def __eq__(self, other):
        return self.val == other.val


def test_compare():
    f1 = Foo(1)
    f2 = Foo(2)
    assert f1 == f2
```
```py
# conftest.py
from test_foocompare import Foo


def pytest_assertrepr_compare(op, left, right):
    if isinstance(left, Foo) and isinstance(right, Foo) and op == "==":
        return ['Foo实例对比:',
                '   值: %s != %s' % (left.val, right.val)]

```

## `pytest_generate_tests`自定义生成用例
命令行: 传递2个参数`pytest -vs --stringinput="hello" --stringinput="world" test_sample.py `
- tips: 如果没有传递参数,将跳过使用该参数名的用例

```py
# content of test_strings.py

def test_valid_string(stringinput):  # 用例
    print(stringinput)
    assert stringinput.isalpha()
```
```py
def pytest_addoption(parser):  # 增加命令行参数选项
    print("=========1=========")
    parser.addoption(
        "--stringinput",
        action="append",
        default=[],
        help="list of stringinputs to pass to test functions",
    )

def pytest_generate_tests(metafunc):  # 自定义用例收集
    print("=========1=========")
    if "stringinput" in metafunc.fixturenames:
        print(metafunc.fixturenames)  # 存有参数选项的列表  ['stringinput']
        print(metafunc.config.getoption("stringinput"))  # 取出该(stringinput)选项的值(列表) ['hello', 'world']
        metafunc.parametrize("stringinput",metafunc.config.getoption("stringinput"))  # 将该选项的值生成变量为stringinput的参数化
```

如下方结果可知,`pytest_addoption`运行在最前面,`pytest_generate_tests`运行在collecting阶段

outputs:
```
=========1=========
test_fixture======================== test session starts test_fixture=========================
platform linux -- Python 3.7.5, pytest-6.1.2, py-1.9.0, pluggy-0.13.1 -- /usr/bin/python3.7
cachedir: .pytest_cache
rootdir: /home/qydev012/workspace/demo
plugins: allure-pytest-2.8.6
collecting ... =========1=========
['stringinput']
['hello', 'world']
collected 2 items                                                                                                              

test_sample.py::test_valid_string[hello] hello
PASSED
test_sample.py::test_valid_string[world] world
PASSED

test_fixture========================= 2 passed in 0.01s ====================
```


# plugins 插件
## 安装插件

使用pip安装即可

- `pip install pytest-NAME`
- `pip uninstall pytest-NAME`

### 查看插件列表
`pytest --trace-config`

### 常用插件列表
- pytest-django：为django应用程序编写测试。
- pytest-twisted：为twisted应用程序编写测试,启动反应堆并处理测试函数的延迟。
- pytest-cov：覆盖率报告,与分布式测试兼容
- pytest-xdist：将测试分发到CPU和远程主机,以盒装模式运行,允许分段故障,在looponfailing模式下运行,自动重新运行文件更改的失败测试。
- pytest-instafail：在测试运行期间报告失败。
- pytest-bdd使用行为驱动的测试编写测试。
- pytest-timeout：根据函数标记或全局定义进行超时测试。
- pytest-pep8：--pep8启用PEP8合规性检查的选项。

## 加载插件
方法一: 在测试模块/根目录`conftest.py`文件中指定需要使用插件的元组`pytest_plugins = ("myapp.testsupport.myplugin",)`

方法二: 
- 使用命令行运行/main方法注册插件
- 也可以取消注册插件`pytest -p no:name`

方法三:
- 无条件禁用: `pytest.ini`

```
[pytest]
addopts = -p no:NAME
```

## 插件发现顺序
- 通过加载所有内置插件
- 通过加载通过[setuptools入口点注册的所有插件。
- 通过预扫描选项的命令行并在实际命令行解析之前加载指定的插件。-pname
- 通过conftest.py命令行调用推断加载所有文件：
- 如果未指定测试路径,则使用当前dir作为测试路径
- 如果存在,则加载conftest.py并test*/conftest.py相对于第一个测试路径的目录部分。
- 请注意,pytestconftest.py在工具启动时没有在更深的嵌套子目录中找到文件。将conftest.py文件保存在顶级测试或项目根目录中通常是个好主意。
- 通过递归加载文件中pytest_plugins变量指定的所有插件conftest.py

## 失败重跑

失败重跑需要安装插件：
```shell
    pip install pytest-rerunfailures
```
function/class级别标注重跑参数：
```python
    @pytest.mark.flaky(reruns 5, reruns-delay 3)
```
控制台使用命令：作用域是当前会话全部
```shell
    pytest --reruns num --reruns-delay num 
    # num: 重试的次数 num: 间隔时间(s)
```
pytest.main()中使用命令：
```python
    pytest.main(["--reruns", "num", "--reruns-delay", "num"])
    # num: 重试的次数 num: 间隔时间(s)
```
-- --
## 并发运行

安装：
```shell
    pip install pytest-xdist
```
> 该方法用的是多进程并发
> 支持部署到remote TODO:待研究
> pytest-parallel 该module支持多进程多线程并发 TODO:待研究

使用方法：
pytest.main()中使用命令：
```python
    pytest.main(["-n", "3"]) # 进行三个进程的并发运行
    pytest.main(["-n", "auto"])  # 自动根据CPU确定线程，一般为CPU核心线程数
```
控制台使用命令：
```shell
    pytest -n 3 # 进行三个进程的并发运行
    pytest -n auto # 自动根据CPU确定线程，一般为CPU核心线程数
```
-- --
## allure 测试报告
```shell
  pip install allure-pytest
```
![index](https://upload-images.jianshu.io/upload_images/20499241-eabd309700892d6d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)

控制台使用：
```shell
  pytest -alluredir=path # path为输出报告的路径
```
pytest.main()中使用：
```python
  pytest.main(["--alluredir=path"])  # path为输出报告的路径
```
[allure使用详情](https://www.jianshu.com/p/40a5a005ce01)
