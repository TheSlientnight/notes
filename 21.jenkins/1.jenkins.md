# 1. 简介
本文档重点对pipeline做介绍
## 1. 资料
- 官网: https://www.jenkins.io/
- 文档: https://www.jenkins.io/doc/
- 下载: https://www.jenkins.io/download/
- docker部署文档: https://github.com/jenkinsci/docker/blob/master/README.md
- w3c文档: https://www.w3cschool.cn/jenkins/jenkins-5h3228n2.html
- wiki: https://wiki.jenkins.io/
- 微医devops大佬: https://testerhome.com/cay/topics 讲的非常好我的远逊于他

## 2. 容器化部署
- 基础部署:`docker run -u root -d -v jenkins_home:/var/jenkins_home -p 8080:8080 -p 50000:50000 jenkins/jenkins:lts`
- BlueOcean版jenkins(推荐): `docker run -u root --rm -d -p 8080:8080 -p 50000:50000 -v jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v /etc/localtime:/etc/localtime jenkinsci/blueocean`
    - 50000端口: jenkins TCP port for inbound agents默认端口
2. 查看初始token: `docker logs <jenkins的容器>`

默认状态下jenkins镜像使用的是UTC时间，若要修改时间，查看docker系列文章
## 3. 插件(按需安装)
1. 修改插件源
    - 将插件源改为国内源将会下载更快:插件管理-高级-升级站点
    - 源: `https://mirrors.tuna.tsinghua.edu.cn/jenkins/updates/update-center.json` 

2. `Role-based Authorization Strategy`: 权限矩阵管理
3. `Pipeline Stage View Plugin`: pipeline阶段视图
4. `docker`: 部署slave
5. `SonarQube Scanner for Jenkins`: SonarQube服务端
6. `Sonar Quality Gates Plugin`: Sonar质量阀
7. `Blue Ocean`: 如果安装的非Blue Ocean版 可安装该插件
8. `Credentials Plugin`: 凭证管理

# 2. Jenkins pipeline
- 实践: https://testerhome.com/cay/topics

## 1. 概念理解

1. Jenkins Pipeline总体介绍
- Pipeline，简而言之，就是一台运行于Jenkins上的工作流框架，将原本独立运行于单个或者多个节点的任务连接起来，实现单个任务难以完成的复杂流程编排与可视化。
- Pipeline是Jenkins2.X最核心的特性，帮助Jenkins实现从CI到CD与DevOps的转变。
- 详细介绍可见https://jenkins.io/2.0
2. 什么是Jenkins Pipeline
- Jenkins Pipeline是一组插件，让Jenkins可以实现持续交付管道的落地和实施。
- 持续交付管道（CD Pipeline）是将软件从版本控制阶段到交付给用户或客户的完整过程的自动化表现。
- Pipeline提供了一组可扩展的工具，通过Pipeline Domain Specific Language（DSL）syntax可以达到Pipeline as Code的目的
- Pipeline as Code: Jenkinsfile 存储在项目的源代码库
3. Jenkins Pipeline核心概念
- Stage
    - 阶段，一个Pipeline可以划分为若干个Stage，每个Stage代表一组操作，如:“Build”，“Test”， "Deploy"。
    - 注意，Stage是一个逻辑分组的概念，可以跨多个Node。
- Node
    - 节点，一个Node就是一个Jenkins节点，或者是Master，或者是Agent。是执行Step的具体运行环境 。
- Step
    - 步骤，Step是 最基本的操作单元，小到创建一个目录，大到构建一个Docker镜像，由各类 Jenkins Plugin提供，例如:sh 'make'
 
4. 为什么要用Pipeline？
- 代码（Code）: Pipeline以代码的形式实现，通常被检入源代码控制，是团队能够编辑，审查 和迭代其CD流程。
- 可持续性（Durable）:Jenkins重启或者中断后都不会影响Pipeline Job。
- 可停顿（Pausable）:Pipeline可以选择停止并等待人工输入或者批准，然后再继续Pipeline运行。
- 多功能（Versatile）:Pipeline支持实现现实世界的复杂CD要求，包括fork/join子进程，循环和并行执行工作的能力。
- 可拓展（Extensible）:Pipeline插件支持其DSL的自定义扩展及与其他插件集成的多个选项。

## 2. 语法
- https://www.jenkins.io/doc/book/pipeline/syntax/
- https://www.w3cschool.cn/jenkins/jenkins-jg9528pb.html

- 脚本式语法&声明式语法:
    - Scripted Pipeline极大的灵活性和可扩展性,更专业
    - 声明性Pipeline更简单和更有见解的语法,学习曲线更低(官方推荐)

tips: 1. 本笔记只涉略声明式脚本 2. 下面仅介绍一些常用的代码块,更多使用方法可以看上方链接处的语法介绍

### 0. 模板
```groovy
pipeline {
    agent any // 执行者

    stages {
        stage('Build') {  // 阶段
            steps {  // 步骤
                sh 'make' 
            }
        }
        stage('Test'){
            steps {
                sh 'make check'
                junit 'reports/**/*.xml' 
            }
        }
        stage('Deploy') {
            steps {
                sh 'make publish'
            }
        }
    }
}
```

- Pipeline的顶层必须是块，具体来说是:pipeline { }
- 没有分号作为语句分隔符。每个声明必须在自己的一行
- 块只能包含章节， 指令，步骤或赋值语句。
- 属性引用语句被视为无参数方法调用。所以例如，输入被视为input（）
- 可以要()括号 也可以不使用

### 1. 代码块命令
**jenkins自带语法生成器: `http://jenkinsUrl:Port/pipeline-syntax/`**
![](./images/pipeline_syntax.png)

#### 1. shell命令

```groovy
pipeline {
    agent any
    stages {
        stage('Build') {
            steps {
                sh 'echo "Hello World"' // 执行单条命令
                sh '''
                    echo "Multiline shell steps works too"
                    ls -lah
                '''//执行多条命令
            }
        }
    }
}
```

**也可以进行互相嵌套使用**
```groovy
pipeline {
    agent any
    stages {
        stage('Deploy') {
            steps {
                timeout(time: 3, unit: 'MINUTES') {
                    retry(5) {
                        sh './flakey-deploy.sh'
                    }
                }
            }
        }
    }
}
```

#### 3. post 根据构建状态而执行
![](./images/pipeline_post.png)

```groovy
pipeline {
    agent any
    stages {
        stage('ignore') {
            steps {
                echo "hello_word"
            }
        }
    }
    post { // post部分应放在Pipeline末端
        always {
            echo 'This will always run'
        }
        success {
            echo 'This will run only if successful'
        }
        failure {
            echo 'This will run only if failed'
        }
        unstable {
            echo 'This will run only if the run was marked as unstable'
        }
        changed {
            echo 'This will run only if the state of the Pipeline has changed'
            echo 'For example, if the Pipeline was previously failing but is now successful'
        }
    }   
}
```

- always: 
运行，无论Pipeline运行的完成状态如何。

- changed: 
只有当前Pipeline运行的状态与先前完成的Pipeline的状态不同时，才能运行。

- failure: 
仅当当前Pipeline处于“失败”状态时才运行，通常在Web UI中用红色指示表示。

- success: 
仅当当前Pipeline具有“成功”状态时才运行，通常在具有蓝色或绿色指示的Web UI中表示。

- unstable: 
只有当前Pipeline具有“不稳定”状态，通常由测试失败，代码违例等引起，才能运行。通常在具有黄色指示的Web UI中表示。

- aborted: 
只有当前Pipeline处于“中止”状态时，才会运行，通常是由于Pipeline被手动中止。通常在具有灰色指示的Web UI中表示。



#### 4. agent 代理
以下意思为:启动指定容器并进入执行shell命令
```groovy
pipeline {
    agent none 
    stages {
        stage('Example Build') {
            agent { docker 'maven:3-alpine' } 
            steps {
                echo 'Hello, Maven'
                sh 'mvn --version'
            }
        }
        stage('Example Test') {
            agent { docker 'openjdk:8-jre' } 
            steps {
                echo 'Hello, JDK'
                sh 'java -version'
            }
        }
    }
}
```
- agent none: 在Pipeline顶层定义确保执行者不会被不必要地分配。使用agent none也强制每个stage部分包含自己的agent部分

#### 5. environment 环境变量

```groovy
pipeline {
    agent any

    environment {
        DISABLE_AUTH = 'true'
        DB_ENGINE    = 'sqlite'
    }

    stages {
        stage('Build') {
            steps {
                echo 'DB_ENGINE'
            }
        }
    }
}
```

#### 6. credentials 凭证使用

![](./images/pipeline_token.png)
不同的凭证类型语法上有些许变化，以语法生成器的为准
```groovy
pipeline {
    agent any
    environment {
    // 以下方法仅适用于声明式脚本
    // Secret text
    SONARQUBE_TOKEN = credentials('SONARQUBE_TOKEN')
    // Username with password
    SONARQUBE_ACCESS = credentials('SONARQUBE_ACCESS')
    }
    stages {
        stage('DEMO1') {
            steps {
                // 以下方法仅适用于声明式脚本
                echo ${SONARQUBE_TOKEN}  // 输出token
                echo ${SONARQUBE_ACCESS} // 输出账号和密码
                echo ${SONARQUBE_ACCESS_USR}  // 输出账号
                echo ${SONARQUBE_ACCESS_PSW}  // 输出密码
            }
        }
        stage('DEMO2') {
            steps {
                // 此方法都适用
                withCredentials([string(credentialsId: 'SONARQUBE_TOKEN', variable: 'TOKEN')]) {  // 创建凭证环境
                    echo ${TOKEN}
                }
            }
        }
    }
}

```

#### 7. 通知

安装相关插件可实现邮件发送或者机器人通知
```groovy
post {
    failure {  // 发送邮件
        mail to: 'team@example.com',  // 送达目标
             subject: "Failed Pipeline: ${currentBuild.fullDisplayName}",  //邮件标题
             body: "Something is wrong with ${env.BUILD_URL}" // 正文内容
    }
}
```

#### 8. input 输入
```groovy
stage('Sanity check') {
    steps {
        input "Does the staging environment look ok?"
    }
}
```

#### 9. globals 全局变量
jenkins自带全局变量文档: `http://jenkinsUrl:Port/job/test/pipeline-syntax/globals`

```groovy
pipeline {
    agent any
    stages {
        stage('Example') {
            steps {
                echo "Running ${env.BUILD_ID} on ${env.JENKINS_URL}"
            }
        }
    }
}
```

ex:
- `env.BUILD_ID`: 当前版本ID
- `env.JOB_NAME`: 构建项目的名称
- `env.JENKINS_URL`: 完整的Jenkins网址(需要在系统配置)

#### 10. checkout 检查scm

```groovy
stage('checkout'){
    steps{
        checkout([$class: 'GitSCM', branches: [[name: '*/master']], doGenerateSubmoduleConfigurations: false, extensions: [], submoduleCfg: [], userRemoteConfigs: [[url: 'https://github.com/foo/foo.git']]])
    }
}
```

#### 11. parameters 参数调用
![](./images/jenkins-param2.png)
![](./images/jenkins-param.png)
```groovy
pipeline {
    agent any
    parameters {
        string(name: 'Greeting', defaultValue: 'Hello', description: 'How should I greet the world?')
        booleanParam(name: 'DEBUG_BUILD', defaultValue: true, description: '')
    }
    stages {
        stage('Example') {
            steps {
                echo "${params.Greeting} World!"
                echo "${params.project}" // 调用参数化构建过程中设定的值
            }
        }
    }
}
```

#### 12. stash存放 & unstash取出
```groovy
```
#### 13. triggers 触发器
```groovy
pipeline {
    agent any
    triggers {
    pollSCM '* * * * *'  //  轮询scm
    cron '* * * * *'  // 定时构建
    upstream 'test' // 其他工程构建后触发
    }
    stages {
        stage('Example') {
            steps {
                echo 'Hello World'
            }
        }
    }
}
```

#### 14. tools 工具指定
通过tools可自动安装工具，并放置环境变量到PATH
```groovy
pipeline {
    agent any
    tools {
        sonarscanner 'sonarscanner-01'  // 需要在全局工具配置中设置,且具有多个不同版本的相同工具时使用
    }
    stages {
        stage('Example') {
            steps {
                sh 'sonarscanner'
            }
        }
    }
}
```

#### 15. when 判断

```groovy
pipeline {
    agent any
    stages {
        stage('Example Build') {
            steps {
                echo 'Hello World'
            }
        }
        stage('Example Deploy') {
            when {
                expression { BRANCH_NAME ==~ /(production|staging)/ }
                anyOf {
                    environment name: 'DEPLOY_TO', value: 'production'
                    environment name: 'DEPLOY_TO', value: 'staging'
                }
            }
            steps {
                echo 'Deploying'
            }
        }
    }
}
```
- branch: 
当正在构建的分支与给出的分支模式匹配时执行阶段，例如:`when { branch 'master' }`。请注意，这仅适用于多分支Pipeline。

- environment: 
当指定的环境变量设置为给定值时执行阶段，例如: `when { environment name: 'DEPLOY_TO', value: 'production' }`

- expression: 
当指定的Groovy表达式求值为true时执行阶段，例如: `when { expression { return params.DEBUG_BUILD } }`

- not: 
当嵌套条件为false时执行阶段。必须包含一个条件。例如:`when { not { branch 'master' } }`

- allOf: 
当所有嵌套条件都为真时，执行舞台。必须至少包含一个条件。例如:`when { allOf { branch 'master'; environment name: 'DEPLOY_TO', value: 'production' } }`

- anyOf: 
当至少一个嵌套条件为真时执行舞台。必须至少包含一个条件。例如:`when { anyOf { branch 'master'; branch 'staging' } }`

#### 16. script 支持groovy脚本
支持在声明式脚本中使用复杂的groovy脚本
```groovy
pipeline {
    agent any
    stages {
        stage('Example') {
            steps {
                echo 'Hello World'

                script {
                    def browsers = ['chrome', 'firefox']
                    for (int i = 0; i < browsers.size(); ++i) {
                        echo "Testing the ${browsers[i]} browser"
                    }
                }
            }
        }
    }
}
```

#### 17. parallel 并行执行
```groovy
pipeline {
    agent none
    stages {
        stage('Non-Parallel Stage') {
            steps {
                echo 'This stage will be executed first.'
            }
        }
        stage('Parallel Stage') {
            when {
                branch 'master'
            }
            failFast true  // 以下并行执行 一个失败所有终止
            parallel { // 并行执行
                stage('Branch A') {
                    agent {
                        label "for-branch-a"
                    }
                    steps {
                        echo "On Branch A"
                    }
                }
                stage('Branch B') {
                    agent {
                        label "for-branch-b"
                    }
                    steps {
                        echo "On Branch B"
                    }
                }
                stage('Branch C') {
                    agent {
                        label "for-branch-c"
                    }
                    stages { // 阶段内再嵌套阶段
                        stage('Nested 1') {
                            steps {
                                echo "In stage Nested 1 within Branch C"
                            }
                        }
                        stage('Nested 2') {
                            steps {
                                echo "In stage Nested 2 within Branch C"
                            }
                        }
                    }
                }
            }
        }
    }
}
```

#### 18. build 构建job
![](./images/jenkins-build-job.png)

```groovy
build 'test'
```

#### 其他
```groovy
sleep 20 // 休息20秒
```

### 2. Declarative Directive Generator 声明式命令
#### 1. options Jenkins Pipeline 配置参数

|参数名|说明|例子|
|-|-|-|
|buildDiscarder|保留最近历史构建记录的数量	|buildDiscarder(logRotator(numToKeepStr: '10')|
|checkoutToSubdirectory	|将代码从版本控制库中拉取后，保存在工作目录的子目录|checkoutToSubdirectory('subdir')|
|disableConcurrentBuilds|禁用Jenkins同时执行多次该pipeline|	disableConcurrentBuilds()|
|newContainerPerStage|agent为Docker或Dockerfile时，每个stage都分别运行在一个新容器中|newContainerPerStage()|
|retry|	pipeline发生失败后重试次数	|retry(4)|
|timeout|pipeline运行超时时间|timeout(time:10, unit: 'HOURS')|

1. timeout超时 & retry重试

![](./images/pipeline_timeout.png)
```groovy
pipeline {
    agent any
    options { // 全局
        timeout(time: 1, unit: 'HOURS') 
        retry(3)
    }
    stages {
        stage('Deploy') {
            steps {
                retry(3) {  // 代码块内 重试3次
                    sh './flakey-deploy.sh'
                }

                timeout(time: 3, unit: 'MINUTES') {  // 超时时间(3分钟)
                    sh './health-check.sh'
                }
            }
        }
    }
}
```
unit常用选项:
- SECONDS
- MINUTES
- HOURS
- DAYS


## 3. Jenkinsfile
tips: 
1. Jenkinsfile 名字一定要严格区分大小写

### 1. 多分支流水线
1. 通过blueocean新建流水线
2. 直接创建多分支流水线job

tips: 创建后会自动设置webhook
```groovy
#!/usr/bin/env groovy Jenkinsfile
```

## 4. 共享库share library
相当于已经创建好的库，在Jenkins 系统设置中设置好后可以进行引包操作。使用库中已经封装好的函数。方便多个pipeline使用，也便于维护。
https://www.jenkins.io/doc/book/pipeline/shared-libraries/

鉴于本人暂无使用需求，故在此处埋坑 日后再填

# 3. docker部署 jenkins slave

官方文档: https://plugins.jenkins.io/docker-plugin/

1. 安装`docker`插件
2. 系统管理→节点管理→Configure Clouds
3. 如下图填写相关参数(填写完docker服务器地址 右侧可以进行连接测试)
![](./images/Jenkins-slave-config.png)
4. 创建job，查看job能否创建slave并构建(脚本在下面)

tips: 
1. docker部署的slave每次构建时若无存活slave则会启动新的容器生成新的slave.在构建完成后一小段时间内会自行销毁。
2. 容器会自行销毁但是挂载的其他数据卷则会保留，所以在使用一段时间后应注意占用空间(每次占用极小几k上下)，时间长还是要避免浪费
3. 目标机docker需打开远程访问端口,具体方法可参考docker章节

验证功能是否正常
```groovy
pipeline {
    agent {
        label 'Docker-Slave'
    }
    
    stages {
        stage ('Exec Test Command') {
            steps{
                echo 'Build slave container successful'
                sh 'docker -v'  // 查看slave的docker环境是否正常
                sleep 3
                echo 'Destruction slave container successful'
            }
        }
    }
}
```

# 实践
- 自定义通知器: https://www.cnblogs.com/ssgeek/p/12347315.html